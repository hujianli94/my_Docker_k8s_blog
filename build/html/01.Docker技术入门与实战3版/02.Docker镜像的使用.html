<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Docker镜像的使用 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="操作Docker容器" href="03.%E6%93%8D%E4%BD%9CDocker%E5%AE%B9%E5%99%A8.html" />
    <link rel="prev" title="初识Docker与容器" href="01.%E5%88%9D%E8%AF%86Docker%E4%B8%8E%E5%AE%B9%E5%99%A8.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> 小健_Docker_K8s_Blog
            <img src="../_static/docker-k8s.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">01.Docker技术入门与实战3版</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01.%E5%88%9D%E8%AF%86Docker%E4%B8%8E%E5%AE%B9%E5%99%A8.html">初识Docker与容器</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Docker镜像的使用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">1. 镜像写时复制机制</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">2. 本地镜像管理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">2.1 获取镜像</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">2.2 查看镜像</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">2.3 搜寻镜像</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">2.4 下载镜像</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">2.5 删除镜像</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">2.6 创建本地镜像</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id12">3. 存出和载入镜像</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">4.上传镜像</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#docker-hub">4.1 推送到Docker Hub</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">4.2 推送到腾讯云镜像仓库</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">4.3推送到阿里云镜像仓库</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id16">5. Docker Hub</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id17">5.1 登录</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">5.2 上传镜像</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id20">7. 搭建自己的私有仓库</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">8. 镜像制作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22">9. 系统资源限制配置说明</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="03.%E6%93%8D%E4%BD%9CDocker%E5%AE%B9%E5%99%A8.html">操作Docker容器</a></li>
<li class="toctree-l2"><a class="reference internal" href="04.%E8%AE%BF%E9%97%AEDocker%E4%BB%93%E5%BA%93.html">访问Docker仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="05.%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html">搭建本地私有仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="06.Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86.html">Docker数据管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="07.Docker%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C.html">Docker使用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="08.%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.html">使用Dockerfile创建镜像</a></li>
<li class="toctree-l2"><a class="reference internal" href="09.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B.html">实战案例</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.Docker%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF.html">Docker核心实现技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="11.%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html">配置私有仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="12.%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E4%B8%8E%E9%85%8D%E7%BD%AE.html">安全防护与配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="13.%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD.html">高级网络功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="14.libnetwork%E6%8F%92%E4%BB%B6%E5%8C%96%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD.html">libnetwork插件化网络功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="15.Etcd%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93.html">Etcd高可用的键值数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="16.Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Compose.html">Docker三剑客之Docker-Compose</a></li>
<li class="toctree-l2"><a class="reference internal" href="17.Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Swarm.html">Docker三剑客之Docker-Swarm</a></li>
<li class="toctree-l2"><a class="reference internal" href="18.Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Machine.html">Docker三剑客之Docker-Machine</a></li>
<li class="toctree-l2"><a class="reference internal" href="19.%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAWeb%E5%BA%94%E7%94%A8%E6%A0%88.html">搭建一个Web应用栈</a></li>
<li class="toctree-l2"><a class="reference internal" href="20.Docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E5%AE%9E%E6%88%98.html">Docker高级网络实战</a></li>
<li class="toctree-l2"><a class="reference internal" href="21.%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.html">服务发现</a></li>
<li class="toctree-l2"><a class="reference internal" href="22.Mesos-%E4%BC%98%E7%A7%80%E7%9A%84%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0.html">Mesos—优秀的集群资源调度平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="23.Kubernetes-%E7%94%9F%E4%BA%A7%E7%BA%A7%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%B9%B3%E5%8F%B0.html">Kubernetes-生产级容器集群平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="24.%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE.html">其他相关项目</a></li>
<li class="toctree-l2"><a class="reference internal" href="25.%E9%99%84%E5%BD%95.html">附录</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../02.Kubernetes%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/index.html">02.Kubernetes实战指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03.Docker%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B/index.html">03.Docker经典实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04.Prometheus%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/index.html">04.Prometheus监控运维实战</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05.Kubernetes%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/index.html">05.Kubernetes入门到实践</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">小健_Docker_K8s_Blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">01.Docker技术入门与实战3版</a> &raquo;</li>
      <li>Docker镜像的使用</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/01.Docker技术入门与实战3版/02.Docker镜像的使用.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#docker" id="id23">Docker镜像的使用</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id24">1. 镜像写时复制机制</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id25">2. 本地镜像管理</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id26">2.1 获取镜像</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id27">2.2 查看镜像</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id28">2.3 搜寻镜像</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id29">2.4 下载镜像</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id30">2.5 删除镜像</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id31">2.6 创建本地镜像</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id12" id="id32">3. 存出和载入镜像</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id33">4.上传镜像</a></p>
<ul>
<li><p><a class="reference internal" href="#docker-hub" id="id34">4.1 推送到Docker Hub</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id35">4.2 推送到腾讯云镜像仓库</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id36">4.3推送到阿里云镜像仓库</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id16" id="id37">5. Docker Hub</a></p>
<ul>
<li><p><a class="reference internal" href="#id17" id="id38">5.1 登录</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id39">5.2 上传镜像</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id20" id="id40">7. 搭建自己的私有仓库</a></p></li>
<li><p><a class="reference internal" href="#id21" id="id41">8. 镜像制作</a></p></li>
<li><p><a class="reference internal" href="#id22" id="id42">9. 系统资源限制配置说明</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="docker">
<h1><a class="toc-backref" href="#id23">Docker镜像的使用</a><a class="headerlink" href="#docker" title="Permalink to this heading">¶</a></h1>
<p><strong>镜像</strong>
是Docker三大核心概念中最重要的，自Docker诞生之日起镜像就是相关社区最为热门的关键词。</p>
<p>Docker运行容器前需要本地存在对应的镜像，如果镜像不存在，Docker会尝试先从默认镜像仓库下载（默认使用Docker
Hub公共注册服务器中的仓库），用户也可以通过配置，使用自定义的镜像仓库。</p>
<section id="id1">
<h2><a class="toc-backref" href="#id24">1. 镜像写时复制机制</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>通过 docker run
命令指定镜像创建一个容器时，实际上是在该镜像之上创建一个空的可读写文件系统层级。</p>
<p>可以将这个文件系统当成一个新的临时镜像，而命令里所指定的镜像称为父镜像。父镜像的内容都是以只读方式挂载进来的，容器会读取共享父镜像的内容。</p>
<p>不过一旦需要修改父镜像文件，便会触发Docker从父镜像中复制这个文件到临时镜像中来，所有的修改均发生你的文
件系统中，而不会对父镜像造成任何影响，这就是Docker镜像的写时复制机制。</p>
<p><strong>docker镜像的分层</strong></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 启动一个nginx容器</span>
$ docker run -d -p <span class="m">80</span>:80 --name webserver nginx

<span class="c1"># 从Docker Hub的Ubuntu仓库下载一个最新的Ubuntu操作系统的镜像。</span>
$ docker pull ubuntu

<span class="c1">#*  镜像的latest标签意味着该镜像的内容会跟踪最新的非稳定版本而发布，内容是不稳定的。不要在生产环境中忽略镜像的标签信息或使用默认的latest标记的镜像。</span>

例如，docker pull ubuntu：14.04命令相当于docker pull registry.hub.docker.com/ubuntu：14.04命令，即从默认的注册服务器Docker Hub Registry中的ubuntu仓库来下载标记为14.04的镜像。 如果从非官方的仓库下载，则需要在仓库名称前指定完整的仓库地址。

<span class="c1">#例如从网易蜂巢的镜像源来下载ubuntu：14.04镜像，可以使用如下命令，此时下载的镜像名称为hub.c.163.com/public/ubuntu：14.04：</span>

<span class="c1"># 下载阿里云的镜像</span>
$ docker pull registry.cn-beijing.aliyuncs.com/mysqld/mysql

<span class="c1"># 使用tag命令添加镜像标签</span>
$ docker tag ubuntu:latest myubuntu:latest


<span class="c1">#使用inspect命令查看详细信息</span>
$ docker inspect ubuntu

<span class="c1">#返回的是一个JSON格式的消息，如果我们只要其中一项内容时，可以使用参数-f来指定</span>
$ docker inspect -f <span class="o">{{</span><span class="s2">&quot;.Architecture&quot;</span><span class="o">}}</span> ubuntu


<span class="c1">#使用history命令查看镜像历史</span>
$ docker <span class="nb">history</span> ubuntu

<span class="c1"># 搜寻镜像,在Docker Hub上搜索符合要求的镜像</span>
$ docker search nginx
</pre></div>
</div>
</section>
<section id="id2">
<h2><a class="toc-backref" href="#id25">2. 本地镜像管理</a><a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<section id="id3">
<h3><a class="toc-backref" href="#id26">2.1 获取镜像</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<p>镜像是运行容器的前提，官方的Docker
Hub网站已经提供了数十万个镜像供大家开放下载。本节主要介绍Docker镜像的pull子命令。</p>
<p>可以使用docker[image]pull命令直接从Docker
Hub镜像源来下载镜像。该命令的格式为docker[image]pull NAME[：TAG]。</p>
<p>其中，NAME是镜像仓库名称（用来区分镜像），TAG是镜像的标签（往往用来表示版本信息）。通常情况下，描述一个镜像需要包括“名称+标签”信息。</p>
<p>例如，获取一个Ubuntu 18.04系统的基础镜像可以使用如下的命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker pull ubuntu:18.04
</pre></div>
</div>
<p>对于Docker镜像来说，如果不显式指定TAG，则默认会选择latest标签，这会下载仓库中最新版本的镜像。</p>
<p>下面的例子将从Docker
Hub的Ubuntu仓库下载一个最新版本的Ubuntu操作系统的镜像：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker pull ubuntu
</pre></div>
</div>
<p>该命令实际上下载的就是ubuntu：latest镜像。</p>
<p>下载镜像到本地后，即可随时使用该镜像了，例如利用该镜像创建一个容器，在其中运行bash应用，执行打印“Hello
World”命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run -it ubuntu:18.04 bash
root@65663247040f:/# echo &quot;Hello World&quot;
Hello World
root@65663247040f:/# exit
</pre></div>
</div>
</section>
<section id="id4">
<h3><a class="toc-backref" href="#id27">2.2 查看镜像</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<p><strong>1.使用images命令列出镜像</strong></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>docker image ls
<span class="c1"># 或者</span>
docker images
docker images ubun*

<span class="c1"># 筛选指定标签的镜像</span>
docker images ubuntu
<span class="c1"># 语法支持通配符筛选</span>
docker image ls ubunt*
docker image ls ubunt*:14*

<span class="c1"># 筛选悬空镜像</span>
docker images --filter <span class="s2">&quot;dangling=true&quot;</span>

<span class="c1"># 该命令可用于查询镜像（Images）、容器（Containers）和本地卷（LocalVolumes）等空间使用大户的空间占用情况</span>
$ docker system df
TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              <span class="m">13</span>                  <span class="m">0</span>                   <span class="m">1</span>.763GB             <span class="m">1</span>.763GB <span class="o">(</span><span class="m">100</span>%<span class="o">)</span>
Containers          <span class="m">0</span>                   <span class="m">0</span>                   0B                  0B
Local Volumes       <span class="m">0</span>                   <span class="m">0</span>                   0B                  0B
Build Cache         <span class="m">0</span>                   <span class="m">0</span>                   0B                  0B

<span class="c1"># 具体是哪个镜像、哪个数据卷占用了空间，这时可以通过-v参数来实现：</span>
$ docker system df -v
</pre></div>
</div>
<p><strong>2.使用tag命令添加镜像标签</strong></p>
<p>为了方便在后续工作中使用特定镜像，还可以使用docker
tag命令来为本地镜像任意添加新的标签。例如，添加一个新的myubuntu：latest镜像标签：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker tag ubuntu:latest myubuntu:latest
</pre></div>
</div>
<p>再次使用docker
images列出本地主机上镜像信息，可以看到多了一个myubuntu：latest标签的镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY           TAG           IMAGE ID           CREATED             SIZE
ubuntu               <span class="m">18</span>.04         452a96d81c30       <span class="m">2</span> weeks ago         <span class="m">79</span>.6MB
ubuntu               latest        452a96d81c30       <span class="m">2</span> weeks ago         <span class="m">79</span>.6MB
myubuntu             latest        452a96d81c30       <span class="m">2</span> weeks ago         <span class="m">79</span>.6MB
</pre></div>
</div>
<p><strong>3.使用inspect命令查看详细信息</strong></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker image inspect ubuntu:18.04
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">&quot;Id&quot;</span>: <span class="s2">&quot;sha256:452a96d81c30a1e426bc250428263ac9ca3f47c9bf086f876d11cb39cf57aeec&quot;</span>,
        <span class="s2">&quot;RepoTags&quot;</span>: <span class="o">[</span>
            <span class="s2">&quot;ubuntu:18.04&quot;</span>,
            <span class="s2">&quot;ubuntu:latest&quot;</span>
        <span class="o">]</span>,
        <span class="s2">&quot;RepoDigests&quot;</span>: <span class="o">[</span>
            <span class="s2">&quot;ubuntu@sha256:c8c275751219dadad8fa56b3ac41ca6cb22219ff117ca98fe82b42f24e1ba64e&quot;</span>
        <span class="o">]</span>,
        <span class="s2">&quot;Parent&quot;</span>: <span class="s2">&quot;&quot;</span>,
        <span class="s2">&quot;Comment&quot;</span>: <span class="s2">&quot;&quot;</span>,
        <span class="s2">&quot;Created&quot;</span>: <span class="s2">&quot;2018-04-27T23:28:36.319694807Z&quot;</span>,
        ...
<span class="o">]</span>
</pre></div>
</div>
<p>上面代码返回的是一个JSON格式的消息，如果我们只要其中一项内容时，可以使用-f来指定，例如，获取镜像的Architecture：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker image inspect -f <span class="o">{{</span><span class="s2">&quot;.Architecture&quot;</span><span class="o">}}</span> ubuntu:14.04
amd64
</pre></div>
</div>
<p><strong>4.使用history命令查看镜像历史</strong></p>
<p>既然镜像文件由多个层组成，那么怎么知道各个层的内容具体是什么呢？这时候可以使用history子命令，该命令将列出各层的创建信息。</p>
<p>例如，查看ubuntu：18.04镜像的创建过程，可以使用如下命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker history ubuntu:18.04
IMAGE        CREATED       CREATED BY              SIZE                   COMMENT
452a96d81c30 5 weeks ago   /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]           0B
&lt;missing&gt;    5 weeks ago   /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &#39;do… 7B
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">注意，过长的命令被自动截断了，可以使用前面提到的--no-trunc选项来输出完整命令。</span></code></p>
</section>
<section id="id5">
<h3><a class="toc-backref" href="#id28">2.3 搜寻镜像</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>使用docker search命令可以搜索Docker Hub官方仓库中的镜像。语法为docker
search[option]keyword。支持的命令选项主要包括：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·-f，--filter filter：过滤输出内容；

·--format string：格式化输出内容；

·--limit int：限制输出结果个数，默认为25个；

·--no-trunc：不截断输出结果。
</pre></div>
</div>
<p>例如，搜索官方提供的带nginx关键字的镜像，如下所示：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker search --filter<span class="o">=</span>is-official<span class="o">=</span><span class="nb">true</span> nginx
NAME DESCRIPTION STARS OFFICIAL AUTOMATED
nginx Official build of Nginx. <span class="m">7978</span> <span class="o">[</span>OK<span class="o">]</span>
kong Open-source Microservice <span class="p">&amp;</span> API Management la… <span class="m">159</span> <span class="o">[</span>OK<span class="o">]</span>
</pre></div>
</div>
<p>再比如，搜索所有收藏数超过4的关键词包括tensorflow的镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker search --filter<span class="o">=</span><span class="nv">stars</span><span class="o">=</span><span class="m">4</span> tensorflow
NAME DESCRIPTION STARS OFFICIAL AUTOMATED
tensorflow/tensorflow Official docker images <span class="k">for</span> deep learning fra…   <span class="m">760</span>
xblaster/tensorflow-jupyter Dockerized Jupyter with tensorflow <span class="m">47</span> <span class="o">[</span>OK<span class="o">]</span>
jupyter/tensorflow-notebook Jupyter Notebook Scientific Python Stack w/ …   <span class="m">46</span>
romilly/rpi-docker-tensorflow Tensorflow and Jupyter running <span class="k">in</span> docker con…   <span class="m">16</span>
floydhub/tensorflow tensorflow <span class="m">8</span> <span class="o">[</span>OK<span class="o">]</span>
erroneousboat/tensorflow-python3-jupyter Docker container with python <span class="m">3</span> version of te…   <span class="m">8</span> <span class="o">[</span>OK<span class="o">]</span>
tensorflow/tf_grpc_server Server <span class="k">for</span> TensorFlow GRPC Distributed Runti…   <span class="m">5</span>
</pre></div>
</div>
<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受欢迎程度）、是否官方创建、是否自动创建等。默认的输出结果将按照星级评价进行排序。</p>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id29">2.4 下载镜像</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 首先本地搜索ubuntu镜像，如果没有就去Docker Hub上拉取ubuntu镜像</span>
$ docker run ubuntu <span class="nb">echo</span> <span class="s2">&quot;hello docker&quot;</span>

<span class="c1"># 搜索符合要求的镜像</span>
$ docker serach wordpress


<span class="c1"># 可以预先拉取镜像，放置到本地</span>
$ docker pull ubuntu
</pre></div>
</div>
</section>
<section id="id7">
<h3><a class="toc-backref" href="#id30">2.5 删除镜像</a><a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1">#1.使用标签删除镜像</span>
$ docker rmi myubuntu:latest
<span class="c1"># 或者</span>
$ docker image rm <span class="m">172</span>.16.32.12:9090/jenkinsci/citest:50


<span class="c1">#2.使用镜像ID删除镜像</span>
$ docker rmi 91e7d180c6a3

<span class="c1">#想强行删除镜像，可以使用-f参数</span>
$ docker rmi -f 47b19964fb50


<span class="c1">#通常并不推荐使用-f参数来强制删除一个存在容器依赖的镜像。正确的做法是，先删除依赖该镜像的所有容器，再来删除镜像</span>
$ docker rm e90b01fe1248
e90b01fe1248

<span class="c1"># 删除本地停止运行的容器，一次性删除无用的容器对镜像的依赖</span>
$ docker rm <span class="k">$(</span>docker ps -a -q<span class="k">)</span>

<span class="c1"># 删除所有镜像</span>
$ docker rmi -f <span class="k">$(</span>docker images<span class="p">|</span>grep -v REPOSITORY<span class="p">|</span>awk <span class="s1">&#39;{print $1&quot;:&quot;$2}&#39;</span><span class="k">)</span>

<span class="c1"># 清理悬空镜像</span>
$ docker rmi <span class="k">$(</span>docker images -f <span class="s2">&quot;dangling=true&quot;</span> -q<span class="k">)</span>

<span class="c1"># 批量清理按label筛选的镜像</span>
$ docker rmi <span class="k">$(</span>docker images --filter <span class="s2">&quot;label=MAINTAINER=hujianli@qq.com&quot;</span> -q<span class="k">)</span>

<span class="c1"># 清理未使用的镜像</span>
$ docker system prune

<span class="c1"># 筛选着进行删除</span>
$ docker stop <span class="k">$(</span>docker ps -a <span class="p">|</span> grep <span class="s2">&quot;Exited&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $1 }&#39;</span><span class="k">)</span>  //停止容器
$ docker rm <span class="k">$(</span>docker ps -a <span class="p">|</span> grep <span class="s2">&quot;Exited&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $1 }&#39;</span><span class="k">)</span>  //删除容器
$ docker rmi <span class="k">$(</span>docker images <span class="p">|</span> grep <span class="s2">&quot;none&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $3}&#39;</span><span class="k">)</span>  //删除镜像

<span class="c1"># 清理无容器使用的镜像</span>
$ docker image prune -a
</pre></div>
</div>
<p>使用Docker一段时间后，系统中可能会遗留一些临时的镜像文件，以及一些没有被使用的镜像，可以通过docker
image prune命令来进行清理。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>支持选项包括：
·-a，-all：删除所有无用镜像，不光是临时镜像；
·-filter filter：只清理符合给定过滤器的镜像；
·-f，-force：强制删除镜像，而不进行提示确认。
</pre></div>
</div>
<p>例如，如下命令会自动清理临时的遗留镜像文件层，最后会提示释放的存储空间：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker image prune -f
</pre></div>
</div>
<section id="id8">
<h4>清理删除未被使用的镜像<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h4>
<p>描述 cicd
持久化部署节点越来越多的镜像，磁盘空间越来越不够，这时需要做一个定时清理没有使用的镜像。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>选项
参数  描述
--all , -a  Remove all unused images, not just dangling ones -----删除所有未使用的映像，而不仅仅是悬空映像
--filter    Provide filter values (e.g. ‘until=&#39;) -----提供过滤值（例如&#39;until =“）
--force , -f    Do not prompt for confirmation -----不要提示确认
until           仅删除在给定时间戳之前创建的映像
</pre></div>
</div>
</section>
<section id="id9">
<h4>定时任务清理<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h4>
<p>清理10天前创建且当前无容器实例使用的镜像</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cat &gt;&gt; /var/spool/cron/crontabs/root <span class="s">&lt;&lt; EOF</span>
<span class="s"># 每周一清理无效镜像</span>
<span class="s">* * * * 1 /usr/bin/docker image prune -a --force --filter &quot;until=240h&quot; 2&gt;&amp;1</span>
<span class="s">EOF</span>
</pre></div>
</div>
<p>参考文献：</p>
<p><a class="reference external" href="https://www.akiraka.net/linux/docker/502.html">https://www.akiraka.net/linux/docker/502.html</a></p>
</section>
</section>
<section id="id10">
<h3><a class="toc-backref" href="#id31">2.6 创建本地镜像</a><a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<section id="commit">
<h4>1.基于已有容器commit创建<a class="headerlink" href="#commit" title="Permalink to this heading">¶</a></h4>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@hujianli-docker01 centos<span class="o">]</span><span class="c1"># docker run -it ubuntu</span>

root@d78a1c4c8541:/# apt-get update

<span class="c1">#安装sqlite3</span>
root@d78a1c4c8541:/# apt-get install sqlite3
root@d78a1c4c8541:/# <span class="nb">echo</span> <span class="s2">&quot;test docker commit&quot;</span> &gt;&gt; hellodocker
root@d78a1c4c8541:/# cat hellodocker
<span class="nb">test</span> docker commit
root@d78a1c4c8541:/# <span class="nb">exit</span>
<span class="nb">exit</span>

<span class="c1">#记住上面退出时候的容器id：d78a1c4c8541</span>

<span class="c1"># 使用 commit 命令将容器里的所有修改提交到本地库中，形成一个全新的镜像</span>
<span class="o">[</span>root@hujianli-docker01 centos<span class="o">]</span><span class="c1"># docker commit -m=&quot;Message&quot; --author=&quot;hujianli&quot; d78a1c4c8541 hjl_ubuntu/sqlite3:v1</span>
sha256:3b450d854758de25b3b90fe30692d55bce75a318136ea7ec48dddbe38fc059a1


<span class="o">[</span>root@hujianli-docker01 centos<span class="o">]</span><span class="c1"># docker images</span>
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
hjl_ubuntu/sqlite3       v1                  3b450d854758        <span class="m">54</span> seconds ago      <span class="m">95</span>.6MB
ubuntu                   latest              4c108a37151f        <span class="m">2</span> weeks ago         <span class="m">64</span>.2MB
portworx/px-enterprise   <span class="m">2</span>.0.3.7             a63b970ac332        <span class="m">2</span> weeks ago         <span class="m">2</span>.51GB
quay.io/coreos/etcd      latest              61ad63875109        <span class="m">12</span> months ago       <span class="m">39</span>.5MB

<span class="c1"># 我们使用刚才创建的镜像来构建一个容器并运行，以检视所做的修改</span>
<span class="o">[</span>root@hujianli-docker01 centos<span class="o">]</span><span class="c1"># docker run -it hjl_ubuntu/sqlite3:v1</span>
root@aa51b9edac11:/# cat hellodocker
<span class="nb">test</span> docker commit

root@aa51b9edac11:/# sqlite3 -version
<span class="m">3</span>.22.0 <span class="m">2018</span>-01-22 <span class="m">18</span>:45:57 0c55d179733b46d8d0ba4d88e01a25e10677046ee3da1d5b1581e86726f2alt1
</pre></div>
</div>
</section>
<section id="id11">
<h4>2.基于本地模板导入<a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h4>
<p>用户也可以直接从一个操作系统模板文件导入一个镜像，主要使用docker[container]import命令。</p>
<p>命令格式为docker[image]import[OPTIONS]file|URL|-[REPOSITORY[：TAG]]</p>
<p>要直接导入一个镜像，可以使用OpenVZ提供的模板来创建，或者用其他已导出的镜像模板来创建。</p>
<p>OPENVZ模板的下载地址为http://download.openvz.org/template/precreated/</p>
<p>例如，下载了centos-7-x86_64的模板压缩包，之后使用以下命令导入即可：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ wget -c https://download.openvz.org/template/precreated/centos-7-x86_64.tar.gz
$ cat centos-7-x86_64.tar.gz <span class="p">|</span> docker import - centos:7
</pre></div>
</div>
<p>然后查看新导入的镜像，已经在本地存在了：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY                                                 TAG        IMAGE ID       CREATED         SIZE
centos                                                     <span class="m">7</span>          7c5119718b64   <span class="m">8</span> seconds ago   589MB
</pre></div>
</div>
</section>
<section id="dockerfile">
<h4>3.基于Dockerfile创建<a class="headerlink" href="#dockerfile" title="Permalink to this heading">¶</a></h4>
<p>基于Dockerfile创建是最常见的方式。Dockerfile是一个文本文件，利用给定的指令描述基于某个父镜像创建新镜像的过程。</p>
<p>下面给出Dockerfile的一个简单示例，基于debian：stretch-slim镜像安装Python
3环境，构成一个新的python：3镜像：</p>
<p><code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code></p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="w"> </span><span class="s">debian:stretch-slim</span>
<span class="k">LABEL</span><span class="w"> </span><span class="nv">version</span><span class="o">=</span><span class="s2">&quot;1.0&quot;</span> <span class="nv">maintainer</span><span class="o">=</span><span class="s2">&quot;docker user &lt;docker_user@github&gt;&quot;</span>
<span class="k">RUN</span><span class="w"> </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\</span>
    apt-get install -y python3 <span class="o">&amp;&amp;</span> <span class="se">\</span>
    apt-get clean <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -rf /var/lib/apt/lists/*
</pre></div>
</div>
<p>创建镜像的过程可以使用docker[image]build命令，编译成功后本地将多出一个python：3镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker <span class="o">[</span>image<span class="o">]</span> build -t python:3 .
...
Successfully built 4b10f46eacc8
Successfully tagged python:3
$ docker images<span class="p">|</span>grep python
python <span class="m">3</span> 4b10f46eacc8 About a minute ago   <span class="m">95</span>.1MB
</pre></div>
</div>
<p>推荐使用Dockerfile来构建镜像。将需要对镜像进行的操作全部
写到一个文件中，然后使用 docker build
命令从这个文件中创建镜像。这种方法可以使镜像的创
建变得透明和独立化，并且创建过程可以被重复执行。</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="c"># Version: 1.0.1</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">ubuntu:latest</span>
<span class="k">MAINTAINER</span><span class="w"> </span><span class="s">xxh &quot;xxh@qq.com&quot;</span>
<span class="c">#设置root用户为后续命令的执行者</span>
<span class="k">USER</span><span class="w"> </span><span class="s">root</span>

<span class="c">#执行操作</span>
<span class="k">RUN</span><span class="w"> </span>apt-get update
<span class="k">RUN</span><span class="w"> </span>apt-get install -y nginx

<span class="c">#使用&amp;&amp;拼接命令</span>
<span class="k">RUN</span><span class="w"> </span>touch test.txt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;abc&quot;</span> &gt;&gt; abc.txt

<span class="c">#对外暴露端口</span>
<span class="k">EXPOSE</span><span class="w"> </span><span class="s">80 8080 1038</span>

<span class="c">#添加文件</span>
<span class="k">ADD</span><span class="w"> </span>abc.txt /opt/

<span class="c">#添加文件夹</span>
<span class="k">ADD</span><span class="w"> </span>/webapp /opt/webapp

<span class="c">#添加网络文件</span>
<span class="k">ADD</span><span class="w"> </span>https://www.baidu.com/img/bd_logo1.png /opt/


<span class="c">#设置环境变量</span>
<span class="k">ENV</span><span class="w"> </span><span class="nv">WEBAPP_PORT</span><span class="o">=</span><span class="m">9090</span>

<span class="c">#设置工作目录</span>
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/opt/</span>

<span class="c">#设置启动命令</span>
<span class="k">ENTRYPOINT</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;ls&quot;</span><span class="p">]</span>

<span class="c">#设置启动参数</span>
<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;-a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;-l&quot;</span><span class="w"> </span><span class="p">]</span>

<span class="c">#设置卷</span>
<span class="k">VOLUME</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;/data&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;/var/www&quot;</span><span class="p">]</span>

<span class="c">#设置子镜像的触发操作</span>
<span class="k">ONBUILD</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span>. /app/src
<span class="k">ONBUILD</span><span class="w"> </span><span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">&quot;on build excuted&quot;</span> &gt;&gt; onbuild.txt
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-t</span> <span class="pre">xixihe/test:v1</span> <span class="pre">.</span></code></p>
<p>其中 -t 参数用来指定镜像的命名空间、仓库名及 TAG
。这个值可以在镜像创建成功之后通过 tag 命
令修改，事实上是创建一个镜像的两个名称引用，如下所示的 xixihe/test:v1 和
xixihe/test:v2指向的是同一个镜像实体 8758374dc545 ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">tag</span> <span class="n">xixihe</span><span class="o">/</span><span class="n">test</span><span class="p">:</span><span class="n">v1</span> <span class="n">xixihe</span><span class="o">/</span><span class="n">test</span><span class="p">:</span><span class="n">v2</span>

<span class="c1"># docker images</span>
<span class="n">REPOSITORY</span> <span class="n">TAG</span> <span class="n">IMAGE</span> <span class="n">ID</span> <span class="n">CREATED</span> <span class="n">VIRTUAL</span> <span class="n">SIZE</span>
<span class="n">xixihe</span><span class="o">/</span><span class="n">test</span> <span class="n">v2</span> <span class="mi">8758374</span><span class="n">dc545</span> <span class="mi">5</span> <span class="n">minutes</span> <span class="n">ago</span> <span class="mf">192.7</span> <span class="n">MB</span>
<span class="n">xixihe</span><span class="o">/</span><span class="n">test</span> <span class="n">v1</span> <span class="mi">8758374</span><span class="n">dc545</span> <span class="mi">5</span> <span class="n">minutes</span> <span class="n">ago</span> <span class="mf">192.7</span> <span class="n">MB</span>
<span class="n">ubuntu</span> <span class="n">latest</span> <span class="mi">9</span><span class="n">bd07e480c5b</span> <span class="mi">6</span> <span class="n">days</span> <span class="n">ago</span> <span class="mf">192.7</span> <span class="n">MB</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="id12">
<h2><a class="toc-backref" href="#id32">3. 存出和载入镜像</a><a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h2>
<p>存出镜像</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker save -o ubuntu_14.04.tar ubuntu:14.04
<span class="c1">#用户就可以通过复制ubuntu_14.04.tar文件将该镜像分享给他人使用了</span>
</pre></div>
</div>
<p>载入镜像</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker load --input ubuntu_14.04.tar
<span class="c1">#或者</span>
$ docker load &lt; ubuntu_14.04.tar
</pre></div>
</div>
<p>这将导入镜像及其相关的元数据信息（包括标签等）。导入成功后，可以使用docker
images命令进行查看，与原镜像一致。</p>
</section>
<section id="id13">
<h2><a class="toc-backref" href="#id33">4.上传镜像</a><a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h2>
<section id="docker-hub">
<h3><a class="toc-backref" href="#id34">4.1 推送到Docker Hub</a><a class="headerlink" href="#docker-hub" title="Permalink to this heading">¶</a></h3>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="m">1</span>. 登录Docker Hub
<span class="m">2</span>. 推送镜像（如果命名空间不一致，就需要使用“docker tag”命令修改名称和标签）。
<span class="m">3</span>. docker push <span class="m">1879324764</span>/myubuntu:latest
</pre></div>
</div>
</section>
<section id="id14">
<h3><a class="toc-backref" href="#id35">4.2 推送到腾讯云镜像仓库</a><a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h3>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker login --username <span class="o">{</span>用户名<span class="o">}</span> ccr.ccs.tencentyun.com
$ docker tag dingtalk.net ccr.css.tencentyun.com/xinlai/dingtalk.net
$ docker images ccr.ccs.tencentyun.com/xinlai/ding*
$ docker push ccr.css.tencentyun.com/xinlai/dingtalk.net
</pre></div>
</div>
</section>
<section id="id15">
<h3><a class="toc-backref" href="#id36">4.3推送到阿里云镜像仓库</a><a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h3>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="m">1</span>. 登录阿里云Docker Registry
$ sudo docker login --username<span class="o">=</span>hujianli_722 registry.cn-hangzhou.aliyuncs.com
// 密码提示：adminXXXX

<span class="m">2</span>. 从Registry中拉取镜像
$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/devops_hu/devops_hu:<span class="o">[</span>镜像版本号<span class="o">]</span>

<span class="m">3</span>. 将镜像推送到Registry
$ sudo docker login --username<span class="o">=</span>hujianli_722 registry.cn-hangzhou.aliyuncs.com
$ sudo docker tag <span class="o">[</span>ImageId<span class="o">]</span> registry.cn-hangzhou.aliyuncs.com/devops_hu/devops_hu:<span class="o">[</span>镜像版本号<span class="o">]</span>
$ sudo docker push registry.cn-hangzhou.aliyuncs.com/devops_hu/devops_hu:<span class="o">[</span>镜像版本号<span class="o">]</span>
</pre></div>
</div>
</section>
</section>
<section id="id16">
<h2><a class="toc-backref" href="#id37">5. Docker Hub</a><a class="headerlink" href="#id16" title="Permalink to this heading">¶</a></h2>
<p>Docker
Hub的网址是https://hub.docker.com，它与提供源代码托管服务的GitHub类似，</p>
<p>不同的是Docker Hub提供的是镜像托管服务。利用Docker
Hub，我们可以搜索、创建、分享和管理镜像，
还可以利用其提供的自动化构建技术直接在集群云服务器上构建镜像</p>
<p>Docker Hub上的镜像分为两类。一类是官方镜像，比如 ubuntu 、 nginx 、
redis 、 mysql 、 wordpress
等，此类镜像一般由权威的第三方（比如Canonical、Oracle、Red
Hat等极具背景的大公司）进行
开发维护，最后还需要Docker官方认证通过。另一类为普通用户镜像。</p>
<section id="id17">
<h3><a class="toc-backref" href="#id38">5.1 登录</a><a class="headerlink" href="#id17" title="Permalink to this heading">¶</a></h3>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 登录Docker Hub账号</span>
$ docker login

<span class="c1"># 登录信息都保存在/root/.docker/config.json文件中：</span>
$ cat ~/.docker/config.json
<span class="o">{</span>
    <span class="s2">&quot;auths&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;https://index.docker.io/v1/&quot;</span>: <span class="o">{</span>
            <span class="s2">&quot;auth&quot;</span>: <span class="s2">&quot;MTg3OTMyNDc2NDphZG1pbiMxMjM=&quot;</span>
        <span class="o">}</span>
    <span class="o">}</span>,
    <span class="s2">&quot;HttpHeaders&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;User-Agent&quot;</span>: <span class="s2">&quot;Docker-Client/18.09.7 (linux)&quot;</span>
    <span class="o">}</span>
</pre></div>
</div>
<p>登录成功之后，使用 push 命令上传镜像。如果不指定镜像 TAG
，指定的仓库在本地的所有镜像都会上传到Docker Hub。</p>
</section>
<section id="id18">
<span id="id19"></span><h3><a class="toc-backref" href="#id39">5.2 上传镜像</a><a class="headerlink" href="#id18" title="Permalink to this heading">¶</a></h3>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1">#可以使用docker push命令上传镜像到仓库，默认上传到Docker Hub官方仓库</span>
docker push NAME<span class="o">[</span>:TAG<span class="o">]</span> <span class="p">|</span> <span class="o">[</span>REGISTRY_HOST<span class="o">[</span>:REGISTRY_PORT<span class="o">]</span>/<span class="o">]</span>NAME<span class="o">[</span>:TAG<span class="o">]</span>

sudo docker login
<span class="c1">#先得添加新的标签</span>
docker tag ubuntu:14.04 <span class="m">1879324764</span>/ubuntu_test:14.04
<span class="c1">#然后将新添加标签的image上传到DockerHub上</span>
docker push <span class="m">1879324764</span>/ubuntu_test:14.04
</pre></div>
</div>
<p>举例说明</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#查看镜像
[root@pxe-server ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hu_tomcat_001       latest              fb758b420be9        4 weeks ago         1.49GB
mariadb             latest              1813edbc6da2        4 weeks ago         1GB


# 镜像改名，改为 DockerHubaccount/镜像名:版本Tag
[root@pxe-server ~]# docker tag mariadb:latest 1879324764/mariadb:latest


[root@pxe-server ~]# docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
hu_tomcat_001        latest              fb758b420be9        4 weeks ago         1.49GB
1879324764/mariadb   latest              1813edbc6da2        4 weeks ago         1GB
mariadb              latest              1813edbc6da2        4 weeks ago         1GB

# 登录DcokerHub，使用DockerHubaccount和密码
[root@pxe-server ~]# docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https://hub.docker.com to create
one.Username: 1879324764
Password:
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded

# 推送镜像到DockerHub上
[root@pxe-server ~]# docker push 1879324764/mariadb
</pre></div>
</div>
<p>第一次上传时，会提示输入登录信息或进行注册，之后登录信息会记录到本地~/.docker目录下。</p>
</section>
</section>
<section id="id20">
<h2><a class="toc-backref" href="#id40">7. 搭建自己的私有仓库</a><a class="headerlink" href="#id20" title="Permalink to this heading">¶</a></h2>
<p>除了使用Docker官方提供的注册服务器Docker
Hub来存储管理镜像之外，我们还可以搭建自 己的注册服务器。Docker
Hub所使用的注册服务器本身是开源的，并且以镜像的形式分发在 Docker Hub上。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>注册服务器源码的地址是https://github.com/docker/docker-registry，
Docker Hub上的镜像名是 registry
</pre></div>
</div>
<p>我们只需要两步,就能完成注册服务器的创建</p>
<p>①拉取最新的registry官方镜像：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker pull registry</span>
</pre></div>
</div>
<p>②运行registry：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker run -p 5000:5000 -d -i -t registry</span>
</pre></div>
</div>
<p>这样我们的注册服务器就已经成功地在5000端口运行了。接下来，可以将我们的镜像提交到,这个注册服务器上。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>我们使用 commit 命令将任意一个容器提交成镜像，
并且按照[registry_host: registry_port\image_name:image_tag]方式指定TAG：
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># docker ps -a
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS
NAMES
...
56d26c54b98f    registry:latest &quot;docker-registry&quot; 9 minutes ago Exited (3) 9 minutes ago
pensive_davinci
...


# docker commit 56d26c54b98f 127.0.0.1:5000/my_image:v1
e35c26122c2ada4f2fb1a84542c3a0ec9e1e0dc191949e01cf5ba43da6aef410


接下来，提交这个镜像到注册服务器：
# docker push 127.0.0.1:5000/my_image:v1
</pre></div>
</div>
</section>
<section id="id21">
<h2><a class="toc-backref" href="#id41">8. 镜像制作</a><a class="headerlink" href="#id21" title="Permalink to this heading">¶</a></h2>
<p>操作系统基础镜像制作目前，具有一定规模的企业都会自己制作操作系统镜像，而不是直接使用公有Hub上的镜像或者从镜像提供商的网站下载并直接使用，主要原因如下：</p>
<p>1）下载的容器镜像文件过大，浪费空间，执行效率低。</p>
<p>2）下载的容器镜像过小，不少驱动、工具或文件在容器镜像中并没有包括，不能满足应用的要求。</p>
<p>3）镜像文件没有遵循企业的规范。</p>
<p>4）外部下载的容器镜像存在安全漏洞。</p>
<p>5）操作系统版本同企业用的主流版本不一致。因此企业需要掌握操作系统基础镜像的制作技能并制定出相关的规范，以满足企业的基本要求。操作系统基础镜像属于容器镜像的base
image，其他镜像都是这个镜像的上层镜像。由于容器共享宿主机操作系统的内核，rootfs使用宿主机，因此操作系统基础镜像中主要包括rootfs、rpm工具包及常用命令等。</p>
<p><strong>操作系统镜像制作过程</strong></p>
<p>制作过程</p>
<p>1）重新安装或利用现有RHEL7.4（3.10.0-693.el7.86_64）操作系统的主机。</p>
<p>2）根据宿主机操作系统的安装要求进行相关的参数配置，如文件句柄数等。</p>
<p>3）在该主机上安装Docker，原因是使用docker import生成镜像时需要Docker。</p>
<p>4）在该机器根目录下创建tmp目录，将需要复制到镜像的原始文件复制到此目录下。</p>
<p>5）在tmp目录下建立临时目录。</p>
<p>6）读取rpm包列表，使用yum命令在tmp目录安装文件系统和软件包。</p>
<p>7）将tmp目录tar打包并通过docker import导入本地镜像文件后上传到镜像仓库。</p>
<p>8）清理tmp临时目录。</p>
<p>其中第6、7两步可以通过执行makeImageForRedhat.sh脚本完成。</p>
<p>■ 制作脚本makeImageForRedhat.sh下载地址：</p>
<p><a class="reference external" href="https://pan.baidu.com/s/13tm-xRJz8LjHV3KtRxPVKw">https://pan.baidu.com/s/13tm-xRJz8LjHV3KtRxPVKw</a>，密码：jgwh。</p>
</section>
<section id="id22">
<h2><a class="toc-backref" href="#id42">9. 系统资源限制配置说明</a><a class="headerlink" href="#id22" title="Permalink to this heading">¶</a></h2>
<p>通过修改/etc/security/limit.conf文件可限制用户同一时刻打开文件数和开启进程数等。</p>
<p>容器技术进行资源限制的方法有两种：</p>
<p>1）修改<code class="docutils literal notranslate"><span class="pre">/usr/lib/systemd/system/docker.service</span></code>文件可实现全局性控制，docker
deamon控制下的容器都是按照配置来限制资源。</p>
<p>2）docker run提供了–ulimit参数，可针对每个容器使用的资源进行差异化限制。</p>
<p>但是，通常情况下用户都不会使用上述两种方法进行资源限制，因为根据容器系统启动加载的原理，bootfs仅会加载宿主机/etc/security/limit.conf配置，而非容器内的limit.conf文件来限制资源的使用，因此只需要正确配置宿主机limit.conf即可，镜像中的limit.conf文件不起作用。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="01.%E5%88%9D%E8%AF%86Docker%E4%B8%8E%E5%AE%B9%E5%99%A8.html" class="btn btn-neutral float-left" title="初识Docker与容器" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="03.%E6%93%8D%E4%BD%9CDocker%E5%AE%B9%E5%99%A8.html" class="btn btn-neutral float-right" title="操作Docker容器" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>