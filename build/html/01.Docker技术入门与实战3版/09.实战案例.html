<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>实战案例 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Docker核心实现技术" href="10.Docker%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF.html" />
    <link rel="prev" title="使用Dockerfile创建镜像" href="08.%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> 小健_Docker_K8s_Blog
            <img src="../_static/docker-k8s.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">01.Docker技术入门与实战3版</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01.%E5%88%9D%E8%AF%86Docker%E4%B8%8E%E5%AE%B9%E5%99%A8.html">初识Docker与容器</a></li>
<li class="toctree-l2"><a class="reference internal" href="02.Docker%E9%95%9C%E5%83%8F%E7%9A%84%E4%BD%BF%E7%94%A8.html">Docker镜像的使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="03.%E6%93%8D%E4%BD%9CDocker%E5%AE%B9%E5%99%A8.html">操作Docker容器</a></li>
<li class="toctree-l2"><a class="reference internal" href="04.%E8%AE%BF%E9%97%AEDocker%E4%BB%93%E5%BA%93.html">访问Docker仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="05.%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html">搭建本地私有仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="06.Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86.html">Docker数据管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="07.Docker%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C.html">Docker使用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="08.%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.html">使用Dockerfile创建镜像</a></li>
<li class="toctree-l2"><a class="reference internal" href="08.%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.html#id7">指令        说明</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">实战案例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">1. 操作系统</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#busybox">1.1 BusyBox</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alpine">1.2 Alpine</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debian-ubantu">1.3 Debian/Ubantu</a></li>
<li class="toctree-l4"><a class="reference internal" href="#centos-fedora">1.4 CentOS/Fedora</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ssh">1.5 为镜像添加SSH服务</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#web">2. Web服务与应用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#apache">2.1 Apache</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nginx">2.2 Nginx</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tomcat">2.3 Tomcat</a></li>
<li class="toctree-l4"><a class="reference internal" href="#jetty">2.4 Jetty</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lamp">2.5 LAMP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id23">3. 持续开发与管理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#jenkins">3.1 Jenkins及官方镜像</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gitlab">3.2 GitLab及其官方镜像</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id24">3.3 相关资源</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id26">4. 数据库应用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mysql">4.1 MySQL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#oracle-database-xe">4.2 Oracle Database XE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mongodb">4.3 MongoDB</a></li>
<li class="toctree-l4"><a class="reference internal" href="#redis">4.4 Redis</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cassandra">4.5 Cassandra</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id54">5.分布式处理与大数据平台</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hadoop">5.1 Hadoop</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spark">5.2 Spark</a></li>
<li class="toctree-l4"><a class="reference internal" href="#storm">5.3 Storm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#elasticsearch">5.4 Elasticsearch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id70">6.编程开发</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#c-c">6.1 C/C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#java">6.2 Java</a></li>
<li class="toctree-l4"><a class="reference internal" href="#python">6.3 Python</a></li>
<li class="toctree-l4"><a class="reference internal" href="#javascript">6.4 JavaScript</a></li>
<li class="toctree-l4"><a class="reference internal" href="#go">6.5 Go</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id91">7.容器与云服务</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id92">7.1 公有云容器服务</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id96">7.2 容器云服务</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id102">7.3 阿里云容器服务</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id103">7.4 时速云介绍</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id106">8.容器实战思考</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#docker">Docker为什么会成功</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id107">研发人员该如何看待容器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id111">容器化开发模式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id115">容器与生产环境</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="10.Docker%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF.html">Docker核心实现技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="11.%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html">配置私有仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="12.%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E4%B8%8E%E9%85%8D%E7%BD%AE.html">安全防护与配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="13.%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD.html">高级网络功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="14.libnetwork%E6%8F%92%E4%BB%B6%E5%8C%96%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD.html">libnetwork插件化网络功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="15.Etcd%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93.html">Etcd高可用的键值数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="16.Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Compose.html">Docker三剑客之Docker-Compose</a></li>
<li class="toctree-l2"><a class="reference internal" href="17.Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Swarm.html">Docker三剑客之Docker-Swarm</a></li>
<li class="toctree-l2"><a class="reference internal" href="18.Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Machine.html">Docker三剑客之Docker-Machine</a></li>
<li class="toctree-l2"><a class="reference internal" href="19.%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAWeb%E5%BA%94%E7%94%A8%E6%A0%88.html">搭建一个Web应用栈</a></li>
<li class="toctree-l2"><a class="reference internal" href="20.Docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E5%AE%9E%E6%88%98.html">Docker高级网络实战</a></li>
<li class="toctree-l2"><a class="reference internal" href="21.%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.html">服务发现</a></li>
<li class="toctree-l2"><a class="reference internal" href="22.Mesos-%E4%BC%98%E7%A7%80%E7%9A%84%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0.html">Mesos—优秀的集群资源调度平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="23.Kubernetes-%E7%94%9F%E4%BA%A7%E7%BA%A7%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%B9%B3%E5%8F%B0.html">Kubernetes-生产级容器集群平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="24.%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE.html">其他相关项目</a></li>
<li class="toctree-l2"><a class="reference internal" href="25.%E9%99%84%E5%BD%95.html">附录</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../02.Kubernetes%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/index.html">02.Kubernetes实战指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03.Docker%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B/index.html">03.Docker经典实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04.Prometheus%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/index.html">04.Prometheus监控运维实战</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05.Kubernetes%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/index.html">05.Kubernetes入门到实践</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">小健_Docker_K8s_Blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">01.Docker技术入门与实战3版</a> &raquo;</li>
      <li>实战案例</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/01.Docker技术入门与实战3版/09.实战案例.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id116">实战案例</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id117">1. 操作系统</a></p>
<ul>
<li><p><a class="reference internal" href="#busybox" id="id118">1.1 BusyBox</a></p></li>
<li><p><a class="reference internal" href="#alpine" id="id119">1.2 Alpine</a></p></li>
<li><p><a class="reference internal" href="#debian-ubantu" id="id120">1.3 Debian/Ubantu</a></p></li>
<li><p><a class="reference internal" href="#centos-fedora" id="id121">1.4 CentOS/Fedora</a></p></li>
<li><p><a class="reference internal" href="#ssh" id="id122">1.5 为镜像添加SSH服务</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#web" id="id123">2. Web服务与应用</a></p>
<ul>
<li><p><a class="reference internal" href="#apache" id="id124">2.1 Apache</a></p></li>
<li><p><a class="reference internal" href="#nginx" id="id125">2.2 Nginx</a></p></li>
<li><p><a class="reference internal" href="#tomcat" id="id126">2.3 Tomcat</a></p></li>
<li><p><a class="reference internal" href="#jetty" id="id127">2.4 Jetty</a></p></li>
<li><p><a class="reference internal" href="#lamp" id="id128">2.5 LAMP</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id23" id="id129">3. 持续开发与管理</a></p>
<ul>
<li><p><a class="reference internal" href="#jenkins" id="id130">3.1 Jenkins及官方镜像</a></p></li>
<li><p><a class="reference internal" href="#gitlab" id="id131">3.2 GitLab及其官方镜像</a></p></li>
<li><p><a class="reference internal" href="#id24" id="id132">3.3 相关资源</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id26" id="id133">4. 数据库应用</a></p>
<ul>
<li><p><a class="reference internal" href="#mysql" id="id134">4.1 MySQL</a></p></li>
<li><p><a class="reference internal" href="#oracle-database-xe" id="id135">4.2 Oracle Database XE</a></p></li>
<li><p><a class="reference internal" href="#mongodb" id="id136">4.3 MongoDB</a></p></li>
<li><p><a class="reference internal" href="#redis" id="id137">4.4 Redis</a></p></li>
<li><p><a class="reference internal" href="#cassandra" id="id138">4.5 Cassandra</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id54" id="id139">5.分布式处理与大数据平台</a></p>
<ul>
<li><p><a class="reference internal" href="#hadoop" id="id140">5.1 Hadoop</a></p></li>
<li><p><a class="reference internal" href="#spark" id="id141">5.2 Spark</a></p></li>
<li><p><a class="reference internal" href="#storm" id="id142">5.3 Storm</a></p></li>
<li><p><a class="reference internal" href="#elasticsearch" id="id143">5.4 Elasticsearch</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id70" id="id144">6.编程开发</a></p>
<ul>
<li><p><a class="reference internal" href="#c-c" id="id145">6.1 C/C++</a></p></li>
<li><p><a class="reference internal" href="#java" id="id146">6.2 Java</a></p></li>
<li><p><a class="reference internal" href="#python" id="id147">6.3 Python</a></p></li>
<li><p><a class="reference internal" href="#javascript" id="id148">6.4 JavaScript</a></p></li>
<li><p><a class="reference internal" href="#go" id="id149">6.5 Go</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id91" id="id150">7.容器与云服务</a></p>
<ul>
<li><p><a class="reference internal" href="#id92" id="id151">7.1 公有云容器服务</a></p></li>
<li><p><a class="reference internal" href="#id96" id="id152">7.2 容器云服务</a></p></li>
<li><p><a class="reference internal" href="#id102" id="id153">7.3 阿里云容器服务</a></p></li>
<li><p><a class="reference internal" href="#id103" id="id154">7.4 时速云介绍</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id106" id="id155">8.容器实战思考</a></p>
<ul>
<li><p><a class="reference internal" href="#docker" id="id156">Docker为什么会成功</a></p></li>
<li><p><a class="reference internal" href="#id107" id="id157">研发人员该如何看待容器</a></p></li>
<li><p><a class="reference internal" href="#id111" id="id158">容器化开发模式</a></p></li>
<li><p><a class="reference internal" href="#id115" id="id159">容器与生产环境</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="id1">
<h1><a class="toc-backref" href="#id116">实战案例</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<section id="id2">
<h2><a class="toc-backref" href="#id117">1. 操作系统</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>目前常用的Linux发行版主要包括Debian/Ubuntu系列和CentOS/Fedora系列。前者以自带软件包版本较新而出名；后者则宣称运行更稳定一些。选择哪个操作系统取决于读者的具体需求。同时，社区还推出了精简版的Busybox和Alphine。</p>
<p>使用Docker，只需要一个命令就能快速获取一个Linux发行版镜像，这是以往各种虚拟化技术都难以实现的。这些镜像一般都很精简，但是可以支持完整Linux系统的大部分功能。</p>
<section id="busybox">
<h3><a class="toc-backref" href="#id118">1.1 BusyBox</a><a class="headerlink" href="#busybox" title="Permalink to this headline">¶</a></h3>
<p>BusyBox是一个集成了一百多个最常用Linux命令（如cat、echo、grep、mount、telnet等）的精简工具箱，它只有不到2
MB大小，被誉为“Linux系统的瑞士军刀”。BusyBox可运行于多款POSIX环境的操作系统中，如Linux（包括Android）、Hurd、FreeBSD等。</p>
<p><img alt="image0" src="../_images/docker_busyBox.png" /></p>
<p><strong>1.获取官方镜像</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[root@swarm1 centos]# docker search busybox
NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
busybox                   Busybox base image.                             1805                [OK]
progrium/busybox                                                          71                                      [OK]
radial/busyboxplus        Full-chain, Internet enabled, busybox made f…   26                                      [OK]
arm32v7/busybox           Busybox base image.                             8
yauritux/busybox-curl     Busybox with CURL                               6
armhf/busybox             Busybox base image.                             6
odise/busybox-curl                                                        4                                       [OK]
arm64v8/busybox           Busybox base image.                             3
prom/busybox              Prometheus Busybox Docker base images           2                                       [OK]
</pre></div>
</div>
<p>读者可以看到最受欢迎的镜像同时带有OFFICIAL标记，说明它是官方镜像。可使用docker
pull指令下载镜像busybox：latest：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker pull busybox:latest
</pre></div>
</div>
<p>下载后，可以看到busybox镜像只有1.22MB：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="o">@</span><span class="mi">192</span> <span class="o">~</span><span class="p">]</span><span class="c1"># docker images|grep busybox</span>
<span class="n">busybox</span>                 <span class="n">latest</span>              <span class="n">be5888e67be6</span>        <span class="mi">13</span> <span class="n">days</span> <span class="n">ago</span>         <span class="mf">1.22</span><span class="n">MB</span>
</pre></div>
</div>
<p><strong>2.运行busybox</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="o">@</span><span class="mi">192</span> <span class="o">~</span><span class="p">]</span><span class="c1"># docker run -it busybox</span>
<span class="o">/</span> <span class="c1"># grep</span>
</pre></div>
</div>
<p>查看容器内的挂载信息</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span> <span class="c1"># mount</span>
<span class="n">rootfs</span> <span class="n">on</span> <span class="o">/</span> <span class="nb">type</span> <span class="n">rootfs</span> <span class="p">(</span><span class="n">rw</span><span class="p">)</span>
<span class="n">overlay</span> <span class="n">on</span> <span class="o">/</span> <span class="nb">type</span> <span class="n">overlay</span> <span class="p">(</span><span class="n">rw</span><span class="p">,</span><span class="n">relatime</span><span class="p">,</span><span class="n">lowerdir</span><span class="o">=/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">overlay2</span><span class="o">/</span><span class="n">l</span><span class="o">/</span><span class="n">UI4OXIW6TOJHVYVGCPVHXPH6HU</span><span class="p">:</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">overlay2</span><span class="o">/</span><span class="n">l</span><span class="o">/</span><span class="n">NPBGQ34AKVDOUYEXCQIDYMYBNW</span><span class="p">,</span><span class="n">up</span>
<span class="n">perdir</span><span class="o">=/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">overlay2</span><span class="o">/</span><span class="n">a5bc45412d146530f69332687a54568484580cedd5b8ebc8b91310d5aec92e54</span><span class="o">/</span><span class="n">diff</span><span class="p">,</span><span class="n">workdir</span><span class="o">=/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">overlay2</span><span class="o">/</span><span class="n">a5bc45412d146530f69332687a54568484580cedd5b8ebc8b91310d5aec92e54</span><span class="o">/</span><span class="n">work</span><span class="p">)</span><span class="n">proc</span> <span class="n">on</span> <span class="o">/</span><span class="n">proc</span> <span class="nb">type</span> <span class="n">proc</span> <span class="p">(</span><span class="n">rw</span><span class="p">,</span><span class="n">nosuid</span><span class="p">,</span><span class="n">nodev</span><span class="p">,</span><span class="n">noexec</span><span class="p">,</span><span class="n">relatime</span><span class="p">)</span>
<span class="n">tmpfs</span> <span class="n">on</span> <span class="o">/</span><span class="n">dev</span> <span class="nb">type</span> <span class="n">tmpfs</span> <span class="p">(</span><span class="n">rw</span><span class="p">,</span><span class="n">nosuid</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="mi">65536</span><span class="n">k</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="mi">755</span><span class="p">)</span>
<span class="o">......</span>
</pre></div>
</div>
<p>bosybox镜像虽然小巧，但包括了大量常见的Linux命令。可以用它快速熟悉Linux命令。</p>
<p><strong>相关资源</strong></p>
<p>BusyBox 的相关资源如下：</p>
<ul class="simple">
<li><p>BusyBox官网：<a class="reference external" href="https://busybox.net/">https://busybox.net/</a></p></li>
<li><p>BusyBox官方仓库：<a class="reference external" href="https://git.busybox.net/busybox/">https://git.busybox.net/busybox/</a></p></li>
<li><p>BusyBox官方镜像：<a class="reference external" href="https://hub.docker.com/_/busybox/">https://hub.docker.com/_/busybox/</a></p></li>
<li><p>BusyBox官方镜像仓库：<a class="reference external" href="https://github.com/docker-library/busybox">https://github.com/docker-library/busybox</a></p></li>
</ul>
</section>
<section id="alpine">
<h3><a class="toc-backref" href="#id119">1.2 Alpine</a><a class="headerlink" href="#alpine" title="Permalink to this headline">¶</a></h3>
<p><strong>1.简介</strong></p>
<p>Alpine操作系统是一个面向安全的轻型Linux发行版，关注安全，性能和资源效能。不同于其他发行版，Alpine采用了musl
libc和BusyBox以减小系统的体积和运行时资源消耗，比BusyBox功能上更完善。在保持瘦身的同时，Alpine还提供了包管理工具apk查询和安装软件包。</p>
<p><img alt="image1" src="../_images/docker_alpine01.png" /></p>
<p>Alpine Docker镜像继承了Alpine
Linux发行版的这些优势。相比于其他镜像，它的容量非常小，仅仅只有5
MB左右（Ubuntu系列镜像接近200 MB）。官方镜像来自docker-alpine项目。</p>
<p>目前Docker官方推荐使用Alpine作为默认的基础镜像环境，这可以带来多个优势，如镜像下载速度加快、镜像安全性提高、主机之间的切换更方便、占用更少磁盘空间等。</p>
<p>下面是官方镜像的大小比较， 可以看出Alpine 镜像的显著优势：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">REPOSITORY</span>          <span class="n">TAG</span>           <span class="n">IMAGE</span> <span class="n">ID</span>          <span class="n">VIRTUAL</span> <span class="n">SIZE</span>
<span class="n">alpine</span>              <span class="n">latest</span>        <span class="mf">4e38</span><span class="n">e38c8ce0</span>      <span class="mf">4.799</span> <span class="n">MB</span>
<span class="n">debian</span>              <span class="n">latest</span>        <span class="mi">4</span><span class="n">d6ce913b130</span>      <span class="mf">84.98</span> <span class="n">MB</span>
<span class="n">ubuntu</span>              <span class="n">latest</span>        <span class="n">b39b81afc8ca</span>      <span class="mf">188.3</span> <span class="n">MB</span>
<span class="n">centos</span>              <span class="n">latest</span>        <span class="mi">8</span><span class="n">efe422e6104</span>      <span class="mi">210</span> <span class="n">MB</span>
</pre></div>
</div>
<p>2.<strong>获取并使用官方镜像</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run alpine echo &#39;123&#39;
123
</pre></div>
</div>
<p>本地在没有提前pull镜像的情况下，直接执行echo命令，仅需要3秒左右</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ time docker run alpine echo &#39;123&#39;
Unable to find image &#39;alpine:latest&#39; locallylatest: Pulling from library/alpine
e110a4a17941: Pull completeDigest: sha256:3dcdb92d7432d56604d4545cbd324b14e647b313626d99b889d0626de158f73aStatus: Downloaded newer image for alpine:latest123
real 0m3.367s user 0m0.040s sys 0m0.007s
</pre></div>
</div>
<p><strong>3.迁移至Alpine基础镜像</strong></p>
<p>目前，大部分Docker官方镜像都已经支持Alpine作为基础镜像，可以很容易进行迁移。</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- ubuntu/debian-&gt;alpine

- python：2.7-&gt;python：3.6-alpine

- ruby：2.6-&gt;ruby：2.6-alpine
</pre></div>
</div>
<p>如果使用Aline镜像，安装软件包时可以使用apk工具，则如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ apk add --no-cache &lt;package&gt;
</pre></div>
</div>
<p>Alpine中软件安装包的名字可能会与其他发行版有所不同，可以在<a class="reference external" href="https://pkgs.alpinelinux.org/packages">https://pkgs.alpinelinux.org/packages</a>
网站搜索并确定安装包名称。</p>
<p>如果需要的安装包不在主索引内，但是在测试或社区索引中。那么首先需要更新仓库列表，如下所示。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> <span class="s2">&quot;http://dl-4.alpinelinux.org/alpine/edge/testing&quot;</span> &gt;&gt; /etc/apk/repositories
$ apk --update add --no-cache &lt;package&gt;
</pre></div>
</div>
<p>例子如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it alpine
/ <span class="c1"># echo &quot;http://mirrors.ustc.edu.cn/alpine/v3.5/main&quot; &gt;&gt; /etc/apk/repositories</span>
/ <span class="c1"># apk --update add --no-cache git</span>
/ <span class="c1"># apk --update add --no-cache wget</span>
/ <span class="c1"># apk --update add --no-cache &lt;package&gt;</span>
</pre></div>
</div>
<p><strong>相关资源：</strong></p>
<p>Apline的相关资源如下：</p>
<ul class="simple">
<li><p>Apline官网：<a class="reference external" href="http://alpinelinux.org/">http://alpinelinux.org/</a></p></li>
<li><p>Apline官方仓库：<a class="reference external" href="https://github.com/alpinelinux">https://github.com/alpinelinux</a></p></li>
<li><p>Apline官方镜像：<a class="reference external" href="https://hub.docker.com/_/alpine/">https://hub.docker.com/_/alpine/</a></p></li>
<li><p>Apline官方镜像仓库：<a class="reference external" href="https://github.com/gliderlabs/docker-alpine">https://github.com/gliderlabs/docker-alpine</a></p></li>
</ul>
</section>
<section id="debian-ubantu">
<h3><a class="toc-backref" href="#id120">1.3 Debian/Ubantu</a><a class="headerlink" href="#debian-ubantu" title="Permalink to this headline">¶</a></h3>
<section id="debian">
<h4>Debian<a class="headerlink" href="#debian" title="Permalink to this headline">¶</a></h4>
<p>Debian和Ubuntu都是目前较为流行的Debian系的服务器操作系统，十分适合研发场景。</p>
<p>Docker Hub上提供了它们的官方镜像，国内各大容器云服务都提供了完整的支持。</p>
<p><img alt="image2" src="../_images/docker_debian.png" /></p>
<p><strong>1.Debian系统简介及官方镜像使用</strong></p>
<p>Debian是基于GPL授权的开源操作系统，是目前个人电脑与服务器中最受欢迎的开源操作系统之一，由Debian计划（Debian
Project）组织维护。Debian以其坚守Unix和自由软件的精神，及给予用户的众多选择而闻名。目前Debian包括超过25
000个软件包并支持12个计算机系统结构。</p>
<p>在Docker Hub中搜索debian相关的镜像</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker search debian
NAME DESCRIPTION                                        STARS OFFICIAL AUTOMATED
ubuntu Ubuntu is a Debian-based Linux operating sys…   7664                 [OK]
debian Debian is a Linux distribution that&#39;s compos…   2569                 [OK]
...
</pre></div>
</div>
<p>使用docker run命令直接运行Debian镜像。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run -it debian bash
root@668e178d8d69:/# cat /etc/issue
Debian GNU/Linux 8
</pre></div>
</div>
<p>可以将Debian镜像作为基础镜像来构建自定义镜像。如需要进行本地化配置，如UTF-8支持，可参考:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">&amp;&amp;</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">locales</span> <span class="o">&amp;&amp;</span> <span class="n">rm</span> <span class="o">-</span><span class="n">rf</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">lists</span><span class="o">/*</span> \
    <span class="o">&amp;&amp;</span> <span class="n">localedef</span> <span class="o">-</span><span class="n">i</span> <span class="n">en_US</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">f</span> <span class="n">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="o">-</span><span class="n">A</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">locale</span><span class="o">/</span><span class="n">locale</span><span class="o">.</span><span class="n">alias</span> <span class="n">en_US</span><span class="o">.</span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span>
<span class="n">ENV</span> <span class="n">LANG</span> <span class="n">en_US</span><span class="o">.</span><span class="n">utf8</span>
</pre></div>
</div>
</section>
<section id="ubantu">
<h4>Ubantu<a class="headerlink" href="#ubantu" title="Permalink to this headline">¶</a></h4>
<p>Ubuntu是以桌面应用为主的GNU/Linux开源操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词。官方译名“友帮拓”，另有“乌班图”等译名。Ubuntu每6个月会发布一个新版本，每两年推出一个长期支持（Long
Term Support，LTS）版本，一般支持3年时间。</p>
<p><img alt="image3" src="../_images/docker_ubuntu01.png" /></p>
<p>Ubuntu相关的镜像有很多，这里只搜索那些评星50以上的镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker search --filter<span class="o">=</span><span class="nv">stars</span><span class="o">=</span><span class="m">50</span> ubuntu
root@3b42e05dfae5:/# cat /etc/lsb-release
<span class="nv">DISTRIB_ID</span><span class="o">=</span>Ubuntu
<span class="nv">DISTRIB_RELEASE</span><span class="o">=</span><span class="m">18</span>.04
<span class="nv">DISTRIB_CODENAME</span><span class="o">=</span>bionic
<span class="nv">DISTRIB_DESCRIPTION</span><span class="o">=</span><span class="s2">&quot;Ubuntu 18.04.4 LTS&quot;</span>



<span class="c1"># 执行apt-get update命令更新仓库信息</span>
apt-get update

<span class="c1"># 安装curl工具</span>
apt-get install -y curl

<span class="c1"># 安装apache服务</span>
apt-get install -y apache2

<span class="c1"># 启动apache服务</span>
service apache2 start
</pre></div>
</div>
<p>配合使用-p参数对外映射服务器端口，可以允许容器来访问该服务。</p>
<p><strong>相关资源</strong></p>
<p>Debian 的相关资源如下：</p>
<ul class="simple">
<li><p>Debian官网：<a class="reference external" href="https://www.debian.org/">https://www.debian.org/</a></p></li>
<li><p>Debian官方镜像：<a class="reference external" href="https://hub.docker.com/_/debian/">https://hub.docker.com/_/debian/</a></p></li>
</ul>
<p>Ubuntu的相关资源如下：</p>
<ul class="simple">
<li><p>Ubuntu官网：<a class="reference external" href="http://www.ubuntu.org.cn/global">http://www.ubuntu.org.cn/global</a></p></li>
<li><p>Ubuntu官方镜像：<a class="reference external" href="https://hub.docker.com/_/ubuntu/">https://hub.docker.com/_/ubuntu/</a></p></li>
</ul>
</section>
</section>
<section id="centos-fedora">
<h3><a class="toc-backref" href="#id121">1.4 CentOS/Fedora</a><a class="headerlink" href="#centos-fedora" title="Permalink to this headline">¶</a></h3>
<p>CentOS和Fedora都是基于Redhat的Linux发行版。</p>
<p>CentOS是目前企业级服务器的常用操作系统；Fedora则主要面向个人桌面用户。</p>
<section id="centos">
<h4>1.CentOS系统简介及官方镜像使用<a class="headerlink" href="#centos" title="Permalink to this headline">¶</a></h4>
<p>CentOS（Community Enterprise Operating System，社区企业操作系统）基于Red
Hat Enterprise Linux源代码编译而成。由于CentOS与RedHat
Linux源于相同的代码基础，所以很多成本敏感且需要高稳定性的公司就使用CentOS来替代商业版Red
Hat Enterprise Linux。CentOS自身不包含闭源软件。</p>
<p><img alt="image4" src="../_images/docker_centos01.png" /></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用docker search命令来搜索标星至少50的相关镜像</span>
$ docker search --filter<span class="o">=</span><span class="nv">stars</span><span class="o">=</span><span class="m">50</span> centos

<span class="c1"># 使用docker run 直接运行centos，并登录bash</span>
$ docker run -it centos bash
</pre></div>
</div>
</section>
<section id="fedora">
<h4>2.Fedora系统简介及官方镜像使用<a class="headerlink" href="#fedora" title="Permalink to this headline">¶</a></h4>
<p>​ Fedora是由Fedora Project社区开发，Red
Hat公司赞助的Linux发行版。它的目标是创建一套新颖、多功能并且自由和开源的操作系统。</p>
<p><img alt="image5" src="../_images/docker_fedora.png" /></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用docker search命令来搜索标星至少50的相关镜像</span>
<span class="n">docker</span> <span class="n">search</span> <span class="o">--</span><span class="nb">filter</span><span class="o">=</span><span class="n">stars</span><span class="o">=</span><span class="mi">50</span> <span class="n">fedora</span>

<span class="c1"># 使用docker run 直接运行fedora，并登录bash</span>
<span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">it</span> <span class="n">fedora</span> <span class="n">bash</span>
</pre></div>
</div>
<p><strong>相关资源</strong></p>
<p>Fedora 的相关资源如下：</p>
<ul class="simple">
<li><p>Fedora官网：<a class="reference external" href="https://getfedora.org/">https://getfedora.org/</a></p></li>
<li><p>Fedora官方镜像：<a class="reference external" href="https://hub.docker.com/_/fedora/">https://hub.docker.com/_/fedora/</a></p></li>
</ul>
<p>CentOS 的相关资源如下：</p>
<ul class="simple">
<li><p>CentOS 官网： <a class="reference external" href="https://www.centos.org/">https://www.centos.org/</a></p></li>
<li><p>CentOS 官方镜像： <a class="reference external" href="https://hub.docker.com/_/centos/">https://hub.docker.com/_/centos/</a></p></li>
</ul>
</section>
</section>
<section id="ssh">
<h3><a class="toc-backref" href="#id122">1.5 为镜像添加SSH服务</a><a class="headerlink" href="#ssh" title="Permalink to this headline">¶</a></h3>
<p>介绍两种创建容器的方法：基于docker commit命令创建和基于Dockerfile创建。</p>
<section id="commit">
<h4>1. commit命令创建<a class="headerlink" href="#commit" title="Permalink to this headline">¶</a></h4>
<p><strong>1.准备工作</strong> 首先，获取ubuntu：18.04镜像，并创建一个容器：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker pull ubuntu:18.04
$ docker run -it ubuntu:18.04 /bin/bash
root@fc1936ea8ceb:/#
</pre></div>
</div>
<p><strong>2.配置软件源</strong> 检查软件源，并使用apt-get update命令来更新软件源信息：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># apt-get update</span>
<span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># apt-get install vim net-tools</span>
</pre></div>
</div>
<p>如果默认的官方源速度慢的话，也可以替换为国内163、sohu等镜像的源。以163源为例，在容器内创建/etc/apt/sources.list.d/163.list文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># vi /etc/apt/sources.list.d/163.list</span>
</pre></div>
</div>
<p>添加如下内容到文件中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
<span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span><span class="o">-</span><span class="n">security</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
<span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span><span class="o">-</span><span class="n">updates</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
<span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span><span class="o">-</span><span class="n">proposed</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
<span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span><span class="o">-</span><span class="n">backports</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
<span class="n">deb</span><span class="o">-</span><span class="n">src</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
<span class="n">deb</span><span class="o">-</span><span class="n">src</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span><span class="o">-</span><span class="n">security</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
<span class="n">deb</span><span class="o">-</span><span class="n">src</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span><span class="o">-</span><span class="n">updates</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
<span class="n">deb</span><span class="o">-</span><span class="n">src</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span><span class="o">-</span><span class="n">proposed</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
<span class="n">deb</span><span class="o">-</span><span class="n">src</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">mirrors</span><span class="mf">.163</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span> <span class="n">bionic</span><span class="o">-</span><span class="n">backports</span> <span class="n">main</span> <span class="n">restricted</span> <span class="n">universe</span> <span class="n">multiverse</span>
</pre></div>
</div>
<p>之后重新执行apt-get update命令即可。</p>
<p><strong>3.安装和配置SSH服务</strong></p>
<p>更新软件包缓存后可以安装SSH服务了，选择主流的openssh-server作为服务端。可以看到需要下载安装众多的依赖软件包：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># apt-get install openssh-server</span>
</pre></div>
</div>
<p>如果需要正常启动SSH服务，则目录/var/run/sshd必须存在。下面手动创建它，并启动SSH服务：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># mkdir -p /var/run/sshd</span>
<span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># /usr/sbin/sshd -D &amp;</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="mi">3254</span>
</pre></div>
</div>
<p>此时查看容器的22端口（SSH服务默认监听的端口），可见此端口已经处于监听状态：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># netstat -tunlp</span>
<span class="n">Active</span> <span class="n">Internet</span> <span class="n">connections</span> <span class="p">(</span><span class="n">only</span> <span class="n">servers</span><span class="p">)</span>
<span class="n">Proto</span> <span class="n">Recv</span><span class="o">-</span><span class="n">Q</span> <span class="n">Send</span><span class="o">-</span><span class="n">Q</span> <span class="n">Local</span> <span class="n">Address</span>      <span class="n">Foreign</span> <span class="n">Address</span>     <span class="n">State</span>    <span class="n">PID</span><span class="o">/</span><span class="n">Program</span> <span class="n">name</span>
<span class="n">tcp</span>        <span class="mi">0</span>      <span class="mi">0</span> <span class="mf">0.0.0.0</span><span class="p">:</span><span class="mi">22</span>         <span class="mf">0.0.0.0</span><span class="p">:</span><span class="o">*</span>           <span class="n">LISTEN</span>   <span class="o">-</span>
<span class="n">tcp6</span>       <span class="mi">0</span>      <span class="mi">0</span> <span class="p">:::</span><span class="mi">22</span>              <span class="p">:::</span><span class="o">*</span>                <span class="n">LISTEN</span>   <span class="o">-</span>
</pre></div>
</div>
<p>修改SSH服务的安全登录配置，取消pam登录限制：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># sed -ri &#39;s/session    required     pam_loginuid.so/#session    required     pam_loginuid.so/g&#39; /etc/pam.d/sshd</span>

<span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># cat /etc/pam.d/sshd | grep pam_loginuid.so</span>
<span class="c1">#session    required     pam_loginuid.so</span>
</pre></div>
</div>
<p>在root用户目录下创建.ssh目录，并复制需要登录的公钥信息（一般为本地主机用户目录下的.ssh/id_rsa.pub文件，可由ssh-keygen-t
rsa命令生成）到authorized_keys文件中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#配置登录秘钥
１:主机(client)生成公钥
ubuntu@ubuntu:~$ ssh-keygen -trsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/ubuntu/.ssh/id_rsa.
Your public key has been saved in /home/ubuntu/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:cCJNE3EeRpucmyTAN4tJ1diGO9TVuaNJ4LkPsJisMOE ubuntu@ubuntu
The key&#39;s randomart image is:
+---[RSA 3072]----+
|   ...X=... .   |
|    o+**=  o    |
|   ..==*Oo   .   |
|.   o.=*oo. o    |
|.. . o +So o .   |
|oE  + . o o      |
| o .     o       |
|  .       .      |
|                 |
+----[SHA256]-----+


一直敲回车就行了
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>２：在容器中(server)中创建/root/.ssh目录
root@fc1936ea8ceb:/# mkdir root/.ssh
root@fc1936ea8ceb:/# vi /root/.ssh/authorized_keys
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>３：将client的公钥复制到server的authorized_keys文件中
ubuntu@ubuntu:~$ cat  /home/ubuntu/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDxEH+/DRAITMdyTkVpIiLgvEWm5g03n+1qrN0pYAc78KM/T3Ktxn7e/kO8iqS+42NQIgEtgDq7DcUryxcgizBzeNuqJfjsfUjkiQplwnj7hjC3qfsAu8Re1pRmK
24eEtz4HxIwd9BepYakl8NLm99PCiTkOtnDFuxNh+u4BbI6tBxmfvrrqRFC8BC5pJRmr7FooOMruzhpXbOnvTLDFaOFJU5ecQX//nBI4uj8UbXoU/ytzkcGBxJ/JXza8fNxRD4sAmQZJ9tJIqeNUBHmn1+KD0y/h5
xh6xn8LcBASI4cGHo3azGviuWNreSxarOUvxZDWDyHxT3AI+KPvvlKP8gh root@192.168.1.106


root@92cf48876d4c:~# vi /root/.ssh/authorized_keys
root@92cf48876d4c:~# cat /root/.ssh/authorized_keys
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDxEH+/DRAITMdyTkVpIiLgvEWm5g03n+1qrN0pYAc78KM/T3Ktxn7e/kO8iqS+42NQIgEtgDq7DcUryxcgizBzeNuqJfjsfUjkiQplwnj7hjC3qfsAu8Re1pRmK
24eEtz4HxIwd9BepYakl8NLm99PCiTkOtnDFuxNh+u4BbI6tBxmfvrrqRFC8BC5pJRmr7FooOMruzhpXbOnvTLDFaOFJU5ecQX//nBI4uj8UbXoU/ytzkcGBxJ/JXza8fNxRD4sAmQZJ9tJIqeNUBHmn1+KD0y/h5
xh6xn8LcBASI4cGHo3azGviuWNreSxarOUvxZDWDyHxT3AI+KPvvlKP8gh root@192.168.1.106
</pre></div>
</div>
<p>创建自动启动SSH服务的可执行文件run.sh，并添加可执行权限：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># vi /run.sh</span>
<span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># chmod +x run.sh</span>
</pre></div>
</div>
<p>run.sh脚本内容如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sshd</span> <span class="o">-</span><span class="n">D</span>
</pre></div>
</div>
<p>最后，退出容器：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@fc1936ea8ceb</span><span class="p">:</span><span class="o">/</span><span class="c1"># exit</span>
<span class="n">exit</span>
</pre></div>
</div>
<p><strong>4.保存镜像</strong></p>
<p>将所退出的容器用docker commit命令保存为一个新的sshd：ubuntu镜像。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@192 ~<span class="o">]</span><span class="c1"># docker ps -a</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
4d8ac554cdb9        ubuntu:18.04        <span class="s2">&quot;/bin/bash&quot;</span>         <span class="m">8</span> minutes ago       Exited <span class="o">(</span><span class="m">0</span><span class="o">)</span> <span class="m">18</span> seconds ago                       musing_colden
<span class="o">[</span>root@192 ~<span class="o">]</span><span class="c1"># docker commit 4d8ac sshd:ubuntu</span>
sha256:53edb4a83015c2f88e67c2f87199a1f72b13a563fe7902f8e0ec17e1e5964b5e

<span class="c1">#使用sshd:ubuntu镜像,添加端口映射10022--&gt;22</span>
<span class="o">[</span>root@192 ~<span class="o">]</span><span class="c1"># docker run -p 10022:22 -d sshd:ubuntu /run.sh</span>
d562ef6176c31d01524a47f74182a719c0f0a91e2c8c82fda063414daa7893d8
</pre></div>
</div>
<p>启动成功后，可以在宿主主机上看到容器运行的详细信息。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@192 ~<span class="o">]</span><span class="c1"># docker ps -al</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                   NAMES
d562ef6176c3        sshd:ubuntu         <span class="s2">&quot;/run.sh&quot;</span>           <span class="m">20</span> seconds ago      Up <span class="m">19</span> seconds       <span class="m">0</span>.0.0.0:10022-&gt;22/tcp   elegant_dubinsky
</pre></div>
</div>
<p>在宿主主机（192.168.1.200）或其他主机上上，可以通过SSH访问10022端口来登录容器：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ssh 192.168.1.200 -p 10022
The authenticity of host &#39;[192.168.1.200]:10022 ([192.168.1.200]:10022)&#39; can&#39;t be established.
ECDSA key fingerprint is 5f:6e:4c:54:8f:c7:7f:32:c2:38:45:bb:16:03:c9:e8.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;[192.168.1.200]:10022&#39; (ECDSA) to the list of known hosts.
root@3ad7182aa47f:~#
</pre></div>
</div>
</section>
<section id="dockerfile">
<h4>2. 使用Dockerfile创建<a class="headerlink" href="#dockerfile" title="Permalink to this headline">¶</a></h4>
<p><strong>1.创建工作目录</strong> 首先，创建一个sshd_ubuntu工作目录：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mkdir sshd_ubuntu
$ ls
sshd_ubuntu
</pre></div>
</div>
<p>在其中，创建Dockerfile和run.sh文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd sshd_ubuntu/
$ touch Dockerfile run.sh
$ ls
Dockerfile run.sh
</pre></div>
</div>
<p><strong>2.编写run.sh脚本和authorized_keys文件</strong>
脚本文件run.sh的内容与上一小节中一致：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sshd</span> <span class="o">-</span><span class="n">D</span>
</pre></div>
</div>
<p>在宿主主机上生成SSH密钥对，并创建authorized_keys文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ssh-keygen -t rsa
...
$ cat ~/.ssh/id_rsa.pub &gt;authorized_keys
</pre></div>
</div>
<p><strong>3.编写Dockerfile</strong>
下面是Dockerfile的内容及各部分的注释，可以对比上一节中利用docker
commit命令创建镜像过程，所进行的操作基本一致：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#设置继承镜像</span>
<span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">18.04</span>
<span class="c1">#提供一些作者的信息</span>
<span class="n">MAINTAINER</span> <span class="n">docker_user</span> <span class="p">(</span><span class="n">user</span><span class="nd">@docker</span><span class="o">.</span><span class="n">com</span><span class="p">)</span>
<span class="c1">#下面开始运行命令,此处更改ubuntu的源为国内163的源</span>
<span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse&quot;</span> <span class="o">&gt;</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">sources</span><span class="o">.</span><span class="n">list</span>
<span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse&quot;</span> <span class="o">&gt;&gt;</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">sources</span><span class="o">.</span><span class="n">list</span>
<span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse&quot;</span> <span class="o">&gt;&gt;</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">sources</span><span class="o">.</span><span class="n">list</span>
<span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse&quot;</span> <span class="o">&gt;&gt;</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">sources</span><span class="o">.</span><span class="n">list</span>
<span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse&quot;</span> <span class="o">&gt;&gt;</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">sources</span><span class="o">.</span><span class="n">list</span>
<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span>
<span class="c1">#安装 ssh 服务</span>
<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">openssh</span><span class="o">-</span><span class="n">server</span>
<span class="n">RUN</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">sshd</span>
<span class="n">RUN</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="n">root</span><span class="o">/.</span><span class="n">ssh</span>
<span class="c1">#取消pam限制</span>
<span class="n">RUN</span> <span class="n">sed</span> <span class="o">-</span><span class="n">ri</span> <span class="s1">&#39;s/session    required     pam_loginuid.so/#session    required     pam_loginuid.so/g&#39;</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">pam</span><span class="o">.</span><span class="n">d</span><span class="o">/</span><span class="n">sshd</span>
<span class="c1">#复制配置文件到相应位置,并赋予脚本可执行权限</span>
<span class="n">ADD</span> <span class="n">authorized_keys</span> <span class="o">/</span><span class="n">root</span><span class="o">/.</span><span class="n">ssh</span><span class="o">/</span><span class="n">authorized_keys</span>
<span class="n">ADD</span> <span class="n">run</span><span class="o">.</span><span class="n">sh</span> <span class="o">/</span><span class="n">run</span><span class="o">.</span><span class="n">sh</span>
<span class="n">RUN</span> <span class="n">chmod</span> <span class="mi">755</span> <span class="o">/</span><span class="n">run</span><span class="o">.</span><span class="n">sh</span>
<span class="c1">#开放端口</span>
<span class="n">EXPOSE</span> <span class="mi">22</span>
<span class="c1">#设置自启动命令</span>
<span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;/run.sh&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>4.创建镜像</strong></p>
<p>在sshd_ubuntu目录下，使用docker
build命令来创建镜像。这里用户需要注意在最后还有一个“.”，表示使用当前目录中的Dockerfile：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd sshd_ubuntu
$ docker build -t sshd:dockerfile .
</pre></div>
</div>
<p>如果读者使用Dockerfile创建自定义镜像，那么需要注意的是Docker会自动删除中间临时创建的层，还需要注意每一步的操作和编写的Dockerfile中命令的对应关系。</p>
<p>命令执行完毕后，如果读者看见“Successfully built
XXX”字样，则说明镜像创建成功。可以看到，以上命令生成的镜像ID是570c26a9de68。</p>
<p>在本地查看sshd：dockerfile镜像已存在：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY      TAG              IMAGE ID            CREATED             VIRTUAL SIZE
sshd            dockerfile       570c26a9de68        4 minutes ago       246.5 MB
sshd            ubuntu           7aef2cd95fd0        12 hours ago        255.2 MB
busybox         latest           e72ac664f4f0        3 weeks ago         2.433 MB
ubuntu          16.04            ba5877dc9bec        3 months ago        192.7 MB
ubuntu          latest           ba5877dc9bec        3 months ago        192.7 MB
</pre></div>
</div>
<p><strong>5.测试镜像，运行容器</strong></p>
<p>下面使用刚才创建的sshd：dockerfile镜像来运行一个容器。</p>
<p>直接启动镜像，映射容器的22端口到本地的10122端口：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p 10122:22 sshd:dockerfile
890c04ff8d769b604386ba4475253ae8c21fc92d60083759afa77573bf4e8af1
$ docker ps
CONTAINER ID  IMAGE    COMMAND     CREATED      STATUS       PORTS           NAMES
890c04ff8d76  sshd:dockerfile     &quot;/run.sh&quot;   4 seconds ago       Up 3 seconds        0.0.0.0:10122-&gt;22/tcp   high_albattani
</pre></div>
</div>
<p>在宿主主机新打开一个终端，连接到新建的容器：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ssh 192.168.1.200 -p 10122
The authenticity of host &#39;[192.168.1.200]:10122 ([192.168.1.200]:10122)&#39; can&#39;t be established.
ECDSA key fingerprint is d1:59:f1:09:3b:09:79:6d:19:16:f4:fd:39:1b:be:27.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;[192.168.1.200]:10122&#39; (ECDSA) to the list of known hosts.
root@890c04ff8d76:~#
</pre></div>
</div>
<p>镜像创建成功。</p>
</section>
</section>
</section>
<section id="web">
<h2><a class="toc-backref" href="#id123">2. Web服务与应用</a><a class="headerlink" href="#web" title="Permalink to this headline">¶</a></h2>
<p>下面将重点介绍如何使用Docker来运行常见的Web服务器（包括Apache、Nginx、Tomcat等），以及一些常用应用（包括LAMP和CI/CD）</p>
<section id="apache">
<h3><a class="toc-backref" href="#id124">2.1 Apache</a><a class="headerlink" href="#apache" title="Permalink to this headline">¶</a></h3>
<p>Apache是一个高稳定性的、商业级别的开源Web服务器，是目前世界使用排名第一的Web服务器软件。由于其良好的跨平台和安全性，Apache被广泛应用在多种平台和操作系统上。Apache作为软件基金会支持的项目，其开发者社区完善而高效，自1995年发布至今，一直以高标准进行维护与开发。Apache音译为阿帕奇，源自美国西南部一个印第安人部落的名称（阿帕奇族）。</p>
<p><img alt="image6" src="../_images/docker_apache001.png" /></p>
<section id="dockerhub">
<h4>1.使用DockerHub镜像<a class="headerlink" href="#dockerhub" title="Permalink to this headline">¶</a></h4>
<p>DockerHub官方提供的Apache镜像，并不带PHP环境。如果读者需要PHP环境支持，可以选择PHP镜像（<a class="reference external" href="https://registry.hub.docker.com/_/php/">https://registry.hub.docker.com/_/php/</a>
），并请使用含-apache标签的镜像，如7.0.7-apache。如果仅需要使用Apache运行静态HTML文件，则使用默认官方镜像即可。</p>
<p>编写Dockerfile文件，内容如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">httpd</span><span class="p">:</span><span class="mf">2.4</span>
<span class="n">COPY</span> <span class="o">./</span><span class="n">public</span><span class="o">-</span><span class="n">html</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">apache2</span><span class="o">/</span><span class="n">htdocs</span><span class="o">/</span>
</pre></div>
</div>
<p>同目录下：<code class="docutils literal notranslate"><span class="pre">public-html/index.html</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;!DOCTYPE html&gt;
    &lt;html&gt;
        &lt;body&gt;
            &lt;p&gt;Hello, Docker!&lt;/p&gt;
        &lt;/body&gt;
&lt;/html&gt;
</pre></div>
</div>
<p>构建自定义镜像</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t apache2-image .
......
Successfully built 881d3fd0d574
</pre></div>
</div>
<p>启动镜像(<code class="docutils literal notranslate"><span class="pre">-d</span> <span class="pre">在后台启动</span></code>)</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@192 apache<span class="o">]</span><span class="c1"># docker run -p 80:80 -d apache2-image</span>
059b9d66b860583634d8001c640b34e0d1b2bc20c9c349e8ee2c424da1ec8c83
</pre></div>
</div>
<p>通过本地的80即可访问静态页面</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[root@192 apache]# curl 127.0.0.1
&lt;!DOCTYPE html&gt;
    &lt;html&gt;
        &lt;body&gt;
            &lt;p&gt;Hello, Docker!&lt;/p&gt;
        &lt;/body&gt;
&lt;/html&gt;
</pre></div>
</div>
<p><img alt="image7" src="../_images/docker_apache02.png" /></p>
<p>也可以不创建自定义镜像，直接通过映射目录方式运行Apache容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@192 apache<span class="o">]</span><span class="c1"># docker run -it --rm --name my-apache-app -p 80:80 -v &quot;$PWD&quot;:/usr/local/apache2/htdocs/ httpd:2.4</span>
AH00558: httpd: Could not reliably determine the server<span class="s1">&#39;s fully qualified domain name, using 172.17.0.2. Set the &#39;</span>ServerName<span class="s1">&#39; directive globally to suppress this</span>
<span class="s1"> messageAH00558: httpd: Could not reliably determine the server&#39;</span>s fully qualified domain name, using <span class="m">172</span>.17.0.2. Set the <span class="s1">&#39;ServerName&#39;</span> directive globally to suppress this
 message<span class="o">[</span>Tue Apr <span class="m">28</span> <span class="m">13</span>:37:52.753783 <span class="m">2020</span><span class="o">]</span> <span class="o">[</span>mpm_event:notice<span class="o">]</span> <span class="o">[</span>pid <span class="m">1</span>:tid <span class="m">140658846499968</span><span class="o">]</span> AH00489: Apache/2.4.43 <span class="o">(</span>Unix<span class="o">)</span> configured -- resuming normal operations
<span class="o">[</span>Tue Apr <span class="m">28</span> <span class="m">13</span>:37:52.754159 <span class="m">2020</span><span class="o">]</span> <span class="o">[</span>core:notice<span class="o">]</span> <span class="o">[</span>pid <span class="m">1</span>:tid <span class="m">140658846499968</span><span class="o">]</span> AH00094: Command line: <span class="s1">&#39;httpd -D FOREGROUND&#39;</span>
</pre></div>
</div>
<p>再次打开浏览器，可以再次看到页面输出。</p>
</section>
<section id="id3">
<h4>2.使用自定义镜像<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>首先，创建一个apache_ubuntu工作目录，在其中创建Dockerfile文件、run.sh文件和sample目录：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mkdir apache_ubuntu &amp;&amp; cd apache_ubuntu
$ touch Dockerfile run.sh
$ mkdir sample
</pre></div>
</div>
<p>下面是Dockerfile的内容和各个部分的说明：</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">sshd:dockerfile</span>
<span class="c">#设置继承自用户创建的 sshd 镜像</span>
<span class="k">MAINTAINER</span><span class="s"> docker_user (user@docker.com)</span>
<span class="c">#创建者的基本信息</span>
<span class="c">#设置环境变量，所有操作都是非交互式的</span>
<span class="k">ENV</span> DEBIAN_FRONTEND noninteractive
<span class="c">#安装</span>
<span class="k">RUN</span> apt-get -yq install apache2<span class="o">&amp;&amp;</span><span class="se">\</span>
    rm -rf /var/lib/apt/lists/*
<span class="k">RUN</span> <span class="nb">echo</span> <span class="s2">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone <span class="o">&amp;&amp;</span> <span class="se">\</span>
        dpkg-reconfigure -f noninteractive tzdata
<span class="c">#注意这里要更改系统的时区设置，因为在Web应用中经常会用到时区这个系统变量，默认Ubuntu的设置会</span>
　让你的应用程序发生不可思议的效果哦
<span class="c"># 添加用户的脚本，并设置权限，这会覆盖之前放在这个位置的脚本</span>
<span class="k">ADD</span> run.sh /run.sh
<span class="k">RUN</span> chmod <span class="m">755</span> /*.sh
<span class="c"># 添加一个示例的Web站点，删掉默认安装在apache文件夹下面的文件，并将用户添加的示例用软链接链</span>
　 到/var/www/html目录下面
<span class="k">RUN</span> mkdir -p /var/lock/apache2 <span class="o">&amp;&amp;</span>mkdir -p /app <span class="o">&amp;&amp;</span> rm -fr /var/www/html <span class="o">&amp;&amp;</span> ln -s /app /var/www/html
<span class="k">COPY</span> sample/ /app
<span class="c"># 设置apache相关的一些变量，在容器启动的时候可以使用-e参数替代</span>
<span class="k">ENV</span> APACHE_RUN_USER www-data
<span class="k">ENV</span> APACHE_RUN_GROUP www-data
<span class="k">ENV</span> APACHE_LOG_DIR /var/log/apache2
<span class="k">ENV</span> APACHE_PID_FILE /var/run/apache2.pid
<span class="k">ENV</span> APACHE_RUN_DIR /var/run/apache2
<span class="k">ENV</span> APACHE_LOCK_DIR /var/lock/apache2
<span class="k">ENV</span> APACHE_SERVERADMIN admin@localhost
<span class="k">ENV</span> APACHE_SERVERNAME localhost
<span class="k">ENV</span> APACHE_SERVERALIAS docker.localhost
<span class="k">ENV</span> APACHE_DOCUMENTROOT /var/www
<span class="k">EXPOSE</span><span class="s"> 80</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="k">CMD</span> <span class="p">[</span><span class="s2">&quot;/run.sh&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>此sample站点的内容为输出Hello
Docker！。下面用户在sample目录下创建index.html文件，内容为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;!DOCTYPE html&gt;
    &lt;html&gt;
        &lt;body&gt;
            &lt;p&gt;Hello, Docker!&lt;/p&gt;
        &lt;/body&gt;
&lt;/html&gt;
</pre></div>
</div>
<p>run.sh脚本内容也很简单，只是启动apache服务：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cat run.sh
<span class="c1">#!/bin/bash</span>
<span class="nb">exec</span> apache2 -D FOREGROUND
</pre></div>
</div>
<p>此时，apache_ubuntu目录下面的文件结构为：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@192 apache_ubuntu<span class="o">]</span><span class="c1"># tree .</span>
.
├── Dockerfile
├── run.sh
└── sample
    └── index.html

<span class="m">1</span> directory, <span class="m">3</span> files
</pre></div>
</div>
<p>下面，开始创建apache：ubuntu镜像。</p>
<p>使用docker build命令创建apache：ubuntu镜像，注意命令最后的“.”：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t apache:ubuntu .
......
Successfully built 1d865e3032d
</pre></div>
</div>
<p>此时镜像已经创建成功了。用户可使用docker
images指令查看本地新增的apache：ubuntu镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY TAG IMAGE ID CREATED             VIRTUAL SIZE
apache ubuntu 1d865e3032d7 <span class="m">46</span> seconds ago      <span class="m">263</span>.8 MB
</pre></div>
</div>
<p>接下来，使用docker
run指令测试镜像。用户可以使用-P参数映射需要开放的端口（22和80端口）：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -P apache:ubuntu
64681e2ae943f18eae9f599dbc43b5f44d9090bdca3d8af641d7b371c124acfd
$ docker ps -a
CONTAINER ID   IMAGE             COMMAND        CREATED    STATUS   PORTS   NAMES
64681e2ae943 apache:ubuntu   <span class="s2">&quot;/run.sh&quot;</span>   <span class="m">2</span> seconds ago   Up <span class="m">1</span> seconds   <span class="m">0</span>.0.0.0:49171-&gt;22/tcp, <span class="m">0</span>.0.0.0:49172-&gt;80/tcp   naughty_poincare
890c04ff8d76   sshd:dockerfile   <span class="s2">&quot;/run.sh&quot;</span>   <span class="m">9</span> hours ago   Exited <span class="o">(</span><span class="m">0</span><span class="o">)</span> <span class="m">3</span> hours ago   <span class="m">0</span>.0.0.0:101-&gt;22/tcp   high_albattani
3ad7182aa47f   sshd:ubuntu   <span class="s2">&quot;/run.sh&quot;</span>   <span class="m">21</span> hours ago   Exited <span class="o">(</span><span class="m">0</span><span class="o">)</span> <span class="m">3</span> hours ago   <span class="m">0</span>.0.0.0:100-&gt;22/tcp   focused_ptolemy
</pre></div>
</div>
<p>在本地主机上用curl抓取网页来验证刚才创建的sample站点：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ curl <span class="m">127</span>.0.0.1:49172
Hello Docker!
</pre></div>
</div>
<p>读者也可以在其他设备上通过访问宿主主机ip：49172来访问sample站点。</p>
<p>下面，用户看看Dockerfile创建的镜像拥有继承的特性。不知道有没有细心的读者发现，在apache镜像的Dockerfile中只用EXPOSE定义了对外开放的80端口，而在docker
ps-a命令的返回中，却看到新启动的容器映射了2个端口：22和80。</p>
<p>但是实际上，当尝试使用SSH登录到容器时，会发现无法登录。这是因为在run.sh脚本中并未启动SSH服务。这说明在使用Dockerfile创建镜像时，会继承父镜像的开放端口，但却不会继承启动命令。因此，需要在run.sh脚本中添加启动sshd的服务的命令：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cat run.sh
<span class="c1">#!/bin/bash</span>
/usr/sbin/sshd <span class="p">&amp;</span>
<span class="nb">exec</span> apache2 -D FOREGROUND
</pre></div>
</div>
<p>再次创建镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t apache:ubuntu .
</pre></div>
</div>
<p>这次创建的镜像，将默认会同时启动SSH和Apache服务。</p>
<p>下面，用户看看如何映射本地目录。用户可以通过映射本地目录的方式，来指定容器内Apache服务响应的内容，例如映射本地主机上当前目录下的www目录到容器内的/var/www目录：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -i -d -p <span class="m">80</span>:80 -p <span class="m">103</span>:22 -e <span class="nv">APACHE_SERVERNAME</span><span class="o">=</span><span class="nb">test</span>  -v <span class="s1">&#39;pwd&#39;</span>/www:/var/www:ro apache:ubuntu
</pre></div>
</div>
<p>在当前目录内创建www目录，并放上自定义的页面index.html，内容为：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&lt;!DOCTYPE HTML PUBLIC <span class="s2">&quot;-//IETF//DTD HTML 2.0//EN&quot;</span>&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;Hi Docker&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Hi Docker&lt;/h1&gt;
&lt;p&gt;This is the first day I meet the new world.&lt;/p&gt;
&lt;p&gt;How are you?&lt;/p&gt;
&lt;hr&gt;
&lt;address&gt;Apache/2.4.7 <span class="o">(</span>Ubuntu<span class="o">)</span> Server at <span class="m">127</span>.0.0.1 Port <span class="m">80</span>&lt;/address&gt;
&lt;/body&gt;&lt;/html&gt;
</pre></div>
</div>
<p>在本地主机上可访问测试容器提供的Web服务，查看获取内容为新配置的index.html页面信息。</p>
</section>
<section id="id4">
<h4>3.相关资源<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Apache的相关资源如下：</p>
<ul class="simple">
<li><p>Apache官网：<a class="reference external" href="https://httpd.apache.org/">https://httpd.apache.org/</a></p></li>
<li><p>Apache官方仓库：<a class="reference external" href="https://github.com/apache/httpd">https://github.com/apache/httpd</a></p></li>
</ul>
</section>
</section>
<section id="nginx">
<h3><a class="toc-backref" href="#id125">2.2 Nginx</a><a class="headerlink" href="#nginx" title="Permalink to this headline">¶</a></h3>
<p>Nginx（发音为“engine-x”）是一款功能强大的开源反向代理服务器，支持HTTP、HTTPS、SMTP、POP3、IMAP等协议。它也可以作为负载均衡器、HTTP缓存或Web服务器。Nginx一开始就专注于高并发和高性能的应用场景。它使用类BSD开源协议，支持Linux、BSD、Mac、Solaris、AIX等类Unix系统，同时也有Windows上的移植版本。</p>
<p><img alt="image8" src="../_images/docker_nginx0001.png" /></p>
<p>Nginx特性如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·热部署：采用master管理进程与worker工作进程的分离设计，支持热部署。在不间断服务的前提下，可以直接升级版本。也可以在不停止服务的情况下修改配置文件，更换日志文件等。

·高并发连接：Nginx可以轻松支持超过100K的并发，理论上支持的并发连接上限取决于机器内存。

·低内存消耗：在一般的情况下，10K个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗2.5 MB的内存，这也是Nginx支持高并发连接的基础。

·响应快：在正常的情况下，单次请求会得到更快的响应。在高峰期，Nginx可以比其他的Web服务器更快地响应请求。

·高可靠性：Nginx是一个高可靠性的Web服务器，这也是用户为什么选择Nginx的基本条件，现在很多的网站都在使用Nginx，足以说明Nginx的可靠性。高可靠性来自其核心框架代码的优秀设计和实现。
</pre></div>
</div>
<p>本节将首先介绍Nginx官方发行版本的镜像生成，然后介绍第三方发行版Tengine镜像的生成。</p>
<section id="dockerhub-1">
<span id="id5"></span><h4>1.使用DockerHub镜像<a class="headerlink" href="#dockerhub-1" title="Permalink to this headline">¶</a></h4>
<p>用户可以使用docker run指令直接运行官方Nginx镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p <span class="m">80</span>:80 --name webserver nginx
...
34bcd01998a76f67b1b9e6abe5b7db5e685af325d6fafb1acd0ce84e81e71e5d
</pre></div>
</div>
<p>然后使用docker ps指令查看当前运行的容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@192 Docker<span class="o">]</span><span class="c1"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                NAMES
a3454b58a5dc        nginx               <span class="s2">&quot;nginx -g &#39;daemon of…&quot;</span>   About a minute ago   Up About a minute   <span class="m">0</span>.0.0.0:80-&gt;80/tcp   webserver
</pre></div>
</div>
<p>目前Nginx容器已经在0.0.0.0：80启动，并映射了80端口，此时可以打开浏览器访问此地址，就可以看到Nginx输出的页面。</p>
<p><img alt="image9" src="../_images/docker_nginx002.png" /></p>
<p>1.9.8版本后的镜像支持debug模式，镜像包含nginx-debug，可以支持更丰富的log信息：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name my-nginx -v /host/path/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx nginx-debug -g <span class="s1">&#39;daemon off;&#39;</span>
</pre></div>
</div>
<p>相应的docker-compose.yml配置如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">web</span><span class="p">:</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">nginx</span>
    <span class="n">volumes</span><span class="p">:</span>
        <span class="o">-</span> <span class="o">./</span><span class="n">nginx</span><span class="o">.</span><span class="n">conf</span><span class="p">:</span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">nginx</span><span class="o">/</span><span class="n">nginx</span><span class="o">.</span><span class="n">conf</span><span class="p">:</span><span class="n">ro</span>
    <span class="n">command</span><span class="p">:</span> <span class="p">[</span><span class="n">nginx</span><span class="o">-</span><span class="n">debug</span><span class="p">,</span> <span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="s1">&#39;daemon off;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="id6">
<h4>2.自定义Web页面<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>首先，新建index.html文件，内容如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">text</span><span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">div</span> <span class="o">&gt;</span>
            <span class="n">hello</span> <span class="n">world</span>
        <span class="o">&lt;/</span><span class="n">div</span> <span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">body</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">html</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>然后使用docker[container]run指令运行，并将index.html文件挂载至容器中，即可看到显示自定义的页面。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name nginx-container -p <span class="m">80</span>:80 -v index.html:/usr/share/nginx/html:ro -d nginx
</pre></div>
</div>
<p>另外，也可以使用Dockerfile来构建新镜像。Dockerfile内容如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">nginx</span>
<span class="n">COPY</span> <span class="o">./</span><span class="n">index</span><span class="o">.</span><span class="n">html</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">nginx</span><span class="o">/</span><span class="n">html</span>
</pre></div>
</div>
<p>开始构建镜像my-nginx：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t my-nginx .
</pre></div>
</div>
<p>构建成功后执行docker[container]run指令，如下所示：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -p <span class="m">80</span>:80 --name nginx-container -d my-nginx
</pre></div>
</div>
<p>（1）使用自定义Dockerfile</p>
<p>代码如下：</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="c">#设置继承自创建的sshd镜像</span>
<span class="k">FROM</span> <span class="s">sshd:dockerfile</span>
<span class="c">#下面是一些创建者的基本信息</span>
<span class="k">MAINTAINER</span><span class="s"> docker_user (user@docker.com)</span>
<span class="c">#安装nginx，设置nginx以非daemon方式启动。</span>
<span class="k">RUN</span> <span class="se">\</span>
    apt-get install -y nginx <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -rf /var/lib/apt/lists/* <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="nb">echo</span> <span class="s2">&quot;\ndaemon off;&quot;</span> &gt;&gt; /etc/nginx/nginx.conf <span class="o">&amp;&amp;</span> <span class="se">\</span>
    chown -R www-data:www-data /var/lib/nginx
<span class="k">RUN</span> <span class="nb">echo</span> <span class="s2">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone <span class="o">&amp;&amp;</span> <span class="se">\</span>
    dpkg-reconfigure -f noninteractive tzdata
<span class="c"># 注意这里要更改系统的时区设置，因为在Web应用中经常会用到时区这个系统变量，默认ubuntu的设置</span>
  会让你的应用程序发生不可思议的效果哦
<span class="c"># 添加用户的脚本，并设置权限，这会覆盖之前放在这个位置的脚本</span>
<span class="k">ADD</span> run.sh /run.sh
<span class="k">RUN</span> chmod <span class="m">755</span> /*.sh
<span class="c"># 定义可以被挂载的目录，分别是虚拟主机的挂载目录、证书目录、配置目录、和日志目录</span>
<span class="k">VOLUME</span> <span class="p">[</span><span class="s2">&quot;/etc/nginx/sites-enabled&quot;</span><span class="p">,</span> <span class="s2">&quot;/etc/nginx/certs&quot;</span><span class="p">,</span> <span class="s2">&quot;/etc/nginx/conf.d&quot;</span><span class="p">,</span> <span class="s2">&quot;/var/log/nginx&quot;</span><span class="p">]</span>
<span class="c"># 定义工作目录</span>
<span class="k">WORKDIR</span><span class="s"> /etc/nginx</span>
<span class="c"># 定义输出命令</span>
<span class="k">CMD</span> <span class="p">[</span><span class="s2">&quot;/run.sh&quot;</span><span class="p">]</span>
<span class="c"># 定义输出端口</span>
<span class="k">EXPOSE</span><span class="s"> 80</span>
<span class="k">EXPOSE</span><span class="s"> 443</span>
</pre></div>
</div>
<p>（2）查看run.sh脚本文件内容</p>
<p>代码如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cat run.sh
<span class="c1">#!/bin/bash</span>
/usr/sbin/sshd <span class="p">&amp;</span>
/usr/sbin/nginx
</pre></div>
</div>
<p>（3）创建镜像</p>
<p>使用docker build命令，创建镜像nginx：stable：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker build -t nginx:stable .
...
Successfully built 4e3936e36e3
</pre></div>
</div>
<p>（4）测试</p>
<p>启动容器，查看内部的80端口被映射到本地的49193端口：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run -d -P nginx:stable
08c456536e69c8e36670f3bc6b496020e76d28fc9d33a8bcd01ff6d61bc72c4a
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
08c456536e69 nginx:stable &quot;/run.sh&quot; 8 seconds ago Up 8 seconds 0.0.0.0:49191-&gt;22/tcp, 0.0.0.0:49192-&gt;443/tcp, 0.0.0.0:49193-&gt;80/tcp
</pre></div>
</div>
<p>访问本地的49193端口：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ curl 127.0.0.1:49193
</pre></div>
</div>
<p>再次看到Nginx的欢迎页面，说明Nginx已经正常启动了。</p>
</section>
<section id="id7">
<h4>3.参数优化<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>为了能充分发挥Nginx的性能，用户可对系统内核参数做一些调整。下面是一份常见的适合运行Nginx服务器的内核优化参数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">ip_forward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">rp_filter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">accept_source_route</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">kernel</span><span class="o">.</span><span class="n">sysrq</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">kernel</span><span class="o">.</span><span class="n">core_uses_pid</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_syncookies</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">kernel</span><span class="o">.</span><span class="n">msgmnb</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="n">kernel</span><span class="o">.</span><span class="n">msgmax</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="n">kernel</span><span class="o">.</span><span class="n">shmmax</span> <span class="o">=</span> <span class="mi">68719476736</span>
<span class="n">kernel</span><span class="o">.</span><span class="n">shmall</span> <span class="o">=</span> <span class="mi">4294967296</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_max_tw_buckets</span> <span class="o">=</span> <span class="mi">6000</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_sack</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_window_scaling</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_rmem</span> <span class="o">=</span> <span class="mi">4096</span> <span class="mi">87380</span> <span class="mi">4194304</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_wmem</span> <span class="o">=</span> <span class="mi">4096</span> <span class="mi">16384</span> <span class="mi">4194304</span>
<span class="n">net</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">wmem_default</span> <span class="o">=</span> <span class="mi">8388608</span>
<span class="n">net</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">rmem_default</span> <span class="o">=</span> <span class="mi">8388608</span>
<span class="n">net</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">rmem_max</span> <span class="o">=</span> <span class="mi">16777216</span>
<span class="n">net</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">wmem_max</span> <span class="o">=</span> <span class="mi">16777216</span>
<span class="n">net</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">netdev_max_backlog</span> <span class="o">=</span> <span class="mi">262144</span>
<span class="n">net</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">somaxconn</span> <span class="o">=</span> <span class="mi">262144</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_max_orphans</span> <span class="o">=</span> <span class="mi">3276800</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_max_syn_backlog</span> <span class="o">=</span> <span class="mi">262144</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_timestamps</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_synack_retries</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_syn_retries</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_tw_recycle</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_tw_reuse</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_mem</span> <span class="o">=</span> <span class="mi">94500000</span> <span class="mi">915000000</span> <span class="mi">927000000</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_fin_timeout</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">tcp_keepalive_time</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">ip_local_port_range</span> <span class="o">=</span> <span class="mi">1024</span> <span class="mi">65000</span>
</pre></div>
</div>
</section>
<section id="id8">
<h4>4.镜像制作案例<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>案例1</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">centos:7</span>
<span class="k">LABEL</span> maintainer www.chenleilei.net
<span class="k">RUN</span> useradd  www -u <span class="m">1200</span> -M -s /sbin/nologin
<span class="k">RUN</span> mkdir -p /var/log/nginx
<span class="k">RUN</span> yum install -y cmake pcre pcre-devel openssl openssl-devel gd-devel <span class="se">\</span>
    zlib-devel gcc gcc-c++ net-tools iproute telnet wget curl <span class="o">&amp;&amp;</span><span class="se">\</span>
    yum clean all <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -rf /var/cache/yum/*
<span class="k">RUN</span> wget https://www.chenleilei.net/soft/nginx-1.16.1.tar.gz
<span class="k">RUN</span> tar xf nginx-1.16.1.tar.gz
<span class="k">WORKDIR</span><span class="s"> nginx-1.16.1</span>
<span class="k">RUN</span> ./configure --prefix<span class="o">=</span>/usr/local/nginx --with-http_image_filter_module --user<span class="o">=</span>www --group<span class="o">=</span>www <span class="se">\</span>
    --with-http_ssl_module --with-http_v2_module --with-http_stub_status_module <span class="se">\</span>
    --error-log-path<span class="o">=</span>/var/log/nginx/error.log --http-log-path<span class="o">=</span>/var/log/nginx/access.log <span class="se">\</span>
    --pid-path<span class="o">=</span>/var/run/nginx/nginx.pid
<span class="k">RUN</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -rf /usr/local/nginx/html/*  <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="nb">echo</span> <span class="s2">&quot;leilei hello&quot;</span> &gt;/usr/local/nginx/html/index.html  <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -rf nginx* <span class="o">&amp;&amp;</span> <span class="se">\</span>
    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime <span class="o">&amp;&amp;</span><span class="se">\</span>
    ln -sf /dev/stdout /var/log/nginx/access.log <span class="o">&amp;&amp;</span> <span class="se">\</span>
    ln -sf /dev/stderr /var/log/nginx/error.log
<span class="k">RUN</span> chown -R www.www /var/log/nginx
<span class="k">ENV</span> LOG_DIR /var/log/nginx
<span class="k">ENV</span> PATH <span class="nv">$PATH</span>:/usr/local/nginx/sbin
<span class="c">#COPY nginx.conf /usr/local/nginx/conf/nginx.conf</span>
<span class="k">EXPOSE</span><span class="s"> 80</span>
<span class="k">WORKDIR</span><span class="s"> /usr/local/nginx</span>
<span class="k">CMD</span> <span class="p">[</span><span class="s2">&quot;nginx&quot;</span><span class="p">,</span><span class="s2">&quot;-g&quot;</span><span class="p">,</span><span class="s2">&quot;daemon off;&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>案例2</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">centos:7</span>
<span class="k">LABEL</span> maintainer www.chenleilei.net
<span class="k">RUN</span> yum install -y openssl <span class="o">&amp;&amp;</span> <span class="se">\</span>
useradd  www -u <span class="m">1000</span> -M -s /sbin/nologin <span class="o">&amp;&amp;</span> <span class="se">\</span>
rm -fr /etc/yum.repos.d/* <span class="o">&amp;&amp;</span> <span class="se">\</span>
rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm <span class="o">&amp;&amp;</span> yum clean all <span class="o">&amp;&amp;</span> <span class="se">\</span>
yum install -y nginx-1.18.0-2.el7.ngx.x86_64  <span class="o">&amp;&amp;</span>  yum clean all <span class="o">&amp;&amp;</span>  rm -rf /var/cache/yum/* <span class="o">&amp;&amp;</span> <span class="se">\</span>
ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime <span class="o">&amp;&amp;</span> <span class="se">\</span>
ln -sf /dev/stdout /var/log/nginx/access.log <span class="o">&amp;&amp;</span> <span class="se">\</span>
ln -sf /dev/stderr /var/log/nginx/error.log <span class="o">&amp;&amp;</span> <span class="se">\</span>
sed -i <span class="s2">&quot;1,3s#nginx#www#g&quot;</span> /etc/nginx/nginx.conf
<span class="k">EXPOSE</span><span class="s"> 80</span>
<span class="k">EXPOSE</span><span class="s"> 443</span>
<span class="k">WORKDIR</span><span class="s"> /etc/nginx</span>
<span class="k">CMD</span> <span class="p">[</span><span class="s2">&quot;nginx&quot;</span><span class="p">,</span><span class="s2">&quot;-g&quot;</span><span class="p">,</span><span class="s2">&quot;daemon off;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="id9">
<span id="id10"></span><h4>5.相关资源<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>Nginx的相关资源如下：</p>
<ul class="simple">
<li><p>Nginx官网：<a class="reference external" href="https://www.nginx.com">https://www.nginx.com</a></p></li>
<li><p>Nginx官方仓库：<a class="reference external" href="https://github.com/nginx/nginx">https://github.com/nginx/nginx</a></p></li>
<li><p>Nginx官方镜像：<a class="reference external" href="https://hub.docker.com/_/nginx/">https://hub.docker.com/_/nginx/</a></p></li>
<li><p>Nginx官方镜像仓库：<a class="reference external" href="https://github.com/nginxinc/docker-nginx">https://github.com/nginxinc/docker-nginx</a></p></li>
</ul>
</section>
</section>
<section id="tomcat">
<h3><a class="toc-backref" href="#id126">2.3 Tomcat</a><a class="headerlink" href="#tomcat" title="Permalink to this headline">¶</a></h3>
<p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun
Microsystems提供的技术规范，实现了对Servlet和JavaServer
Page（JSP）的支持。同时，它提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，也可以当作单独的Web服务器来使用。</p>
<p><img alt="image10" src="../_images/docker_tomcat001.png" /></p>
<p>下面将以sun_jdk 1.6、tomcat 7.0、ubuntu
18.04环境为例介绍如何定制Tomcat镜像。</p>
<section id="id11">
<h4>1.准备工作<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>创建tomcat7.0_jdk1.6文件夹，从www.oracle.com网站上下载sun_jdk
1.6压缩包，解压为jdk目录。</p>
<p>创建Dockerfile和run.sh文件：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ mkdir tomcat7.0_jdk1.6
$ <span class="nb">cd</span> tomcat7.0_jdk1.6/
$ touch Dockerfile run.sh
</pre></div>
</div>
<p>下载Tomcat，可以到官方网站下载最新的版本，也可以直接使用下面链接中给出的版本：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ wget http://mirror.bit.edu.cn/apache/tomcat/tomcat-7/v7.0.103/bin/apache-tomcat-7.0.103.zip

--2020-04-29 <span class="m">16</span>:55:22--  http://mirror.bit.edu.cn/apache/tomcat/tomcat-7/v7.0.103/bin/apache-tomcat-7.0.103.zip
正在解析主机 mirror.bit.edu.cn <span class="o">(</span>mirror.bit.edu.cn<span class="o">)</span>... <span class="m">2001</span>:da8:204:1205::22, <span class="m">114</span>.247.56.117
正在保存至: “apache-tomcat-7.0.103.zip”
</pre></div>
</div>
<p>解压后，tomcat7.0_jdk1.6目录结构应如下所示（多余的压缩包文件已经被删除）：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ls
Dockerfile  apache-tomcat-7.0.56   jdk  run.sh
</pre></div>
</div>
</section>
<section id="id12">
<h4>2.Dockerfile<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>Dockerfile文件内容如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>FROM sshd:dockerfile
<span class="c1">#设置继承自用户创建的sshd镜像</span>
MAINTAINER docker_user <span class="o">(</span>user@docker.com<span class="o">)</span>
<span class="c1">#下面是一些创建者的基本信息</span>
<span class="c1">#设置环境变量，所有操作都是非交互式的</span>
ENV DEBIAN_FRONTEND noninteractive
RUN <span class="nb">echo</span> <span class="s2">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone <span class="o">&amp;&amp;</span> <span class="se">\</span>
    dpkg-reconfigure -f noninteractive tzdata
<span class="c1">#注意这里要更改系统的时区设置，因为在Web应用中经常会用到时区这个系统变量，默认ubuntu的设置会</span>
　让你的应用程序发生不可思议的效果哦
<span class="c1">#安装跟tomcat用户认证相关的软件</span>
RUN apt-get install -yq --no-install-recommends wget pwgen ca-certificates <span class="o">&amp;&amp;</span> <span class="se">\</span>
    apt-get clean <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -rf /var/lib/apt/lists/*
<span class="c1">#设置tomcat的环境变量，若读者有其他的环境变量需要设置，也可以在这里添加</span>
ENV CATALINA_HOME /tomcat
ENV JAVA_HOME /jdk
<span class="c1">#复制tomcat和jdk文件到镜像中</span>
ADD apache-tomcat-7.0.56 /tomcat
ADD jdk /jdk
ADD create_tomcat_admin_user.sh /create_tomcat_admin_user.sh
ADD run.sh /run.sh
RUN chmod +x /*.sh
RUN chmod +x /tomcat/bin/*.sh
EXPOSE <span class="m">8080</span>
CMD <span class="o">[</span><span class="s2">&quot;/run.sh&quot;</span><span class="o">]</span>
<span class="c1">#创建tomcat用户和密码脚本文件create_tomcat_admin_user.sh文件，内容为：</span>
<span class="c1">#!/bin/bash</span>
<span class="k">if</span> <span class="o">[</span> -f /.tomcat_admin_created <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;Tomcat &#39;admin&#39; user already created&quot;</span>
    <span class="nb">exit</span> <span class="m">0</span>
<span class="k">fi</span>
<span class="c1">#generate password</span>
<span class="nv">PASS</span><span class="o">=</span><span class="si">${</span><span class="nv">TOMCAT_PASS</span><span class="k">:-$(</span>pwgen -s <span class="m">12</span> <span class="m">1</span><span class="k">)</span><span class="si">}</span>
<span class="nv">_word</span><span class="o">=</span><span class="k">$(</span> <span class="o">[</span> <span class="si">${</span><span class="nv">TOMCAT_PASS</span><span class="si">}</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;preset&quot;</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">&quot;random&quot;</span> <span class="k">)</span>
<span class="nb">echo</span> <span class="s2">&quot;=&gt; Creating and admin user with a </span><span class="si">${</span><span class="nv">_word</span><span class="si">}</span><span class="s2"> password in Tomcat&quot;</span>
sed -i -r <span class="s1">&#39;s/&lt;\/tomcat-users&gt;//&#39;</span> <span class="si">${</span><span class="nv">CATALINA_HOME</span><span class="si">}</span>/conf/tomcat-users.xml
<span class="nb">echo</span> <span class="s1">&#39;&lt;role rolename=&quot;manager-gui&quot;/&gt;&#39;</span> &gt;&gt; <span class="si">${</span><span class="nv">CATALINA_HOME</span><span class="si">}</span>/conf/tomcat-users.xml
<span class="nb">echo</span> <span class="s1">&#39;&lt;role rolename=&quot;manager-script&quot;/&gt;&#39;</span> &gt;&gt; <span class="si">${</span><span class="nv">CATALINA_HOME</span><span class="si">}</span>/conf/tomcat-users.xml
<span class="nb">echo</span> <span class="s1">&#39;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&#39;</span> &gt;&gt; <span class="si">${</span><span class="nv">CATALINA_HOME</span><span class="si">}</span>/conf/tomcat-users.xml
<span class="nb">echo</span> <span class="s1">&#39;&lt;role rolename=&quot;admin-gui&quot;/&gt;&#39;</span> &gt;&gt; <span class="si">${</span><span class="nv">CATALINA_HOME</span><span class="si">}</span>/conf/tomcat-users.xml
<span class="nb">echo</span> <span class="s1">&#39;&lt;role rolename=&quot;admin-script&quot;/&gt;&#39;</span> &gt;&gt; <span class="si">${</span><span class="nv">CATALINA_HOME</span><span class="si">}</span>/conf/tomcat-users.xml
<span class="nb">echo</span> <span class="s2">&quot;&lt;user username=\&quot;admin\&quot; password=\&quot;</span><span class="si">${</span><span class="nv">PASS</span><span class="si">}</span><span class="s2">\&quot; roles=\&quot;manager-gui,manager-script,manager-jmx,admin-gui, admin-script\&quot;/&gt;&quot;</span> &gt;&gt; <span class="si">${</span><span class="nv">CATALINA_HOME</span><span class="si">}</span>/conf/tomcat-users.xml
<span class="nb">echo</span> <span class="s1">&#39;&lt;/tomcat-users&gt;&#39;</span> &gt;&gt; <span class="si">${</span><span class="nv">CATALINA_HOME</span><span class="si">}</span>/conf/tomcat-users.xml
<span class="nb">echo</span> <span class="s2">&quot;=&gt; Done!&quot;</span>
touch /.tomcat_admin_created
<span class="nb">echo</span> <span class="s2">&quot;========================================================================&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;You can now configure to this Tomcat server using:&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;    admin:</span><span class="si">${</span><span class="nv">PASS</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;========================================================================&quot;</span>
</pre></div>
</div>
<p>编写run.sh脚本文件，内容为：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="k">if</span> <span class="o">[</span> ! -f /.tomcat_admin_created <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    /create_tomcat_admin_user.sh
<span class="k">fi</span>
/usr/sbin/sshd -D <span class="p">&amp;</span>
<span class="nb">exec</span> <span class="si">${</span><span class="nv">CATALINA_HOME</span><span class="si">}</span>/bin/catalina.sh run
</pre></div>
</div>
</section>
<section id="id13">
<h4>3.创建和测试镜像<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>通过下面的命令创建镜像tomcat7.0：jdk1.6：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t tomcat7.0:jdk1.6 .
…
Successfully built ce78537c247d
</pre></div>
</div>
<p>启动一个tomcat容器进行测试：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -P tomcat7.0:jdk1.6
3cd4238cb32a713a3a1c29d93fbfc80cba150653b5eb8bd7629bee957e7378ed
</pre></div>
</div>
<p>通过docker logs得到tomcat的密码aBwN0CNCPckw：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker logs <span class="nv">3cd</span>
<span class="o">=</span>&gt; Creating and admin user with a random password <span class="k">in</span> <span class="nv">Tomcat</span>
<span class="o">=</span>&gt; Done!
<span class="o">========================================================================</span>
You can now configure to this Tomcat server using:
    admin:aBwN0CNCPckw
<span class="o">========================================================================</span>
</pre></div>
</div>
<p>查看映射的端口信息：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker ps
CONTAINER ID   IMAGE               COMMAND     CREATED          STATUS    PORTS    NAMES
3cd4238cb32a   tomcat7.0:jdk1.6   <span class="s2">&quot;/run.sh&quot;</span>   <span class="m">4</span> seconds ago   Up <span class="m">3</span> seconds   <span class="m">0</span>.0.0.0: <span class="m">49157</span>-&gt;22/tcp, <span class="m">0</span>.0.0.0:49158-&gt;8080/tcp   cranky_wright
</pre></div>
</div>
<p>在本地使用浏览器登录Tomcat管理界面，访问本地的49158端口，即<a class="reference external" href="http://127.0.0.1:49158/">http://127.0.0.1:49158</a>
，可以看见启动页面。</p>
<p>Tomcat启动页面 <img alt="image11" src="../_images/docker_tomcat0002.png" /></p>
<p>输入从docker logs中得到的密码</p>
<p>Tomcat登录</p>
<p><img alt="image12" src="../_images/docker_tomcat0003.png" /></p>
<p>成功进入管理界面。</p>
<p>管理界面</p>
<p><img alt="image13" src="../_images/docker_tomcat004.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">注意</span></code>
在实际环境中，可以通过使用-v参数来挂载Tomcat的日志文件、程序所在目录、以及与Tomcat相关的配置。</p>
</section>
<section id="id14">
<span id="id15"></span><h4>4.相关资源<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>Tomcat的相关资源如下：</p>
<ul class="simple">
<li><p>Tomcat官网：<a class="reference external" href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p></li>
<li><p>Tomcat官方仓库：<a class="reference external" href="https://github.com/apache/tomcat">https://github.com/apache/tomcat</a></p></li>
<li><p>Tomcat官方镜像：<a class="reference external" href="https://hub.docker.com/_/tomcat/">https://hub.docker.com/_/tomcat/</a></p></li>
<li><p>Tomcat官方镜像仓库：<a class="reference external" href="https://github.com/docker-library/tomcat">https://github.com/docker-library/tomcat</a></p></li>
</ul>
</section>
</section>
<section id="jetty">
<h3><a class="toc-backref" href="#id127">2.4 Jetty</a><a class="headerlink" href="#jetty" title="Permalink to this headline">¶</a></h3>
<p>Jetty是一个优秀的开源servlet容器，以其高效、小巧、可嵌入式等优点深得人心，它为基于Java的Web内容（如JSP和servlet）提供运行环境。Jetty基于Java语言编写，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供Web服务。</p>
<p><img alt="image14" src="../_images/docker_jetty01.png" /></p>
<p>与相对老牌的Tomcat比，Jetty架构更合理，性能更优。尤其在启动速度上，让Tomcat望尘莫及。Jetty目前在国内外互联网企业中应用广泛。</p>
<section id="id16">
<h4>1.使用官方镜像<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>DockerHub官方提供了Jetty镜像，直接运行docker[container]run指令即可：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d jetty
f7f1d70f2773be12b54c40e3222c4e658fd7c39f22337e457984b13fbc64a54c
</pre></div>
</div>
<p>使用docker ps指令查看正在运行中的Jetty容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker ps
CONTAINER ID  IMAGE COMMAND              CREATED  STATUS PORTS      NAMES
f7f1d70f2773  jetty <span class="s2">&quot;/docker-entrypoint.b&quot;</span> x ago   Up     <span class="m">8080</span>/tcp    lonely_poitras
</pre></div>
</div>
<p>当然，还可以使用-p参数映射运行端口：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p <span class="m">80</span>:8080 -p <span class="m">443</span>:8443 jetty
7bc629845e8b953e02e31caaac24744232e21816dcf81568c029eb8750775733
</pre></div>
</div>
<p>使用宿主机的浏览器访问container-ip：8080，即可获得Jetty运行页面，由于当前没有内容，会提示错误信息。如图：</p>
<p><img alt="image15" src="../_images/docker_jetty02.png" /></p>
</section>
<section id="id17">
<span id="id18"></span><h4>2.相关资源<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>Jetty的相关资源如下：</p>
<ul class="simple">
<li><p>Jetty官网：<a class="reference external" href="http://www.eclipse.org/jetty/">http://www.eclipse.org/jetty/</a></p></li>
<li><p>Jetty官方仓库：<a class="reference external" href="https://github.com/eclipse/jetty.project">https://github.com/eclipse/jetty.project</a></p></li>
<li><p>Jetty官方镜像：<a class="reference external" href="https://hub.docker.com/_/jetty/">https://hub.docker.com/_/jetty/</a></p></li>
<li><p>Jetty官方镜像仓库：<a class="reference external" href="https://github.com/appropriate/docker-jetty">https://github.com/appropriate/docker-jetty</a></p></li>
</ul>
</section>
</section>
<section id="lamp">
<h3><a class="toc-backref" href="#id128">2.5 LAMP</a><a class="headerlink" href="#lamp" title="Permalink to this headline">¶</a></h3>
<p>LAMP（Linux-Apache-MySQL-PHP）是目前流行的Web工具栈，其中包括：Linux操作系统，Apache网络服务器，MySQL数据库，Perl、PHP或者Python编程语言。其组成工具均是成熟的开源软件，被大量网站所采用。和Java/J2EE架构相比，LAMP具有Web资源丰富、轻量、快速开发等特点；和微软的.NET架构相比，LAMP更具有通用、跨平台、高性能、低价格的优势。因此LAMP技术栈得到了广泛的应用。</p>
<p><img alt="image16" src="../_images/docker_lamp001.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">注意</span></code>
现在也有人用Nginx替换Apache，称为LNMP或LEMP，是十分类似的技术栈，并不影响整个技术框架的选型原则。</p>
<section id="id19">
<span id="id20"></span><h4>1.使用官方镜像<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>用户可以使用自定义Dockerfile或者Compose方式运行LAMP，同时社区也提供了十分成熟的linode/lamp和tutum/lamp镜像。</p>
</section>
<section id="linode-lamp">
<h4>（1）使用linode/lamp镜像<a class="headerlink" href="#linode-lamp" title="Permalink to this headline">¶</a></h4>
<p>首先，执行docker[container]run指令，直接运行镜像，并进入容器内部bash
shell：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker run -p <span class="m">80</span>:80 -t -i linode/lamp /bin/bash
root@e283cc3b2908:/#
</pre></div>
</div>
<p>在容器内部shell启动Apache以及MySQL服务：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ root@e283cc3b2908:/# service apache2 start
  * Starting web server apache2
$ root@e283cc3b2908:/# service mysql start
  * Starting MySQL database server mysqld                                 <span class="o">[</span> OK <span class="o">]</span>
  * Checking <span class="k">for</span> tables which need an upgrade, are corrupt or were
not closed cleanly.
</pre></div>
</div>
<p>此时镜像中Apache、MySQL服务已经启动，可使用docker
ps指令查看运行中的容器：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">root</span><span class="nd">@desktop</span><span class="o">-</span><span class="n">pmjtngi</span> <span class="o">~</span><span class="p">]</span><span class="c1"># docker ps</span>
<span class="n">CONTAINER</span> <span class="n">ID</span>        <span class="n">IMAGE</span>               <span class="n">COMMAND</span>             <span class="n">CREATED</span>             <span class="n">STATUS</span>              <span class="n">PORTS</span>                <span class="n">NAMES</span>
<span class="mf">52531235e745</span>        <span class="n">linode</span><span class="o">/</span><span class="n">lamp</span>         <span class="s2">&quot;/bin/bash&quot;</span>         <span class="mi">46</span> <span class="n">seconds</span> <span class="n">ago</span>      <span class="n">Up</span> <span class="mi">46</span> <span class="n">seconds</span>       <span class="mf">0.0.0.0</span><span class="p">:</span><span class="mi">80</span><span class="o">-&gt;</span><span class="mi">80</span><span class="o">/</span><span class="n">tcp</span>   <span class="n">practical_meninsky</span>
</pre></div>
</div>
<p>此时通过浏览器访问本地80端口即可看到默认页面。如图</p>
<p>linode/lamp默认页面</p>
<p><img alt="image17" src="../_images/docker_lamp002.png" /></p>
</section>
<section id="tutum-lamp">
<h4>（2）使用tutum/lamp镜像<a class="headerlink" href="#tutum-lamp" title="Permalink to this headline">¶</a></h4>
<p>首先，执行docker[container]run指令，直接运行镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p <span class="m">80</span>:80 -p <span class="m">3306</span>:3306 tutum/lamp
51e231878d3d61d4fd28874e22261f5cd740082826e870ac5568d6f2d77850e7
</pre></div>
</div>
<p>容器启动成功后，打开浏览器，访问demo页面，如图</p>
<p>LAMP容器Demo页面</p>
<p><img alt="image18" src="../_images/docker_lamp003.png" /></p>
</section>
<section id="php">
<h4>（3）部署自定义PHP应用<a class="headerlink" href="#php" title="Permalink to this headline">¶</a></h4>
<p>默认的容器启动了一个helloword应用。读者可以基于此镜像，编辑Dockerfile来创建自定义LAMP应用镜像。</p>
<p>在宿主主机上创建新的工作目录lamp：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ mkdir lamp
$ <span class="nb">cd</span> lamp
$ touch Dockerfile
</pre></div>
</div>
<p>在php目录下里面创建Dockerfile文件，内容为：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>FROM tutum/lamp:latest
RUN rm -fr /app <span class="o">&amp;&amp;</span> git clone https://github.com/username/customapp.git /app
<span class="c1">#这里替换 https://github.com/username/customapp.git 地址为你自己的项目地址</span>
EXPOSE <span class="m">80</span> <span class="m">3306</span>
CMD <span class="o">[</span><span class="s2">&quot;/run.sh&quot;</span><span class="o">]</span>
</pre></div>
</div>
<p>创建镜像，命名为my-lamp-app：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker build -t my-lamp-app .
</pre></div>
</div>
<p>利用新创建镜像启动容器，注意启动时候指定-d参数，让容器后台运行：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p <span class="m">8080</span>:80 -p <span class="m">3306</span>:3306 my-lamp-app
</pre></div>
</div>
<p>在本地主机上使用curl命令测试应用程序是不是已经正常响应：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ curl http://127.0.0.1:8080/
</pre></div>
</div>
</section>
<section id="id21">
<span id="id22"></span><h4>2.相关资源<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>LAMP的相关资源如下：</p>
<ul class="simple">
<li><p>tutum LAMP镜像：<a class="reference external" href="https://hub.docker.com/r/tutum/lamp/">https://hub.docker.com/r/tutum/lamp/</a></p></li>
<li><p>linode LAMP镜像：<a class="reference external" href="https://hub.docker.com/r/linode/lamp/">https://hub.docker.com/r/linode/lamp/</a></p></li>
</ul>
</section>
</section>
</section>
<section id="id23">
<h2><a class="toc-backref" href="#id129">3. 持续开发与管理</a><a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p>信息行业日新月异，如何响应不断变化的需求，快速适应和保证软件的质量？持续集成（Continuous
Integration，CI）正是针对解决这类问题的一种开发实践，它倡导开发团队定期进行集成验证。集成通过自动化的构建来完成，包括自动编译、发布和测试，从而尽快地发现错误。</p>
<p>持续集成的特点包括：</p>
<ul class="simple">
<li><p>鼓励自动化的周期性的过程，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，减少人工干预；</p></li>
<li><p>需要有持续集成系统的支持，包括代码托管机制支持，以及集成服务器等。</p></li>
</ul>
<p>持续交付（Continuous
Delivery，CD）则是经典的敏捷软件开发方法的自然延伸，它强调产品在修改后到部署上线的流程要敏捷化、自动化。甚至一些较小的改变也要尽早地部署上线，这与传统软件在较大版本更新后才上线的思路不同。</p>
<section id="jenkins">
<h3><a class="toc-backref" href="#id130">3.1 Jenkins及官方镜像</a><a class="headerlink" href="#jenkins" title="Permalink to this headline">¶</a></h3>
<p><img alt="image19" src="../_images/docker_jenkins0001.png" /></p>
<p>Jenkins是一个得到广泛应用的持续集成和持续交付的工具。作为开源软件项目，它旨在提供一个开放易用的持续集成平台。Jenkins能实时监控集成中存在的错误，提供详细的日志文件和提醒功能，并用图表的形式形象地展示项目构建的趋势和稳定性。Jenkins特点包括安装配置简单、支持详细的测试报表、分布式构建等。</p>
<p>Jenkis自2.0版本推出了“Pipeline as
Code”，帮助Jenkins实现对CI和CD更好的支持。通过Pipeline，将原本独立运行的多个任务连接起来，可以实现十分复杂的发布流程。</p>
<p>Jenkins Pipeline示意图</p>
<p><img alt="image20" src="../_images/docker_jenkins003.png" /></p>
<p>Jenkins官方在DockerHub上提供了全功能的基于官方发布版的Docker镜像。</p>
<p>可以方便地使用docker[container]run指令一键部署Jenkins服务：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -p <span class="m">8080</span>:8080 -p <span class="m">50000</span>:50000 jenkins
Apr <span class="m">30</span>, <span class="m">2020</span> <span class="m">4</span>:57:50 AM jenkins.install.SetupWizard init
INFO:

*************************************************************
*************************************************************
*************************************************************

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

f05ae5368fd74ee68b34ae41dbc4eaed

This may also be found at: /var/jenkins_home/secrets/initialAdminPassword
</pre></div>
</div>
<p>再打开一个控制台终端查看jenkins的密码：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@desktop-pmjtngi lamp<span class="o">]</span><span class="c1"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                              NAMES
4991a17aaed0        jenkins             <span class="s2">&quot;/bin/tini -- /usr/l…&quot;</span>   <span class="m">2</span> minutes ago       Up <span class="m">2</span> minutes        <span class="m">0</span>.0.0.0:8080-&gt;8080/tcp, <span class="m">0</span>.0.0.0:50000-&gt;50000/tcp   admiring_
einstein<span class="o">[</span>root@desktop-pmjtngi lamp<span class="o">]</span><span class="c1"># docker exec -it 4991a17aaed0 cat /var/jenkins_home/secrets/initialAdminPassword</span>
f05ae5368fd74ee68b34ae41dbc4eaed
</pre></div>
</div>
<p>Jenkins容器启动成功后，可以打开浏览器访问8080端口，查看Jenkins管理界面，如图:</p>
<p><img alt="image21" src="../_images/docker_jenkins004.png" /></p>
<p>目前运行的容器中，数据会存储在工作目录/var/jenkins_home中，这包括Jenkins中所有的数据，如插件和配置信息等。如果需要数据持久化，读者可以使用数据卷机制：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -p <span class="m">8080</span>:8080 -p <span class="m">50000</span>:50000 -v /your/home:/var/jenkins_home jenkins
e25d995cc4a44d08a5d81af10aed0cf6
</pre></div>
</div>
<p>以上指令会将Jenkins数据存储于宿主机的/your/home目录（需要确保/your/home目录对于容器内的Jenkins用户是可访问的）下。当然也可以使用数据卷容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name myjenkins -p <span class="m">8080</span>:8080 -p <span class="m">50000</span>:50000 -v /var/jenkins_home jenkins
</pre></div>
</div>
<p>参考文献：</p>
<p><a class="reference external" href="https://www.cnblogs.com/anliven/p/11893316.html">DevOps -
以Docker方式启动Jenkins</a></p>
<p><a class="reference external" href="https://www.cnblogs.com/xiao987334176/p/13373198.html">基于docker搭建jenkins</a></p>
<p><a class="reference external" href="https://www.cnblogs.com/xiao987334176/p/13180819.html">jenkins 调用Rancher2.x
api实现CI/CD</a></p>
<p><a class="reference external" href="https://www.cnblogs.com/xiao987334176/p/13140005.html">python调用jenkinsAPI</a></p>
<p><a class="reference external" href="https://www.cnblogs.com/xiao987334176/p/13074198.html">基于Jenkins+Gitlab+Harbor+Rancher+k8s
CI/CD实现</a></p>
<p><a class="reference external" href="https://www.cnblogs.com/xiao987334176/p/11434849.html">Jenkins+harbor+gitlab+k8s
部署maven项目</a></p>
</section>
<section id="gitlab">
<h3><a class="toc-backref" href="#id131">3.2 GitLab及其官方镜像</a><a class="headerlink" href="#gitlab" title="Permalink to this headline">¶</a></h3>
<p><img alt="image22" src="../_images/docker_gitlab001.png" /></p>
<p>GitLab是一款非常强大的开源源码管理系统。它支持基于Git的源码管理、代码评审、issue跟踪、活动管理、wiki页面、持续集成和测试等功能。基于GitLab，用户可以自己搭建一套类似于Github的开发协同平台。</p>
<p>GitLab官方提供了社区版本（GitLab CE）的DockerHub镜像，可以直接使用docker
run指令运行：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --detach <span class="se">\</span>
    --hostname gitlab.example.com <span class="se">\</span>
    --publish <span class="m">443</span>:443 --publish <span class="m">80</span>:80 --publish <span class="m">23</span>:23 <span class="se">\</span>
    --name gitlab <span class="se">\</span>
    --restart always <span class="se">\</span>
    --volume /srv/gitlab/config:/etc/gitlab <span class="se">\</span>
    --volume /srv/gitlab/logs:/var/log/gitlab <span class="se">\</span>
    --volume /srv/gitlab/data:/var/opt/gitlab <span class="se">\</span>
    gitlab/gitlab-ce:latest

dbae485d24492f656d2baf18526552353cd55aac662e32491046ed7fa033be3a
</pre></div>
</div>
<p>成功运行镜像后，可以打开浏览器访问GitLab服务管理界面，如图</p>
<p><img alt="image23" src="../_images/docker_gitlab002.png" /></p>
<p>参考文献：</p>
<p><a class="reference external" href="https://www.cnblogs.com/anliven/p/12070966.html">DevOps -
以Docker方式启动GitLab</a></p>
<p><a class="reference external" href="https://www.cnblogs.com/xiao987334176/p/13372837.html">基于docker搭建gitlab</a></p>
<p>docker-compose部署gitlab中文版</p>
<p>参考：</p>
<p><a class="reference external" href="https://www.jianshu.com/p/2d76092ebf53">https://www.jianshu.com/p/2d76092ebf53</a></p>
<p>参考：</p>
<p><a class="reference external" href="https://www.jb51.net/article/152570.htm">https://www.jb51.net/article/152570.htm</a></p>
</section>
<section id="id24">
<span id="id25"></span><h3><a class="toc-backref" href="#id132">3.3 相关资源</a><a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p>Jenkins的相关资源如下：</p>
<ul class="simple">
<li><p>Jenkins官网：<a class="reference external" href="https://jenkins.io/">https://jenkins.io/</a></p></li>
<li><p>Jenkins官方仓库：<a class="reference external" href="https://github.com/jenkinsci/jenkins/">https://github.com/jenkinsci/jenkins/</a></p></li>
<li><p>Jenkins官方镜像：<a class="reference external" href="https://hub.docker.com/r/jenkinsci/jenkins/">https://hub.docker.com/r/jenkinsci/jenkins/</a></p></li>
<li><p>Jenkins官方镜像仓库：<a class="reference external" href="https://github.com/jenkinsci/docker">https://github.com/jenkinsci/docker</a></p></li>
</ul>
<p>GitLab的相关资源如下：</p>
<ul class="simple">
<li><p>GitLab官网：<a class="reference external" href="https://github.com/gitlabhq/gitlabhq">https://github.com/gitlabhq/gitlabhq</a></p></li>
<li><p>GitLab官方镜像：<a class="reference external" href="https://hub.docker.com/r/gitlab/gitlab-ce/">https://hub.docker.com/r/gitlab/gitlab-ce/</a></p></li>
</ul>
</section>
</section>
<section id="id26">
<h2><a class="toc-backref" href="#id133">4. 数据库应用</a><a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h2>
<p>目前，主流数据库包括关系型（SQL）和非关系型（NoSQL）两种。关系数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据，支持复杂的事物处理和结构化查询。代表实现有MySQL、Oracle、PostGreSQL、MariaDB、SQLServer等。</p>
<p>非关系数据库是新兴的数据库技术，它放弃了传统关系型数据库的部分强一致性限制，带来性能上的提升，使其更适用于需要大规模并行处理的场景。非关系型数据库是关系型数据库的良好补充，代表产品有MongoDB、Redis等。</p>
<p>本章选取了最具代表性的数据库如MySQL、Oracle、MongoDB、Redis、Cassandra等，来讲解基于Docker创建相关镜像并进行应用的过程。</p>
<section id="mysql">
<h3><a class="toc-backref" href="#id134">4.1 MySQL</a><a class="headerlink" href="#mysql" title="Permalink to this headline">¶</a></h3>
<p>MySQL是全球最流行的开源关系型数据库之一，由于其具有高性能、成熟可靠、高适应性、易用性而得到广泛应用。</p>
<p><img alt="image24" src="../_images/docker_mysql001.png" /></p>
<section id="id27">
<span id="id28"></span><h4>1.使用官方镜像<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>用户可以使用官方镜像快速启动一个MySQL Server实例：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name hi-mysql -e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>my-pwd -d mysql:latest
e6cb906570549812c798b7b3ce46d669a8a4e8ac62a3f3c8997e4c53d16301b6
</pre></div>
</div>
<p>以上指令中的hi-mysql是容器名称，<code class="docutils literal notranslate"><span class="pre">my-pwd为数据库的root用户密码</span></code>。</p>
<p>使用docker ps指令可以看到现在运行中的容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                 NAMES
6f4aa173b2aa        mysql:latest        <span class="s2">&quot;docker-entrypoint.s…&quot;</span>   <span class="m">31</span> seconds ago      Up <span class="m">30</span> seconds       <span class="m">3306</span>/tcp, <span class="m">33060</span>/tcp   hi-mysql
</pre></div>
</div>
<p>当然，还可以使用–link标签将一个应用容器连接至MySQL容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name some-app --link some-mysql:mysql -d application-that-uses-mysql
</pre></div>
</div>
<p>MySQL服务的标准端口是3306，用户可以通过CLI工具对配置进行修改：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --link some-mysql:mysql --rm mysql sh -c <span class="s1">&#39;exec mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&#39;</span>
</pre></div>
</div>
<p>官方MySQL镜像还可以作为客户端，连接非Docker或者远程的MySQL实例：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm mysql mysql -hsome.mysql.host -usome-mysql-user -p
</pre></div>
</div>
</section>
<section id="id29">
<h4>（1）系统与日志访问<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<p>用户可以使用docker exec指令调用内部系统中的bash
shell，以访问容器内部系统：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker exec -it some-mysql bash
</pre></div>
</div>
<p>MySQL Server日志可以使用docker logs指令查看：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker logs some-mysql
</pre></div>
</div>
</section>
<section id="id30">
<h4>（2）使用自定义配置文件<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h4>
<p>如果用户希望使用自定义MySQL配置，则可以创建一个目录，内置cnf配置文件，然后将其挂载至容器的/etc/mysql/conf.d目录。比如，自定义配置文件为/my/custom/config-file.cnf，则可以使用以下指令：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name some-mysql -v /my/custom:/etc/mysql/conf.d -e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>my-secret-pw -d mysql:tag
</pre></div>
</div>
<p>这时新的容器some-mysql启动后，就会结合使用/etc/mysql/my.cnf和/etc/mysql/conf.d/config-file.cnf两个配置文件。</p>
<p>参考文献
<a class="reference external" href="https://www.cnblogs.com/xiao987334176/p/11984692.html">docker封装mysql镜像</a></p>
</section>
<section id="cnf">
<h4>（3）脱离cnf文件进行配置<a class="headerlink" href="#cnf" title="Permalink to this headline">¶</a></h4>
<p>很多的配置选项可以通过标签（flags）传递至mysqld进程，这样用户就可以脱离cnf配置文件，对容器进行弹性的定制。比如，用户需要改变默认编码方式，将所有表格的编码方式修改为uft8mb4，则可以使用如下指令：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name some-mysql -e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>my-secret-pw -d mysql:tag --character-set-server<span class="o">=</span>utf8mb4 --collation-server<span class="o">=</span>utf8mb4_unicode_ci
</pre></div>
</div>
<p>如果需要查看可用选项的完整列表，可以执行如下指令：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm mysql:tag --verbose --help
</pre></div>
</div>
</section>
<section id="docker-stack-deploydocker-compose">
<h4>（4）通过docker stack deploy或docker-compose运行<a class="headerlink" href="#docker-stack-deploydocker-compose" title="Permalink to this headline">¶</a></h4>
<p>MySQL的示例<code class="docutils literal notranslate"><span class="pre">stack.yml</span></code>如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use root/example as user/password credentials</span>
<span class="n">version</span><span class="p">:</span> <span class="s1">&#39;3.1&#39;</span>
<span class="n">services</span><span class="p">:</span>
    <span class="n">db</span><span class="p">:</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">mysql</span>
        <span class="n">restart</span><span class="p">:</span> <span class="n">always</span>
        <span class="n">environment</span><span class="p">:</span>
            <span class="n">MYSQL_ROOT_PASSWORD</span><span class="p">:</span> <span class="n">example</span>
    <span class="n">adminer</span><span class="p">:</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">adminer</span>
        <span class="n">restart</span><span class="p">:</span> <span class="n">always</span>
        <span class="n">ports</span><span class="p">:</span>
            <span class="o">-</span> <span class="mi">8080</span><span class="p">:</span><span class="mi">8080</span>
</pre></div>
</div>
<p>docker-compose部署mysql5.6</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">version</span><span class="p">:</span> <span class="s1">&#39;3.8&#39;</span>

<span class="n">services</span><span class="p">:</span>
  <span class="n">mysql</span><span class="p">:</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">hub</span><span class="o">.</span><span class="n">gitee</span><span class="o">.</span><span class="n">cc</span><span class="o">/</span><span class="n">library</span><span class="o">/</span><span class="n">mysql</span><span class="p">:</span><span class="mf">5.6.48</span>
    <span class="n">restart</span><span class="p">:</span> <span class="n">always</span>
    <span class="n">command</span><span class="p">:</span> <span class="o">--</span><span class="n">character</span><span class="o">-</span><span class="nb">set</span><span class="o">-</span><span class="n">server</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="o">--</span><span class="n">collation</span><span class="o">-</span><span class="n">server</span><span class="o">=</span><span class="n">utf8mb4_unicode_ci</span>
    <span class="n">environment</span><span class="p">:</span>
      <span class="o">-</span> <span class="n">MYSQL_ROOT_PASSWORD</span><span class="o">=</span><span class="n">oschina123</span>
      <span class="o">-</span> <span class="n">MYSQL_DATABASE</span><span class="o">=</span><span class="n">gitlabhq_production</span>
      <span class="o">-</span> <span class="n">MYSQL_USER</span><span class="o">=</span><span class="n">giteeci</span>
      <span class="o">-</span> <span class="n">MYSQL_PASSWORD</span><span class="o">=</span><span class="mi">123456</span>
      <span class="o">-</span> <span class="n">MYSQL_HOST</span><span class="o">=%</span>
    <span class="n">user</span><span class="p">:</span> <span class="mi">1000</span><span class="p">:</span><span class="mi">1000</span>
    <span class="n">ports</span><span class="p">:</span>
      <span class="o">-</span> <span class="mi">3306</span><span class="p">:</span><span class="mi">3306</span>
    <span class="n">volumes</span><span class="p">:</span>
      <span class="o">-</span> <span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">mysql</span><span class="p">:</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">mysql</span>
      <span class="o">-</span> <span class="o">./</span><span class="n">mysql</span><span class="o">.</span><span class="n">cnf</span><span class="p">:</span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">mysql</span><span class="o">/</span><span class="n">conf</span><span class="o">.</span><span class="n">d</span><span class="o">/</span><span class="n">mysql</span><span class="o">.</span><span class="n">cnf</span>
</pre></div>
</div>
<p>docker-compose部署mysql5.7</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">version</span><span class="p">:</span> <span class="s2">&quot;3&quot;</span>
<span class="n">services</span><span class="p">:</span>
  <span class="n">mysql</span><span class="p">:</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">mysql</span><span class="p">:</span><span class="mf">5.7</span>
    <span class="n">restart</span><span class="p">:</span> <span class="n">always</span>
    <span class="n">hostname</span><span class="p">:</span> <span class="n">mysql</span><span class="o">-</span><span class="n">master</span>
    <span class="n">container_name</span><span class="p">:</span> <span class="s2">&quot;mysql57-giteeci&quot;</span>
    <span class="n">ports</span><span class="p">:</span>
      <span class="o">-</span> <span class="mi">33006</span><span class="p">:</span><span class="mi">3306</span>
    <span class="n">environment</span><span class="p">:</span>
      <span class="n">TZ</span><span class="p">:</span> <span class="n">Asia</span><span class="o">/</span><span class="n">Shanghai</span>
      <span class="n">MYSQL_ROOT_PASSWORD</span><span class="p">:</span> <span class="n">oschina123</span>
      <span class="n">MYSQL_DATABASE</span><span class="p">:</span> <span class="n">gitlabhq_production</span>
      <span class="n">MYSQL_USER</span><span class="p">:</span> <span class="n">giteeci</span>
      <span class="n">MYSQL_PASSWORD</span><span class="p">:</span> <span class="mi">123456</span>
      <span class="n">MYSQL_HOST</span><span class="p">:</span> <span class="s2">&quot;%&quot;</span>
    <span class="n">volumes</span><span class="p">:</span>
      <span class="o">-</span> <span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">mysql57</span><span class="p">:</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">mysql</span>
      <span class="o">-</span> <span class="o">./</span><span class="n">mysql</span><span class="o">.</span><span class="n">cnf</span><span class="p">:</span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">mysql</span><span class="o">/</span><span class="n">conf</span><span class="o">.</span><span class="n">d</span><span class="o">/</span><span class="n">mysql</span><span class="o">.</span><span class="n">cnf</span>
    <span class="n">command</span><span class="p">:</span>
      <span class="o">--</span><span class="n">server_id</span><span class="o">=</span><span class="mi">100</span>
      <span class="o">--</span><span class="n">log</span><span class="o">-</span><span class="nb">bin</span><span class="o">=</span><span class="n">mysql</span><span class="o">-</span><span class="nb">bin</span>
      <span class="o">--</span><span class="n">sync_binlog</span><span class="o">=</span><span class="mi">1</span>
      <span class="o">--</span><span class="n">binlog</span><span class="o">-</span><span class="n">ignore</span><span class="o">-</span><span class="n">db</span><span class="o">=</span><span class="n">mysql</span>
      <span class="o">--</span><span class="n">binlog_format</span><span class="o">=</span><span class="n">mixed</span>
      <span class="o">--</span><span class="n">expire_logs_days</span><span class="o">=</span><span class="mi">7</span>
      <span class="o">--</span><span class="n">default</span><span class="o">-</span><span class="n">authentication</span><span class="o">-</span><span class="n">plugin</span><span class="o">=</span><span class="n">mysql_native_password</span>
      <span class="o">--</span><span class="n">character</span><span class="o">-</span><span class="nb">set</span><span class="o">-</span><span class="n">server</span><span class="o">=</span><span class="n">utf8mb4</span>
      <span class="o">--</span><span class="n">collation</span><span class="o">-</span><span class="n">server</span><span class="o">=</span><span class="n">utf8mb4_general_ci</span>
      <span class="o">--</span><span class="n">explicit_defaults_for_timestamp</span><span class="o">=</span><span class="n">true</span>
      <span class="o">--</span><span class="n">lower_case_table_names</span><span class="o">=</span><span class="mi">1</span>
      <span class="o">--</span><span class="n">sql_mode</span><span class="o">=</span><span class="n">NO_ENGINE_SUBSTITUTION</span><span class="p">,</span><span class="n">STRICT_TRANS_TABLES</span>
      <span class="c1">#--sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span>
</pre></div>
</div>
<p>docker安装mysql8.0</p>
<p><a class="reference external" href="http://oudezhinu.site/%e6%8a%80%e6%9c%af%e6%80%bb%e7%bb%93/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f/linux%e6%8a%80%e5%b7%a7/docker%e5%ae%89%e8%a3%85mysql8-0/">http://oudezhinu.site/%e6%8a%80%e6%9c%af%e6%80%bb%e7%bb%93/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f/linux%e6%8a%80%e5%b7%a7/docker%e5%ae%89%e8%a3%85mysql8-0/</a></p>
</section>
<section id="id31">
<span id="id32"></span><h4>2.相关资源<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h4>
<p>MySQL的相关资源如下：</p>
<ul class="simple">
<li><p>MySQL官网：<a class="reference external" href="https://www.mysql.com/">https://www.mysql.com/</a></p></li>
<li><p>MySQL官方镜像：<a class="reference external" href="https://hub.docker.com/_/mysql/">https://hub.docker.com/_/mysql/</a></p></li>
<li><p>MySQL官方镜像仓库：<a class="reference external" href="https://github.com/docker-library/mysql/">https://github.com/docker-library/mysql/</a></p></li>
</ul>
</section>
</section>
<section id="oracle-database-xe">
<h3><a class="toc-backref" href="#id135">4.2 Oracle Database XE</a><a class="headerlink" href="#oracle-database-xe" title="Permalink to this headline">¶</a></h3>
<p>Oracle Database 11g快捷版（Oracle Database XE）是一款基于Oracle Database
11g第2版代码库的小型入门级数据库，具备以下优点：</p>
<p><img alt="image25" src="../_images/docker_oracle001.png" /></p>
<p>·免费开发、部署和分发； ·体积较小，下载速度快； ·管理配置简单。</p>
<p>作为一款优秀的入门级数据库，它适合以下用户使用：</p>
<p>·致力于PHP、Java、.NET、XML和开源应用程序的开发人员；
·需要免费的入门级数据库进行培训和部署的DBA；
·需要入门级数据库进行免费分发的独立软件供应商（ISV）和硬件供应商；
·需要在课程中使用免费数据库的教育机构和学生。</p>
<p>Oracle Database
XE对安装主机的规模和CPU数量不作限制（每台计算机一个数据库），但XE将最多存储11
GB的用户数据，同时最多使用1 GB内存和主机上的一个CPU。</p>
<section id="oracle">
<h4>1.搜索Oracle镜像<a class="headerlink" href="#oracle" title="Permalink to this headline">¶</a></h4>
<p>直接在DockerHub上搜索镜像，并下载wnameless/oracle-xe-11g镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker search --filter<span class="o">=</span><span class="nv">stars</span><span class="o">=</span><span class="m">50</span> oracle
NAME                              DESCRIPTION                                STARS               OFFICIAL            AUTOMATED
oraclelinux                       Official Docker builds of Oracle Linux.    <span class="m">646</span>                 <span class="o">[</span>OK<span class="o">]</span>
jaspeen/oracle-11g                Docker image <span class="k">for</span> Oracle 11g database       <span class="m">157</span>                                     <span class="o">[</span>OK<span class="o">]</span>
oracleinanutshell/oracle-xe-11g                                              <span class="m">93</span>
oracle/graalvm-ce                 GraalVM Community Edition Official Image   <span class="m">66</span>                                      <span class="o">[</span>OK<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="id33">
<h4>2.启动和使用容器<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h4>
<p>启动容器，并分别映射22和1521端口到本地的49160和49161端口：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p <span class="m">49160</span>:22 -p <span class="m">49161</span>:1521 wnameless/oracle-xe-11g
</pre></div>
</div>
<p>使用下列参数可以连接oracle数据库：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>hostname: localhost
port: <span class="m">49161</span>
sid: xe
username: system
password: oracle
Password <span class="k">for</span> SYS
</pre></div>
</div>
<p>使用SSH登录容器，默认的用户名为root，密码为admin：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ssh root@localhost -p <span class="m">49160</span>
password: admin
</pre></div>
</div>
</section>
<section id="id34">
<span id="id35"></span><h4>3.相关资源<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h4>
<p>Oracle的相关资源如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·Oracle XE官网：http://www.oracle.com/technetwork/database/database-technologies/express-edition/overview/index.html

·Oracle XE官方镜像：https://github.com/wnameless/docker-oracle-xe-11g
</pre></div>
</div>
</section>
</section>
<section id="mongodb">
<h3><a class="toc-backref" href="#id136">4.3 MongoDB</a><a class="headerlink" href="#mongodb" title="Permalink to this headline">¶</a></h3>
<p>MongoDB是一款可扩展、高性能的开源文档数据库（Document-Oriented），是当今最流行的NoSQL数据库之一。它采用C++开发，支持复杂的数据类型和强大的查询语言，提供了关系数据库的绝大部分功能。由于其高性能、易部署、易使用等特点，MongoDB已经在很多领域都得到了广泛的应用。</p>
<p><img alt="image26" src="../_images/docker_mongo0001.png" /></p>
<section id="id36">
<span id="id37"></span><h4>1.使用官方镜像<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h4>
<p>用户可以使用docker[container]run指令直接运行官方mongoDB镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name mongo-container -d mongo
ade2b5036f457a6a2e7574fd68cf7a3298936f27280833769e93392015512735
</pre></div>
</div>
<p>之后，可以通过docker ps指令查看正在运行的mongo-container的容器ID：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker ps
CONTAINER ID IMAGE COMMAND                CREATED     STATUS      PORTS     NAMES
ade2b5036f45 mongo <span class="s2">&quot;/entrypoint.sh mongo&quot;</span> <span class="m">1</span> hours ago Up <span class="m">22</span> hours <span class="m">27017</span>/tcp mongo-container
</pre></div>
</div>
<p>在此，mongo-contariner启动一个bash进程，并通过mongo指令启动mongodbDB交互命令行，再通过db.stats()指令查看数据库状态：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker <span class="nb">exec</span> -it ade2b5036f45 sh
<span class="c1"># mongo</span>
MongoDB shell version: <span class="m">3</span>.2.6
connecting to: <span class="nb">test</span>
Server has startup warnings:
I CONTROL  <span class="o">[</span>initandlisten<span class="o">]</span>
I CONTROL  <span class="o">[</span>initandlisten<span class="o">]</span> ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is <span class="s1">&#39;always&#39;</span>.
I CONTROL  <span class="o">[</span>initandlisten<span class="o">]</span> **        We suggest setting it to <span class="s1">&#39;never&#39;</span>
I CONTROL  <span class="o">[</span>initandlisten<span class="o">]</span>
I CONTROL  <span class="o">[</span>initandlisten<span class="o">]</span> ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is <span class="s1">&#39;always&#39;</span>.
I CONTROL  <span class="o">[</span>initandlisten<span class="o">]</span> **        We suggest setting it to <span class="s1">&#39;never&#39;</span>
I CONTROL  <span class="o">[</span>initandlisten<span class="o">]</span>
&gt; show dbs
<span class="nb">local</span>  <span class="m">0</span>.000GB
&gt; db.stats<span class="o">()</span>
<span class="o">{</span>
    <span class="s2">&quot;db&quot;</span> : <span class="s2">&quot;test&quot;</span>,
    <span class="s2">&quot;collections&quot;</span> : <span class="m">1</span>,
    <span class="s2">&quot;objects&quot;</span> : <span class="m">1</span>,
    <span class="s2">&quot;avgObjSize&quot;</span> : <span class="m">39</span>,
    <span class="s2">&quot;dataSize&quot;</span> : <span class="m">39</span>,
    <span class="s2">&quot;storageSize&quot;</span> : <span class="m">16384</span>,
    <span class="s2">&quot;numExtents&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;indexes&quot;</span> : <span class="m">1</span>,
    <span class="s2">&quot;indexSize&quot;</span> : <span class="m">16384</span>,
    <span class="s2">&quot;ok&quot;</span> : <span class="m">1</span>
<span class="o">}</span>
</pre></div>
</div>
<p>这里可以通过env指令查看环境变量的配置：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@e4e9120bb00e</span><span class="p">:</span><span class="o">/</span><span class="c1"># env</span>
<span class="n">PWD</span><span class="o">=/</span>
<span class="n">HOME</span><span class="o">=/</span><span class="n">root</span>
<span class="n">GOSU_VERSION</span><span class="o">=</span><span class="mf">1.12</span>
<span class="n">MONGO_VERSION</span><span class="o">=</span><span class="mf">4.2.6</span>
<span class="n">MONGO_REPO</span><span class="o">=</span><span class="n">repo</span><span class="o">.</span><span class="n">mongodb</span><span class="o">.</span><span class="n">org</span>
<span class="n">TERM</span><span class="o">=</span><span class="n">xterm</span>
<span class="n">MONGO_PACKAGE</span><span class="o">=</span><span class="n">mongodb</span><span class="o">-</span><span class="n">org</span>
<span class="n">SHLVL</span><span class="o">=</span><span class="mi">1</span>
<span class="n">MONGO_MAJOR</span><span class="o">=</span><span class="mf">4.2</span>
<span class="n">JSYAML_VERSION</span><span class="o">=</span><span class="mf">3.13.1</span>
<span class="n">PATH</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">sbin</span><span class="p">:</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="nb">bin</span><span class="p">:</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="p">:</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="nb">bin</span><span class="p">:</span><span class="o">/</span><span class="n">sbin</span><span class="p">:</span><span class="o">/</span><span class="nb">bin</span>
<span class="n">_</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">env</span>
</pre></div>
</div>
<p>镜像默认暴露了mongoDB的服务端口:27017，可以通过该端口访问服务。</p>
</section>
<section id="id38">
<h4>（1）连接mongoDB容器<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h4>
<p>使用–link参数，连接新建的mongo-container容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --link mongo-container:db alpine sh
/ <span class="c1"># ls</span>
</pre></div>
</div>
<p>进入alpine系统容器后，可以使用ping指令测试mongo-container容器的连通性：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>/ <span class="c1"># ping db</span>
PING db <span class="o">(</span><span class="m">172</span>.17.0.5<span class="o">)</span>: <span class="m">56</span> data bytes
<span class="m">64</span> bytes from <span class="m">172</span>.17.0.5: <span class="nv">seq</span><span class="o">=</span><span class="m">0</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span><span class="m">0</span>.093 ms
<span class="m">64</span> bytes from <span class="m">172</span>.17.0.5: <span class="nv">seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span><span class="m">0</span>.104 ms
^C
--- db ping statistics ---
<span class="m">2</span> packets transmitted, <span class="m">2</span> packets received, <span class="m">0</span>% packet loss
round-trip min/avg/max <span class="o">=</span> <span class="m">0</span>.093/0.098/0.104 ms
</pre></div>
</div>
</section>
<section id="mongo-cli">
<h4>（2）直接使用mongo cli指令<a class="headerlink" href="#mongo-cli" title="Permalink to this headline">¶</a></h4>
<p>如果用户想直接在宿主机器上使用mongoDB，可以在docker[container]run指令后面加入entrypoint指令，这样就可以非常方便地直接进入mongo
cli了：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --link mongo-container:db --entrypoint mongo mongo --host db
MongoDB shell version: <span class="m">3</span>.2.6
connecting to: db:27017/test
Welcome to the MongoDB shell.
For interactive help, <span class="nb">type</span> <span class="s2">&quot;help&quot;</span>.
For more comprehensive documentation, see
    http://docs.mongodb.org/
Questions? Try the support group
    http://groups.google.com/group/mongodb-user
......
&gt; db.version<span class="o">()</span><span class="p">;</span>
<span class="m">3</span>.2.6
&gt;  db.stats<span class="o">()</span><span class="p">;</span>
<span class="o">{</span>
    <span class="s2">&quot;db&quot;</span> : <span class="s2">&quot;test&quot;</span>,
    <span class="s2">&quot;collections&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;objects&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;avgObjSize&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;dataSize&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;storageSize&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;numExtents&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;indexes&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;indexSize&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;fileSize&quot;</span> : <span class="m">0</span>,
    <span class="s2">&quot;ok&quot;</span> : <span class="m">1</span>
<span class="o">}</span>
&gt; show dbs
<span class="nb">local</span>  <span class="m">0</span>.000GB
</pre></div>
</div>
<p>最后，用户还可以使用–storageEngine参数来设置储存引擎：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name mongo-container -d mongo --storageEngine wiredTiger
</pre></div>
</div>
</section>
<section id="id39">
<h4>2.使用自定义Dockerfile<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<p>第一步，准备工作。新建项目目录，并在根目录新建Dockerfile，内容如下：</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="c"># 设置从用户之前创建的sshd镜像继承</span>
<span class="k">FROM</span> <span class="s">sshd</span>
<span class="k">MAINTAINER</span><span class="s"> docker_user (user@docker.com)</span>
<span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> <span class="se">\</span>
    apt-get install -y mongodb pwgen <span class="o">&amp;&amp;</span> <span class="se">\</span>
    apt-get clean <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -rf /var/lib/apt/lists/*
<span class="c"># 创建mongoDB存放数据文件的文件夹</span>
<span class="k">RUN</span> mkdir -p /data/db
<span class="k">VOLUME</span><span class="s"> /data/db</span>
<span class="k">ENV</span> AUTH yes
<span class="c"># 添加脚本</span>
<span class="k">ADD</span> run.sh /run.sh
<span class="k">ADD</span> set_mongodb_password.sh /set_mongodb_password.sh
<span class="k">RUN</span> chmod <span class="m">755</span> ./*.sh
<span class="k">EXPOSE</span><span class="s"> 27017</span>
<span class="k">EXPOSE</span><span class="s"> 28017</span>
<span class="k">CMD</span> <span class="p">[</span><span class="s2">&quot;/run.sh&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>新建set_mongodb_password.sh脚本，此脚本主要负责配置数据库的用户名和密码：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1"># 这个脚本主要是用来设置数据库的用户名和密码</span>
<span class="c1"># 判断是否已经设置过密码</span>
<span class="k">if</span> <span class="o">[</span> -f /.mongodb_password_set <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        <span class="nb">echo</span> <span class="s2">&quot;MongoDB password already set!&quot;</span>
        <span class="nb">exit</span> <span class="m">0</span>
<span class="k">fi</span>
/usr/bin/mongod --smallfiles --nojournal <span class="p">&amp;</span>
<span class="nv">PASS</span><span class="o">=</span><span class="si">${</span><span class="nv">MONGODB_PASS</span><span class="k">:-$(</span>pwgen -s <span class="m">12</span> <span class="m">1</span><span class="k">)</span><span class="si">}</span>
<span class="nv">_word</span><span class="o">=</span><span class="k">$(</span> <span class="o">[</span> <span class="si">${</span><span class="nv">MONGODB_PASS</span><span class="si">}</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;preset&quot;</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">&quot;random&quot;</span> <span class="k">)</span>
<span class="nv">RET</span><span class="o">=</span><span class="m">1</span>
<span class="k">while</span> <span class="o">[[</span> RET -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">do</span>
    <span class="nb">echo</span> <span class="s2">&quot;=&gt; Waiting for confirmation of MongoDB service startup&quot;</span>
    sleep <span class="m">5</span>
    mongo admin --eval <span class="s2">&quot;help&quot;</span> &gt;/dev/null <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
    <span class="nv">RET</span><span class="o">=</span><span class="nv">$?</span>
<span class="k">done</span>
<span class="c1"># 通过docker logs + id可以看到下面的输出</span>
<span class="nb">echo</span> <span class="s2">&quot;=&gt; Creating an admin user with a </span><span class="si">${</span><span class="nv">_word</span><span class="si">}</span><span class="s2"> password in MongoDB&quot;</span>
mongo admin --eval <span class="s2">&quot;db.addUser({user: &#39;admin&#39;, pwd: &#39;</span><span class="nv">$PASS</span><span class="s2">&#39;, roles: [ &#39;userAdminAnyDatabase&#39;, &#39;dbAdminAnyDatabase&#39; ]});&quot;</span>
mongo admin --eval <span class="s2">&quot;db.shutdownServer();&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;=&gt; Done!&quot;</span>
touch /.mongodb_password_set
<span class="nb">echo</span> <span class="s2">&quot;========================================================================&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;You can now connect to this MongoDB server using:&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;    mongo admin -u admin -p </span><span class="nv">$PASS</span><span class="s2"> --host &lt;host&gt; --port &lt;port&gt;&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;Please remember to change the above password as soon as possible!&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;========================================================================&quot;</span>
</pre></div>
</div>
<p>新建run.sh，此脚本是主要的mongoDB启动脚本：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="k">if</span> <span class="o">[</span> ! -f /.mongodb_password_set <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        /set_mongodb_password.sh
<span class="k">fi</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$AUTH</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;yes&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
<span class="c1"># 这里读者可以自己设定 MongoDB 的启动参数</span>
    <span class="nb">export</span> <span class="nv">mongodb</span><span class="o">=</span><span class="s1">&#39;/usr/bin/mongod --nojournal --auth --httpinterface --rest&#39;</span>
<span class="k">else</span>
    <span class="nb">export</span> <span class="nv">mongodb</span><span class="o">=</span><span class="s1">&#39;/usr/bin/mongod --nojournal --httpinterface --rest&#39;</span>
<span class="k">fi</span>
<span class="k">if</span> <span class="o">[</span> ! -f /data/db/mongod.lock <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">eval</span> <span class="nv">$mongodb</span>
<span class="k">else</span>
    <span class="nb">export</span> <span class="nv">mongodb</span><span class="o">=</span><span class="nv">$mongodb</span><span class="s1">&#39; --dbpath /data/db&#39;</span>
    rm /data/db/mongod.lock
    mongod --dbpath /data/db --repair <span class="o">&amp;&amp;</span> <span class="nb">eval</span> <span class="nv">$mongodb</span>
<span class="k">fi</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">chmod</span> <span class="mi">755</span> <span class="n">set_mongodb_password</span><span class="o">.</span><span class="n">sh</span> <span class="n">run</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
<p>第二步，使用docker build指令构建镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build  -t mongodb-image .
<span class="nv">$docker</span> images
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
mongodb-image             latest              67b174371e57        <span class="m">13</span> minutes ago      287MB
</pre></div>
</div>
<p>第三步，启动后台容器，并分别映射27017和28017端口到本地：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p <span class="m">27017</span>:27017 -p <span class="m">28017</span>:28017 mongodb-image
</pre></div>
</div>
<p>通过docker logs来查看默认的admin账户密码：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker logs <span class="nv">sa9</span>
    <span class="o">========================================================================</span>
        You can now connect to this MongoDB server using:
            mongo admin -u admin -p 5elsT6KtjrqV --host &lt;host&gt; --port &lt;port&gt;
        Please remember to change the above password as soon as possible!
    <span class="o">========================================================================</span>
</pre></div>
</div>
<p>屏幕输出中的5elsT6KtjrqV就是admin用户的密码。</p>
<p>也可以利用环境变量在容器启动时指定密码：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$  docker run -d -p <span class="m">27017</span>:27017 -p <span class="m">28017</span>:28017 -e <span class="nv">MONGODB_PASS</span><span class="o">=</span><span class="s2">&quot;mypass&quot;</span> mongodb
</pre></div>
</div>
<p>甚至，设定不需要密码即可访问：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$  docker run -d -p <span class="m">27017</span>:27017 -p <span class="m">28017</span>:28017 -e <span class="nv">AUTH</span><span class="o">=</span>no mongodb
</pre></div>
</div>
<p>同样，读者也可以使用-v参数来映射本地目录到容器。</p>
<p>mongoDB的启动参数有很多，包括：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span><span class="n">quiet</span>                <span class="c1"># 安静输出</span>
<span class="o">--</span><span class="n">port</span> <span class="n">arg</span>             <span class="c1"># 指定服务端口号，默认端口27017</span>
<span class="o">--</span><span class="n">bind_ip</span> <span class="n">arg</span>          <span class="c1"># 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP</span>
<span class="o">--</span><span class="n">logpath</span> <span class="n">arg</span>          <span class="c1"># 指定MongoDB日志文件，注意是指定文件不是目录</span>
<span class="o">--</span><span class="n">logappend</span>            <span class="c1"># 使用追加的方式写日志</span>
<span class="o">--</span><span class="n">pidfilepath</span> <span class="n">arg</span>       <span class="c1"># PID File 的完整路径，如果没有设置，则没有 PID文件</span>
<span class="o">--</span><span class="n">keyFile</span> <span class="n">arg</span>          <span class="c1"># 集群的私钥的完整路径，只对于Replica Set架构有效</span>
<span class="o">--</span><span class="n">unixSocketPrefix</span> <span class="n">arg</span> <span class="c1"># UNIX域套接字替代目录(默认为 /tmp)</span>
<span class="o">--</span><span class="n">fork</span>                 <span class="c1"># 以守护进程的方式运行MongoDB，创建服务器进程</span>
<span class="o">--</span><span class="n">auth</span>                 <span class="c1"># 启用验证</span>
<span class="o">--</span><span class="n">cpu</span>                  <span class="c1"># 定期显示CPU的利用率和iowait</span>
<span class="o">--</span><span class="n">dbpath</span> <span class="n">arg</span>           <span class="c1"># 指定数据库路径</span>
<span class="o">--</span><span class="n">diaglog</span> <span class="n">arg</span>          <span class="c1"># diaglog选项：0=off,1=W,2=R,3=both,7=W+some reads</span>
<span class="o">--</span><span class="n">directoryperdb</span>       <span class="c1"># 设置每个数据库将被保存在一个单独的目录</span>
<span class="o">--</span><span class="n">journal</span>              <span class="c1"># 启用日志选项，MongoDB的数据操作将会写入到journal文件夹的文件里</span>
<span class="o">--</span><span class="n">journalOptions</span> <span class="n">arg</span>   <span class="c1"># 启用日志诊断选项</span>
<span class="o">--</span><span class="n">ipv6</span>                 <span class="c1"># 启用IPv6选项</span>
<span class="o">--</span><span class="n">jsonp</span>                <span class="c1"># 允许JSONP形式通过HTTP访问（有安全影响）</span>
<span class="o">--</span><span class="n">maxConns</span> <span class="n">arg</span>         <span class="c1"># 最大同时连接数，默认2000</span>
<span class="o">--</span><span class="n">noauth</span>               <span class="c1"># 不启用验证</span>
<span class="o">--</span><span class="n">nohttpinterface</span>      <span class="c1"># 关闭HTTP接口，默认关闭27018端口访问</span>
<span class="o">--</span><span class="n">noprealloc</span>           <span class="c1"># 禁用数据文件预分配(往往影响性能)</span>
<span class="o">--</span><span class="n">noscripting</span>          <span class="c1"># 禁用脚本引擎</span>
<span class="o">--</span><span class="n">notablescan</span>          <span class="c1"># 不允许表扫描</span>
<span class="o">--</span><span class="n">nounixsocket</span>         <span class="c1"># 禁用Unix套接字监听</span>
<span class="o">--</span><span class="n">nssize</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>     <span class="c1"># 设置信数据库.ns文件大小(MB)</span>
<span class="o">--</span><span class="n">objcheck</span>             <span class="c1"># 在收到客户数据，检查有效性</span>
<span class="o">--</span><span class="n">profile</span> <span class="n">arg</span>          <span class="c1"># 档案参数：0=off, 1=slow, 2=all</span>
<span class="o">--</span><span class="n">quota</span>                <span class="c1"># 限制每个数据库的文件数，设置默认为8</span>
<span class="o">--</span><span class="n">quotaFiles</span> <span class="n">arg</span>       <span class="c1"># 限制单个数据库允许的文件</span>
<span class="o">--</span><span class="n">rest</span>                 <span class="c1"># 开启简单的 Rest API</span>
<span class="o">--</span><span class="n">repair</span>               <span class="c1"># 修复所有数据库，如run repair on all dbs</span>
<span class="o">--</span><span class="n">repairpath</span> <span class="n">arg</span>       <span class="c1"># 修复生成的文件目录,默认为目录名称dbpath</span>
<span class="o">--</span><span class="n">slowms</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>    <span class="c1"># profile和日志输出延迟</span>
<span class="o">--</span><span class="n">smallfiles</span>            <span class="c1"># 使用较小的默认文件</span>
<span class="o">--</span><span class="n">syncdelay</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>  <span class="c1"># 数据写入磁盘的时间秒数(0=never,不推荐)</span>
<span class="o">--</span><span class="n">sysinfo</span>              <span class="c1"># 打印一些诊断系统信息</span>
<span class="o">--</span><span class="n">upgrade</span>              <span class="c1"># 升级数据库，* Replicaton 参数</span>
<span class="o">--------------------------------------------------------------------------------</span>
<span class="o">--</span><span class="n">fastsync</span> <span class="c1"># 从一个dbpath里启用从库复制服务，该dbpath的数据库是主库的快照，可用于快速启用同步</span>
<span class="o">--</span><span class="n">autoresync</span>       <span class="c1"># 如果从库与主库同步数据差得多，自动重新同步</span>
<span class="o">--</span><span class="n">oplogSize</span> <span class="n">arg</span>   <span class="c1"># 设置oplog 的大小(MB), * 主/从参数</span>
<span class="o">--------------------------------------------------------------------------------</span>
<span class="o">--</span><span class="n">master</span>          <span class="c1"># 主库模式</span>
<span class="o">--</span><span class="n">slave</span>           <span class="c1"># 从库模式</span>
<span class="o">--</span><span class="n">source</span> <span class="n">arg</span>      <span class="c1"># 从库端口号</span>
<span class="o">--</span><span class="n">only</span> <span class="n">arg</span>        <span class="c1"># 指定单一的数据库复制</span>
<span class="o">--</span><span class="n">slavedelay</span> <span class="n">arg</span>  <span class="c1"># 设置从库同步主库的延迟时间, * Replica set（副本集）选项</span>
<span class="o">--------------------------------------------------------------------------------</span>
<span class="o">--</span><span class="n">replSet</span> <span class="n">arg</span>     <span class="c1"># 设置副本集名称,  * Sharding(分片)选项</span>
<span class="o">--------------------------------------------------------------------------------</span>
<span class="o">--</span><span class="n">configsvr</span>       <span class="c1"># 声明这是一个集群的config服务,默认端口27019，默认目录/data/configdb</span>
<span class="o">--</span><span class="n">shardsvr</span>        <span class="c1"># 声明这是一个集群的分片,默认端口27018</span>
<span class="o">--</span><span class="n">noMoveParanoia</span>  <span class="c1"># 关闭偏执为moveChunk数据保存</span>
</pre></div>
</div>
<p>上述参数也可以直接在mongod.conf配置文件中配置，例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dbpath</span> <span class="o">=</span> <span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">mongodb</span>
<span class="n">logpath</span> <span class="o">=</span> <span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">mongodb</span><span class="o">/</span><span class="n">mongodb</span><span class="o">.</span><span class="n">log</span>
<span class="n">logappend</span> <span class="o">=</span> <span class="n">true</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">27017</span>
<span class="n">fork</span> <span class="o">=</span> <span class="n">true</span>
<span class="n">auth</span> <span class="o">=</span> <span class="n">true</span>
</pre></div>
</div>
</section>
<section id="id40">
<span id="id41"></span><h4>3.相关资源<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<p>MongoDB相关资源如下：</p>
<ul class="simple">
<li><p>MongoDB官网：<a class="reference external" href="https://www.mongodb.org">https://www.mongodb.org</a></p></li>
<li><p>MongoDB官方镜像：<a class="reference external" href="https://hub.docker.com/_/mongo/">https://hub.docker.com/_/mongo/</a></p></li>
<li><p>MongoDB官方镜像实现：<a class="reference external" href="https://github.com/docker-library/mongo">https://github.com/docker-library/mongo</a></p></li>
</ul>
</section>
</section>
<section id="redis">
<h3><a class="toc-backref" href="#id137">4.4 Redis</a><a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h3>
<p>Redis是一个开源（BSD许可）的基于内存的数据结构存储系统，可以用作数据库、缓存和消息中间件。Redis使用ANSI
C实现，2013年起由Pivotal公司资助。Redis的全称意为：REmote DIctionary
Server。</p>
<p>Redis支持多种类型的数据结构，如string（字符串）、hash（散列）、list（列表）、set（集合）、sorted
set（有序集合）与范围查询、bitmaps、hyperloglogs和geospatial索引半径查询，Redis同时支持replication、LUA脚本、LRU驱动事件、事务和不同级别的持久化支持等，通过哨兵机制和集群机制提供高可用性。</p>
<p><img alt="image27" src="../_images/docker_redis00001.png" /></p>
<section id="id42">
<span id="id43"></span><h4>1.使用官方镜像<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h4>
<p>用户可以通过docker[container]run指令直接启动一个redis-container容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name redis-container -d redis
6f7d16f298e9c505f35ae28b61b4015877a5b0b75c60797fa4583429e4a14e24
</pre></div>
</div>
<p>之后可以通过docker ps指令查看正在运行的redis-container容器的容器ID：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@desktop-pmjtngi mongodb<span class="o">]</span><span class="c1"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
4a910eb38557        redis               <span class="s2">&quot;docker-entrypoint.s…&quot;</span>   <span class="m">9</span> seconds ago       Up <span class="m">7</span> seconds        <span class="m">6379</span>/tcp            redis-container
</pre></div>
</div>
<p>下面，在此redis容器启动bash，并查看容器的运行时间和内存状况：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker <span class="nb">exec</span> -it 4a910e /bin/bash
root@3010492a16cd:/# uptime
 <span class="m">08</span>:29:53 up  <span class="m">5</span>:16,  <span class="m">0</span> users,  load average: <span class="m">0</span>.03, <span class="m">0</span>.11, <span class="m">0</span>.09
root@3010492a16cd:/# free
              total        used        free      shared  buff/cache   available
Mem:         <span class="m">995732</span>      <span class="m">275488</span>      <span class="m">230920</span>        <span class="m">2692</span>      <span class="m">489324</span>      <span class="m">568320</span>
Swap:       <span class="m">2097148</span>       <span class="m">52992</span>     <span class="m">2044156</span>
</pre></div>
</div>
<p>同样，可以通过env指令查看环境变量的配置：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>root@4a910eb38557:/data# env
<span class="nv">HOSTNAME</span><span class="o">=</span>4a910eb38557
<span class="nv">REDIS_DOWNLOAD_SHA</span><span class="o">=</span>53d0ae164cd33536c3d4b720ae9a128ea6166ebf04ff1add3b85f1242090cb85
<span class="nv">PWD</span><span class="o">=</span>/data
<span class="nv">HOME</span><span class="o">=</span>/root
<span class="nv">REDIS_VERSION</span><span class="o">=</span><span class="m">5</span>.0.9
<span class="nv">GOSU_VERSION</span><span class="o">=</span><span class="m">1</span>.12
<span class="nv">TERM</span><span class="o">=</span>xterm
<span class="nv">REDIS_DOWNLOAD_URL</span><span class="o">=</span>http://download.redis.io/releases/redis-5.0.9.tar.gz
<span class="nv">SHLVL</span><span class="o">=</span><span class="m">1</span>
<span class="nv">PATH</span><span class="o">=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span class="nv">_</span><span class="o">=</span>/usr/bin/env
</pre></div>
</div>
<p>用户也可以通过ps指令查看当前容器运行的进程信息：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>root@6f7d16f298e9:/data# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
redis        <span class="m">1</span>     <span class="m">0</span>  <span class="m">0</span> <span class="m">12</span>:16 ?        <span class="m">00</span>:00:02 redis-server *:6379
root        <span class="m">30</span>     <span class="m">0</span>  <span class="m">0</span> <span class="m">12</span>:51 ?        <span class="m">00</span>:00:00 sh
root        <span class="m">39</span>    <span class="m">30</span>  <span class="m">0</span> <span class="m">12</span>:52 ?        <span class="m">00</span>:00:00 ps -ef
</pre></div>
</div>
</section>
<section id="id44">
<h4>（1）连接Redis容器<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h4>
<p>用户可以使用–link参数，连接创建的redis-container容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@desktop-pmjtngi mongodb<span class="o">]</span><span class="c1"># docker run -it --link redis-container:db alpine sh</span>
/ <span class="c1"># ls</span>
bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var
/ <span class="c1"># ping db</span>
PING db <span class="o">(</span><span class="m">172</span>.17.0.2<span class="o">)</span>: <span class="m">56</span> data bytes
<span class="m">64</span> bytes from <span class="m">172</span>.17.0.2: <span class="nv">seq</span><span class="o">=</span><span class="m">0</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span><span class="m">0</span>.288 ms
<span class="m">64</span> bytes from <span class="m">172</span>.17.0.2: <span class="nv">seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span><span class="m">0</span>.075 ms
<span class="m">64</span> bytes from <span class="m">172</span>.17.0.2: <span class="nv">seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span><span class="m">0</span>.085 ms
</pre></div>
</div>
<p>还可以使用nc指令（即NetCat）检测Redis服务的可用性：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span> <span class="c1"># nc db 6379</span>
<span class="n">PING</span>
<span class="o">+</span><span class="n">PONG</span>
</pre></div>
</div>
<p>官方镜像内也自带了Redis客户端，可以使用以下指令直接使用：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@desktop-pmjtngi mongodb<span class="o">]</span><span class="c1"># docker run -it --link redis-container:db --entrypoint redis-cli redis -h db</span>
db:6379&gt; ping
PONG
db:6379&gt; <span class="nb">set</span> <span class="m">1</span> <span class="m">2</span>
OK
db:6379&gt; get <span class="m">1</span>
<span class="s2">&quot;2&quot;</span>
</pre></div>
</div>
</section>
<section id="id45">
<h4>（2）使用自定义配置<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h4>
<p>如果需要使用自定义的Redis配置，有以下两种操作：</p>
<p>·通过Dockerfile构建自定义镜像；</p>
<p>·使用数据卷。</p>
<p>下面首先介绍第一种方式。首先，新建项目目录并新建Dockerfile文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">redis</span>
<span class="n">RUN</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">redis</span> <span class="o">&amp;&amp;</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">redis</span> <span class="o">&amp;&amp;</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">redis</span> <span class="o">&amp;&amp;</span> <span class="n">chmod</span> <span class="mi">777</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">redis</span> <span class="o">&amp;&amp;</span> <span class="n">chown</span> <span class="o">-</span><span class="n">R</span> <span class="mi">999</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">redis</span> <span class="o">&amp;&amp;</span> <span class="n">chmod</span> <span class="mi">777</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">redis</span> <span class="o">&amp;&amp;</span> <span class="n">chown</span> <span class="o">-</span><span class="n">R999</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">redis</span>
<span class="n">COPY</span> <span class="n">redis</span><span class="o">.</span><span class="n">conf</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">redis</span><span class="o">/</span><span class="n">redis</span><span class="o">.</span><span class="n">conf</span>
<span class="n">CMD</span> <span class="p">[</span> <span class="s2">&quot;redis-server&quot;</span><span class="p">,</span> <span class="s2">&quot;/usr/local/etc/redis/redis.conf&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">redis.conf</span></code>配置文件内容如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="o">@</span><span class="mi">3010492</span><span class="n">a16cd</span><span class="p">:</span><span class="o">/</span><span class="c1"># cat /etc/redis/redis.conf | grep -v &quot;^#&quot;|sed &#39;/^$/d&#39;</span>
<span class="n">protected</span><span class="o">-</span><span class="n">mode</span> <span class="n">no</span>
<span class="n">port</span> <span class="mi">6379</span>
<span class="n">tcp</span><span class="o">-</span><span class="n">backlog</span> <span class="mi">511</span>
<span class="n">unixsocket</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">redis</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="n">server</span><span class="o">.</span><span class="n">sock</span>
<span class="n">unixsocketperm</span> <span class="mi">777</span>
<span class="n">timeout</span> <span class="mi">0</span>
<span class="n">tcp</span><span class="o">-</span><span class="n">keepalive</span> <span class="mi">300</span>
<span class="n">daemonize</span> <span class="n">no</span>
<span class="n">supervised</span> <span class="n">no</span>
<span class="n">pidfile</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">redis</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="n">server</span><span class="o">.</span><span class="n">pid</span>
<span class="n">loglevel</span> <span class="n">notice</span>
<span class="n">databases</span> <span class="mi">16</span>
<span class="n">always</span><span class="o">-</span><span class="n">show</span><span class="o">-</span><span class="n">logo</span> <span class="n">yes</span>
<span class="n">save</span> <span class="mi">900</span> <span class="mi">1</span>
<span class="n">save</span> <span class="mi">300</span> <span class="mi">10</span>
<span class="n">save</span> <span class="mi">60</span> <span class="mi">10000</span>
<span class="n">stop</span><span class="o">-</span><span class="n">writes</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">bgsave</span><span class="o">-</span><span class="n">error</span> <span class="n">yes</span>
<span class="n">rdbcompression</span> <span class="n">yes</span>
<span class="n">rdbchecksum</span> <span class="n">yes</span>
<span class="n">dbfilename</span> <span class="n">dump</span><span class="o">.</span><span class="n">rdb</span>
<span class="nb">dir</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">redis</span>
<span class="n">slave</span><span class="o">-</span><span class="n">serve</span><span class="o">-</span><span class="n">stale</span><span class="o">-</span><span class="n">data</span> <span class="n">yes</span>
<span class="n">slave</span><span class="o">-</span><span class="n">read</span><span class="o">-</span><span class="n">only</span> <span class="n">yes</span>
<span class="n">repl</span><span class="o">-</span><span class="n">diskless</span><span class="o">-</span><span class="n">sync</span> <span class="n">no</span>
<span class="n">repl</span><span class="o">-</span><span class="n">diskless</span><span class="o">-</span><span class="n">sync</span><span class="o">-</span><span class="n">delay</span> <span class="mi">5</span>
<span class="n">repl</span><span class="o">-</span><span class="n">disable</span><span class="o">-</span><span class="n">tcp</span><span class="o">-</span><span class="n">nodelay</span> <span class="n">no</span>
<span class="n">slave</span><span class="o">-</span><span class="n">priority</span> <span class="mi">100</span>
<span class="n">lazyfree</span><span class="o">-</span><span class="n">lazy</span><span class="o">-</span><span class="n">eviction</span> <span class="n">no</span>
<span class="n">lazyfree</span><span class="o">-</span><span class="n">lazy</span><span class="o">-</span><span class="n">expire</span> <span class="n">no</span>
<span class="n">lazyfree</span><span class="o">-</span><span class="n">lazy</span><span class="o">-</span><span class="n">server</span><span class="o">-</span><span class="k">del</span> <span class="n">no</span>
<span class="n">slave</span><span class="o">-</span><span class="n">lazy</span><span class="o">-</span><span class="n">flush</span> <span class="n">no</span>
<span class="n">appendonly</span> <span class="n">no</span>
<span class="n">appendfilename</span> <span class="s2">&quot;appendonly.aof&quot;</span>
<span class="n">appendfsync</span> <span class="n">everysec</span>
<span class="n">no</span><span class="o">-</span><span class="n">appendfsync</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">rewrite</span> <span class="n">no</span>
<span class="n">auto</span><span class="o">-</span><span class="n">aof</span><span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="n">percentage</span> <span class="mi">100</span>
<span class="n">auto</span><span class="o">-</span><span class="n">aof</span><span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="nb">min</span><span class="o">-</span><span class="n">size</span> <span class="mi">64</span><span class="n">mb</span>
<span class="n">aof</span><span class="o">-</span><span class="n">load</span><span class="o">-</span><span class="n">truncated</span> <span class="n">yes</span>
<span class="n">aof</span><span class="o">-</span><span class="n">use</span><span class="o">-</span><span class="n">rdb</span><span class="o">-</span><span class="n">preamble</span> <span class="n">no</span>
<span class="n">lua</span><span class="o">-</span><span class="n">time</span><span class="o">-</span><span class="n">limit</span> <span class="mi">5000</span>
<span class="n">slowlog</span><span class="o">-</span><span class="n">log</span><span class="o">-</span><span class="n">slower</span><span class="o">-</span><span class="n">than</span> <span class="mi">10000</span>
<span class="n">slowlog</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="nb">len</span> <span class="mi">128</span>
<span class="n">latency</span><span class="o">-</span><span class="n">monitor</span><span class="o">-</span><span class="n">threshold</span> <span class="mi">0</span>
<span class="n">notify</span><span class="o">-</span><span class="n">keyspace</span><span class="o">-</span><span class="n">events</span> <span class="s2">&quot;&quot;</span>
<span class="nb">hash</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">entries</span> <span class="mi">512</span>
<span class="nb">hash</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">value</span> <span class="mi">64</span>
<span class="nb">list</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">size</span> <span class="o">-</span><span class="mi">2</span>
<span class="nb">list</span><span class="o">-</span><span class="n">compress</span><span class="o">-</span><span class="n">depth</span> <span class="mi">0</span>
<span class="nb">set</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">intset</span><span class="o">-</span><span class="n">entries</span> <span class="mi">512</span>
<span class="n">zset</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">entries</span> <span class="mi">128</span>
<span class="n">zset</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">ziplist</span><span class="o">-</span><span class="n">value</span> <span class="mi">64</span>
<span class="n">hll</span><span class="o">-</span><span class="n">sparse</span><span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="nb">bytes</span> <span class="mi">3000</span>
<span class="n">activerehashing</span> <span class="n">yes</span>
<span class="n">client</span><span class="o">-</span><span class="n">output</span><span class="o">-</span><span class="n">buffer</span><span class="o">-</span><span class="n">limit</span> <span class="n">normal</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="n">client</span><span class="o">-</span><span class="n">output</span><span class="o">-</span><span class="n">buffer</span><span class="o">-</span><span class="n">limit</span> <span class="n">slave</span> <span class="mi">256</span><span class="n">mb</span> <span class="mi">64</span><span class="n">mb</span> <span class="mi">60</span>
<span class="n">client</span><span class="o">-</span><span class="n">output</span><span class="o">-</span><span class="n">buffer</span><span class="o">-</span><span class="n">limit</span> <span class="n">pubsub</span> <span class="mi">32</span><span class="n">mb</span> <span class="mi">8</span><span class="n">mb</span> <span class="mi">60</span>
<span class="n">hz</span> <span class="mi">10</span>
<span class="n">aof</span><span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="n">incremental</span><span class="o">-</span><span class="n">fsync</span> <span class="n">yes</span>
</pre></div>
</div>
<p>然后可以使用docker build指令，构建使用自定义配置的Redis镜像。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t redis-con .
$ docker run --name redis-container -d redis-con
009dac31534c676070855219a7ab9b8d690ff9c1c792507af1b7489646e3e92f

$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
009dac31534c        redis-con           <span class="s2">&quot;docker-entrypoint.s…&quot;</span>   <span class="m">2</span> seconds ago       Up <span class="m">1</span> second         <span class="m">6379</span>/tcp            redis-container
</pre></div>
</div>
<p>如果使用第二种方式，即通过数据卷实现自定义Redis配置，可以通过以下指令完成：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf
</pre></div>
</div>
<p>参考文献
<a class="reference external" href="https://www.cnblogs.com/xiao987334176/p/11984713.html">docker封装redis镜像</a></p>
</section>
<section id="id46">
<span id="id47"></span><h4>2.相关资源<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h4>
<p>Redis的相关资源如下：</p>
<ul class="simple">
<li><p>Redis官方网站：<a class="reference external" href="http://redis.io/">http://redis.io/</a></p></li>
<li><p>Redis官方镜像：<a class="reference external" href="https://hub.docker.com/_/redis/">https://hub.docker.com/_/redis/</a></p></li>
<li><p>Redis官方镜像仓库：<a class="reference external" href="https://github.com/docker-library/redis">https://github.com/docker-library/redis</a></p></li>
</ul>
</section>
</section>
<section id="cassandra">
<h3><a class="toc-backref" href="#id138">4.5 Cassandra</a><a class="headerlink" href="#cassandra" title="Permalink to this headline">¶</a></h3>
<p>Apache Cassandra是个开源（Apache License
2.0）的分布式数据库，支持分布式高可用数据存储，可以提供跨数据中心的容错能力且无单点故障，
并通过异步无主复制实现所有客户端的低延迟操作。Cassandra在设计上引入了P2P技术，具备大规模可分区行存储能力，并支持Spark、Storm、Hadoop系统集成。
目前Facebook、Twitter、Instagram、eBay、Github、Reddit、Netflix等多家公司都在使用Cassandra。类似系统还有HBase等。</p>
<p><img alt="image28" src="../_images/docker_cassandra.png" /></p>
<section id="id48">
<span id="id49"></span><h4>1.使用官方镜像<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h4>
<p>首先可以使用docker run指令基于Cassandra官方镜像启动容器：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name my-cassandra -d cassandra:latest
1dde81cddc53322817f8c6e67022c501759d8d187a2de40f1a25710a5f2dfa53
</pre></div>
</div>
<p>这里的–name标签指定容器名称。cassandra：tag中的标签指定版本号，标签名称可以参考官方仓库的标签说明：<a class="reference external" href="https://hub.docker.com/r/library/cassandra/tags/">https://hub.docker.com/r/library/cassandra/tags/</a>
。</p>
<p>之后用户可以将另一个容器中的应用与Cassandra容器连接起来。此应用容器要暴露Cassandra需要使用的端口（Cassandra默认服务端口rpc_port：9160；CQL默认本地服务端口native_transport_port：9042），这样就可以通过容器link功能来连接Cassandra容器与应用容器。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name my-app --link my-cassandra:cassandra -d app-that-uses-cassandra
</pre></div>
</div>
</section>
<section id="id50">
<h4>2.搭建Cassandra集群<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h4>
<p>Cassandra有两种集群模式：</p>
<p>单机模式（所有实例集中于一台机器）和多机模式（实例分布于多台机器）。单机模式下，可以按照上文描述的方法启动容器即可，如果需要启动更多实例，则需要在指令中配置首个实例信息：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name my-cassandra2 -d -e <span class="nv">CASSANDRA_SEEDS</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>docker inspect --format<span class="o">=</span><span class="s1">&#39;{{ .NetworkSettings.IPAddress }}&#39;</span> my-cassandra<span class="k">)</span><span class="s2">&quot;</span> cassandra:latest
</pre></div>
</div>
<p>其中my-cassandra就是首个Cassandra
Server的实例名称。在这里使用了docker[container]inspect指令，以获取首个实例的IP地址信息。还可以使用docker
run的–link标签来连接这两个Cassandra实例：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name my-cassandra2 -d --link my-cassandra:cassandra cassandra:latest
</pre></div>
</div>
<p>多机模式下，由于容器网络基于Docker
bridge，所以需要通过环境变量，配置Cassandra
Server容器的IP广播地址（即使用-e标签）。假设第一台虚拟机的IP是10.22.22.22，第二台虚拟机的IP是10.23.23.23，Gossip端口是7000，那么启动第一台虚拟机中的Cassandra容器时的指令如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name my-cassandra -d -e <span class="nv">CASSANDRA_BROADCAST_ADDRESS</span><span class="o">=</span><span class="m">10</span>.42.42.42 -p <span class="m">7000</span>:7000 cassandra:latest
</pre></div>
</div>
<p>启动第二台虚拟机的Cassandra容器时，同样需要暴露Gossip端口，并通过环境变量声明第一台Cassandra容器的IP地址：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name my-cassandra -d -e <span class="nv">CASSANDRA_BROADCAST_ADDRESS</span><span class="o">=</span><span class="m">10</span>.43.43.43 -p <span class="m">7000</span>:7000 -e <span class="nv">CASSANDRA_SEEDS</span><span class="o">=</span><span class="m">10</span>.42.42.42 cassandra:latest
</pre></div>
</div>
</section>
<section id="cqlshcassandra">
<h4>3.使用cqlsh连接至Cassandra<a class="headerlink" href="#cqlshcassandra" title="Permalink to this headline">¶</a></h4>
<p>cqlsh是指Cassandra Query Language Shell。在Cassandra
1.x版后，除了cassandra-cli之外，官方在/cassandra_install_folder/bin里加入了cqlsh指令。该指令与cassandra-cli一样，是client端工具，它可联机至server端进行数据维护与查询。cqlsh支持CQL操作，可以方便地维护数据。</p>
<p>以下指令启动了一个Cassandra容器并运行cqlsh：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --link my-cassandra:cassandra --rm cassandra sh -c <span class="s1">&#39;exec cqlsh &quot;$CASSANDRA_PORT_9042_TCP_ADDR&quot;&#39;</span>
Connected to Test Cluster at <span class="m">172</span>.17.0.4:9042.
<span class="o">[</span>cqlsh <span class="m">5</span>.0.1 <span class="p">|</span> Cassandra <span class="m">3</span>.7 <span class="p">|</span> CQL spec <span class="m">3</span>.4.2 <span class="p">|</span> Native protocol v4<span class="o">]</span>
Use HELP <span class="k">for</span> help.
cqlsh&gt; CREATE KEYSPACE demodb WITH <span class="nv">REPLICATION</span> <span class="o">=</span> <span class="o">{</span> <span class="s1">&#39;class&#39;</span> : <span class="s1">&#39;SimpleStrategy&#39;</span>, <span class="s1">&#39;replication_factor&#39;</span> : <span class="m">1</span> <span class="o">}</span> AND <span class="nv">durable_writes</span> <span class="o">=</span> true<span class="p">;</span>
cqlsh&gt; USE demodb<span class="p">;</span>
cqlsh:demodb&gt; desc demodb<span class="p">;</span>
CREATE KEYSPACE demodb WITH <span class="nv">replication</span> <span class="o">=</span> <span class="o">{</span><span class="s1">&#39;class&#39;</span>: <span class="s1">&#39;SimpleStrategy&#39;</span>, <span class="s1">&#39;replication_factor&#39;</span>: <span class="s1">&#39;1&#39;</span><span class="o">}</span>  AND <span class="nv">durable_writes</span> <span class="o">=</span> true<span class="p">;</span>
</pre></div>
</div>
<p>或者如下方式，my-cassandra是我们的Cassandra Server容器的name：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --link my-cassandra:cassandra --rm cassandra cqlsh cassandra
</pre></div>
</div>
</section>
<section id="id51">
<h4>4.访问系统与日志<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h4>
<p>用户可以使用docker
exec指令直接访问Cassandra系统，以下指令会在Cassandra容器中开启bash
shell：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker exec -it my-cassandra bash
root@1dde81cddc53:/# ls -l /etc/cassandra/
total 100
-rw-r--r-- 1 cassandra cassandra 11636 Jul 28 22:10 cassandra-env.sh
-rw-r--r-- 1 cassandra cassandra  1200 Jun  6 18:50 cassandra-rackdc.properties
-rw-r--r-- 1 cassandra cassandra  1358 Jun  6 18:50 cassandra-topology.properties
-rw-r--r-- 1 cassandra cassandra 49826 Aug 30 04:35 cassandra.yaml
-rw-r--r-- 1 cassandra cassandra  2082 Jun  6 18:50 commitlog_archiving.properties
-rw-r--r-- 1 cassandra cassandra  9074 Jun  6 18:50 jvm.options
-rw-r--r-- 1 cassandra cassandra  1193 Jun  6 18:50 logback-tools.xml
-rw-r--r-- 1 cassandra cassandra  3785 Jun  6 18:50 logback.xml
drwxr-xr-x 2 cassandra cassandra  4096 Aug 30 04:35 triggers
</pre></div>
</div>
<p>使用docker logs指令访问日志：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker logs my-cassandra
ocker logs my-cassandra
INFO  04:35:36 Configuration location: file:/etc/cassandra/cassandra.yaml
...
INFO  04:35:37 DiskAccessMode &#39;auto&#39; determined to be mmap, indexAccessMode is mmap
INFO  04:35:37 Global memtable on-heap threshold is enabled at 245MB
INFO  04:35:37 Global memtable off-heap threshold is enabled at 245MB
WARN  04:35:37 Only 56.105GiB free across all data volumes. Consider adding more capacity to your cluster or removing obsolete snapshots
INFO  04:35:38 Hostname: 1dde81cddc53
INFO  04:35:38 JVM vendor/version: OpenJDK 64-Bit Server VM/1.8.0_91
INFO  04:35:38 HeapINFO  04:36:08 Starting listening for CQL clients on /0.0.0.0:9042 (unencrypted)...
INFO  04:36:08 Not starting RPC server as requested. Use JMX (StorageService-&gt;startRPCServer()) or nodetool (enablethrift) to start it
INFO  04:36:10 Scheduling approximate time-check task with a precision of 10 milliseconds
INFO  04:36:10 Created default superuser role &#39;cassandra&#39;
INFO  05:08:21 ConcurrentMarkSweep GC in 201ms.  CMS Old Gen: 32959928 -&gt; 11374920; Code Cache: 13636096 -&gt; 13633792; Metaspace: 38164344 -&gt; 38164408;
INFO  05:13:32 Create new Keyspace: KeyspaceMetadata{name=demodb, params=KeyspaceParams{durable_writes=true, replication=ReplicationParams{class=org.apache.cassandra.locator.SimpleStrategy, replication_factor=1}}, tables=[], views=[], functions=[], types=[]}size: 980.000MiB/980.000MiB
...
</pre></div>
</div>
</section>
<section id="id52">
<span id="id53"></span><h4>5.相关资源<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h4>
<p>Cassandra的相关资源如下：</p>
<ul class="simple">
<li><p>Cassandra官网：<a class="reference external" href="http://cassandra.apache.org/">http://cassandra.apache.org/</a></p></li>
<li><p>Cassandra官方文档：<a class="reference external" href="http://docs.datastax.com/">http://docs.datastax.com/</a></p></li>
<li><p>Cassandra官方仓库：<a class="reference external" href="https://github.com/apache/cassandra">https://github.com/apache/cassandra</a></p></li>
<li><p>Cassandra官方镜像：<a class="reference external" href="https://hub.docker.com/_/cassandra/">https://hub.docker.com/_/cassandra/</a></p></li>
<li><p>Cassandra官方镜像仓库：<a class="reference external" href="https://github.com/docker-library/cassandra">https://github.com/docker-library/cassandra</a></p></li>
</ul>
</section>
</section>
</section>
<section id="id54">
<h2><a class="toc-backref" href="#id139">5.分布式处理与大数据平台</a><a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h2>
<p>分布式系统和大数据处理平台是目前业界关注的热门技术。本章将重点介绍热门的大数据分布式处理的三大重量级武器：Hadoop、Spark、Storm，以及新一代的数据采集和分析引擎Elasticsearch。</p>
<section id="hadoop">
<h3><a class="toc-backref" href="#id140">5.1 Hadoop</a><a class="headerlink" href="#hadoop" title="Permalink to this headline">¶</a></h3>
<p>Hadoop是Apache软件基金会旗下的一个开源分布式计算平台。</p>
<p><img alt="image29" src="../_images/docker_hadoop001.png" /></p>
<p>作为当今大数据处理领域的经典分布式平台，Hadoop主要基于Java语言实现，由三个核心子系统组成：HDFS、YARN、MapReduce，其中，HDFS是一套分布式文件系统；YARN是资源管理系统，MapReduce是运行在YARN上的应用，负责分布式处理管理。如果从操作系统的角度看，HDFS相当于Linux的ext3/ext4文件系统，而Yarn相当于Linux的进程调度和内存分配模块。</p>
<p>Hadoop的核心子系统说明如下：</p>
<p>·HDFS：一个高度容错性的分布式文件系统，适合部署在大量廉价的机器上，提供高吞吐量的数据访问。</p>
<p>·YARN（Yet Another Resource
Negotiator）：资源管理器，可为上层应用提供统一的资源管理和调度，兼容多计算框架。</p>
<p>·MapReduce：是一种分布式编程模型，把对大规模数据集的处理分发（Map）给网络上的多个节点，之后收集处理结果进行规约（Reduce）。</p>
<p>Hadoop还包括HBase（列数据库）、Cassandra（分布式数据库）、Hive（支持SQL语句）、Pig（流处理引擎）、Zookeeper（分布式应用协调服务）等相关项目，其生态系统如图</p>
<p>Apache Hadoop生态系统 <img alt="image30" src="../_images/docker_hadoop0002.png" /></p>
<section id="id55">
<span id="id56"></span><h4>1.使用官方镜像<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h4>
<p>用户可以通过docker pull指令直接使用Hadoop 2.7.0镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker pull sequenceiq/hadoop-docker:2.7.0
<span class="m">2</span>.7.0: Pulling from sequenceiq/hadoop-docker
...
046b321f8081: Pull <span class="nb">complete</span>
Digest: sha256:a40761746eca036fee6aafdf9fdbd6878ac3dd9a7cd83c0f3f5d8a0e6350c76a
Status: Downloaded newer image <span class="k">for</span> sequenceiq/hadoop-docker:2.7.0
</pre></div>
</div>
<p>完成镜像拉取后，使用docker run指令运行镜像，同时打开bash命令行：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it sequenceiq/hadoop-docker:2.7.0 /etc/bootstrap.sh -bash
/
Starting sshd:                                             <span class="o">[</span>  OK  <span class="o">]</span>
Starting namenodes on <span class="o">[</span>d4e1e9d8f24f<span class="o">]</span>
d4e1e9d8f24f: starting namenode, logging to /usr/local/hadoop/logs/hadoop-root-namenode-d4e1e9d8f24f.out
localhost: starting datanode, logging to /usr/local/hadoop/logs/hadoop-root-datanode-d4e1e9d8f24f.out
Starting secondary namenodes <span class="o">[</span><span class="m">0</span>.0.0.0<span class="o">]</span>
<span class="m">0</span>.0.0.0: starting secondarynamenode, logging to /usr/local/hadoop/logs/hadoop-root-secondarynamenode-d4e1e9d8f24f.out
starting yarn daemons
starting resourcemanager, logging to /usr/local/hadoop/logs/yarn--resourcemanager-d4e1e9d8f24f.out
localhost: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-root-nodemanager-d4e1e9d8f24f.out
bash-4.1#
</pre></div>
</div>
<p>用户此时可以查看各种配置信息和执行操作，例如查看namenode日志等信息：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>bash-4.1# cat /usr/local/hadoop/logs/hadoop-root-namenode-48db675a662b.out
<span class="nb">ulimit</span> -a <span class="k">for</span> user root
core file size          <span class="o">(</span>blocks, -c<span class="o">)</span> unlimited
data seg size           <span class="o">(</span>kbytes, -d<span class="o">)</span> unlimited
scheduling priority             <span class="o">(</span>-e<span class="o">)</span> <span class="m">0</span>
file size               <span class="o">(</span>blocks, -f<span class="o">)</span> unlimited
pending signals                 <span class="o">(</span>-i<span class="o">)</span> <span class="m">3796</span>
max locked memory       <span class="o">(</span>kbytes, -l<span class="o">)</span> <span class="m">64</span>
max memory size         <span class="o">(</span>kbytes, -m<span class="o">)</span> unlimited
open files                      <span class="o">(</span>-n<span class="o">)</span> <span class="m">1048576</span>
pipe size            <span class="o">(</span><span class="m">512</span> bytes, -p<span class="o">)</span> <span class="m">8</span>
POSIX message queues     <span class="o">(</span>bytes, -q<span class="o">)</span> <span class="m">819200</span>
real-time priority              <span class="o">(</span>-r<span class="o">)</span> <span class="m">0</span>
stack size              <span class="o">(</span>kbytes, -s<span class="o">)</span> <span class="m">8192</span>
cpu <span class="nb">time</span>               <span class="o">(</span>seconds, -t<span class="o">)</span> unlimited
max user processes              <span class="o">(</span>-u<span class="o">)</span> unlimited
virtual memory          <span class="o">(</span>kbytes, -v<span class="o">)</span> unlimited
file locks                      <span class="o">(</span>-x<span class="o">)</span> unlimited
</pre></div>
</div>
<p>用户需要验证Hadoop环境是否安装成功。首先进入Hadoop容器的bash命令行环境，进入Hadoop目录：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>bash-4.1# <span class="nb">cd</span> <span class="nv">$HADOOP_PREFIX</span>
bash-4.1# <span class="nb">pwd</span>
/usr/local/hadoop
</pre></div>
</div>
<p>然后通过运行Hadoop内置的实例程序来进行测试：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>bash-4.1# bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.0.jar grep input output <span class="s1">&#39;dfs[a-z.]+&#39;</span>
<span class="m">20</span>/04/30 <span class="m">06</span>:14:47 INFO client.RMProxy: Connecting to ResourceManager at /0.0.0.0:8032
<span class="m">20</span>/04/30 <span class="m">06</span>:14:49 INFO input.FileInputFormat: Total input paths to process : <span class="m">31</span>
<span class="m">20</span>/04/30 <span class="m">06</span>:14:50 INFO mapreduce.JobSubmitter: number of splits:31
<span class="m">20</span>/04/30 <span class="m">06</span>:14:50 INFO mapreduce.JobSubmitter: Submitting tokens <span class="k">for</span> job: job_1588241417898_0001
<span class="m">20</span>/04/30 <span class="m">06</span>:14:51 INFO impl.YarnClientImpl: Submitted application application_1588241417898_0001
<span class="m">20</span>/04/30 <span class="m">06</span>:14:51 INFO mapreduce.Job: The url to track the job: http://48db675a662b:8088/proxy/application_1588241417898_0001/
<span class="m">20</span>/04/30 <span class="m">06</span>:14:51 INFO mapreduce.Job: Running job: job_1588241417898_0001
</pre></div>
</div>
<p>最后用户可以使用hdfs指令检查输出结果：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>bash-4.1# bin/hdfs dfs -cat output/*
</pre></div>
</div>
</section>
<section id="id57">
<span id="id58"></span><h4>2.相关资源<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h4>
<p>Hadoop的相关资源如下：</p>
<ul class="simple">
<li><p>Hadoop官网：<a class="reference external" href="http://hadoop.apache.org">http://hadoop.apache.org</a></p></li>
<li><p>Hadoop镜像：<a class="reference external" href="https://hub.docker.com/r/sequenceiq/hadoop-docker/">https://hub.docker.com/r/sequenceiq/hadoop-docker/</a></p></li>
<li><p>Hadoop镜像仓库：<a class="reference external" href="https://github.com/sequenceiq/hadoop-docker">https://github.com/sequenceiq/hadoop-docker</a></p></li>
<li><p>Hadoop
Dockerfile：<a class="reference external" href="https://hub.docker.com/r/sequenceiq/hadoop-docker/~/dockerfile/">https://hub.docker.com/r/sequenceiq/hadoop-docker/~/dockerfile/</a></p></li>
</ul>
</section>
</section>
<section id="spark">
<h3><a class="toc-backref" href="#id141">5.2 Spark</a><a class="headerlink" href="#spark" title="Permalink to this headline">¶</a></h3>
<p>Apache
Spark是一个围绕速度、易用性和复杂分析构建的大数据处理框架，基于Scala开发。最初在2009年由加州大学伯克利分校的AMPLab开发，并于2010年成为Apache的开源项目之一。与Hadoop和Storm等其他大数据及MapReduce技术相比，Spark支持更灵活的函数定义，可以将应用处理速度提升1～2个数量级，并且提供了众多方便的实用工具，包括SQL查询、流处理、机器学习和图处理等：</p>
<p><img alt="image31" src="../_images/docker_spark0001.png" /></p>
<p>Spark目前支持Scala、Java、Python、Clojure、R程序设计语言编写应用。除了Spark核心API之外，Spark生态系统中还包括其他附加库，可以在大数据分析和机器学习领域提供更多的能力。这些库包括：Spark
Streaming（用于构建弹性容错的流处理App），Spark
SQL（支持SQL语句以及结构化数据处理），Spark MLlib（用于机器学习），Spark
GraphX（用于图数据处理）。除了这些库以外，还有一些其他的库，如BlinkDB和Tachyon。</p>
<p>Spark典型架构包括三个主要组件：驱动程序、集群管理器、工作者节点，如图</p>
<p>Spark的典型架构</p>
<p><img alt="image32" src="../_images/docker_spark0002.png" /></p>
<p>目前Spark推出了2.2版本，性能大幅度提升，并在数据流支持方面推出了很多新功能。</p>
<section id="id59">
<span id="id60"></span><h4>1.使用官方镜像<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h4>
<p>用户可以使用sequenceiq/spark镜像，版本方面支持Hadoop 2.6.0、Apache Spark
v1.6.0（CentOS）。同时此镜像还包含Dockerfile，用户可以基于它构建自定义的Apache
Spark镜像。</p>
<p>可使用docker pull指令直接获取镜像：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker pull sequenceiq/spark:1.6.0
1.6.0: Pulling from sequenceiq/spark
...
9d406b080497: Pull complete
Digest: sha256:64fbdd1a9ffb6076362359c3895d089afc65a533c0ef021ad4ae6da3f8b2a413
Status: Downloaded newer image for sequenceiq/spark:1.6.0
</pre></div>
</div>
<p>也可以使用docker build指令构建spark镜像：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker build --rm -t sequenceiq/spark:1.6.0 .
</pre></div>
</div>
<hr class="docutils" />
<p>另外，用户在运行容器时，需要映射YARN UI需要的端口：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it -p <span class="m">8088</span>:8088 -p <span class="m">8042</span>:8042 -h sandbox sequenceiq/spark:1.6.0 bash
/
Starting sshd:                                             <span class="o">[</span>  OK  <span class="o">]</span>
Starting namenodes on <span class="o">[</span>sandbox<span class="o">]</span>
sandbox: starting namenode, logging to /usr/local/hadoop/logs/hadoop-root-namenode-sandbox.out
localhost: starting datanode, logging to /usr/local/hadoop/logs/hadoop-root-datanode-sandbox.out
Starting secondary namenodes <span class="o">[</span><span class="m">0</span>.0.0.0<span class="o">]</span>
<span class="m">0</span>.0.0.0: starting secondarynamenode, logging to /usr/local/hadoop/logs/hadoop-root-secondarynamenode-sandbox.out
starting yarn daemons
starting resourcemanager, logging to /usr/local/hadoop/logs/yarn--resourcemanager-sandbox.out
localhost: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-root-nodemanager-sandbox.out
bash-4.1#
</pre></div>
</div>
<hr class="docutils" />
<p>启动后，可以使用bash命令行来查看namenode日志等信息：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>bash-4.1# cat /usr/local/hadoop/logs/hadoop-root-namenode-sandbox.out
<span class="nb">ulimit</span> -a <span class="k">for</span> user root
core file size          <span class="o">(</span>blocks, -c<span class="o">)</span> <span class="m">0</span>
data seg size           <span class="o">(</span>kbytes, -d<span class="o">)</span> unlimited
scheduling priority             <span class="o">(</span>-e<span class="o">)</span> <span class="m">0</span>
file size               <span class="o">(</span>blocks, -f<span class="o">)</span> unlimited
pending signals                 <span class="o">(</span>-i<span class="o">)</span> <span class="m">7758</span>
max locked memory       <span class="o">(</span>kbytes, -l<span class="o">)</span> <span class="m">64</span>
max memory size         <span class="o">(</span>kbytes, -m<span class="o">)</span> unlimited
open files                      <span class="o">(</span>-n<span class="o">)</span> <span class="m">1048576</span>
pipe size            <span class="o">(</span><span class="m">512</span> bytes, -p<span class="o">)</span> <span class="m">8</span>
POSIX message queues     <span class="o">(</span>bytes, -q<span class="o">)</span> <span class="m">819200</span>
real-time priority              <span class="o">(</span>-r<span class="o">)</span> <span class="m">0</span>
stack size              <span class="o">(</span>kbytes, -s<span class="o">)</span> <span class="m">8192</span>
cpu <span class="nb">time</span>               <span class="o">(</span>seconds, -t<span class="o">)</span> unlimited
max user processes              <span class="o">(</span>-u<span class="o">)</span> unlimited
virtual memory          <span class="o">(</span>kbytes, -v<span class="o">)</span> unlimited
file locks                      <span class="o">(</span>-x<span class="o">)</span> unlimited
</pre></div>
</div>
<p>用户还可以使用daemon模式运行此Spark环境：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run -d -h sandbox sequenceiq/spark:1.6.0 -d
e2c26d1bb97439081ad1956faaed3346fcb6335ae774e1177021706dc5887e55
</pre></div>
</div>
<hr class="docutils" />
<p>继续使用docker ps指令查看运行详情：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker ps -a
CONTAINER ID IMAGE                   COMMAND
e2c26d1bb974 sequenceiq/spark:1.6.0  &quot;/etc/bootstrap.sh -d&quot;
CREATED  STATUS      PORTS
x ago    Up x minute 22/tcp, 8030-8033/tcp, 8040/tcp, 8042/tcp, 8088/tcp, 49707/tcp, 50010/tcp, 50020/tcp, 50070/tcp, 50075/tcp, 50090/tcp
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="id61">
<h4>2.验证<a class="headerlink" href="#id61" title="Permalink to this headline">¶</a></h4>
<p>基于YARN部署Spark系统时，用户有两种部署方式可选：YARN客户端模式和YARN集群模式。下面将分别论述两种部署方式。</p>
<p>（1）YARN客户端模式</p>
<p>在YARN客户端模式中，SparkContext（或称为驱动程序）运行在客户端进程中，主（master）应用仅处理来自YARN的资源管理请求：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 运行 spark shell</span>
<span class="n">spark</span><span class="o">-</span><span class="n">shell</span> \
<span class="o">--</span><span class="n">master</span> <span class="n">yarn</span><span class="o">-</span><span class="n">client</span> \
<span class="o">--</span><span class="n">driver</span><span class="o">-</span><span class="n">memory</span> <span class="mi">1</span><span class="n">g</span> \
<span class="o">--</span><span class="n">executor</span><span class="o">-</span><span class="n">memory</span> <span class="mi">1</span><span class="n">g</span> \
<span class="o">--</span><span class="n">executor</span><span class="o">-</span><span class="n">cores</span> <span class="mi">1</span>
<span class="c1"># 执行以下指令，若返回1000则符合预期</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<hr class="docutils" />
<p>（2）YARN集群模式</p>
<p>在YARN集群模式中，Spark驱动程序运行于主应用的进程中，即由YARN从集群层面进行管理。下面，以Pi值计算为例子，展示两种模式的区别：</p>
<p>Pi计算（YARN集群模式）：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># 执行以下指令，成功后，日志中会新增记录&quot;Pi is roughly 3.1418&quot;
# 集群模式下用户必须指定 --files 参数，以开启metrics
spark-submit \
--class org.apache.spark.examples.SparkPi \
--files $SPARK_HOME/conf/metrics.properties \
--master yarn-cluster \
--driver-memory 1g \
--executor-memory 1g \
--executor-cores 1 \
$SPARK_HOME/lib/spark-examples-1.6.0-hadoop2.6.0.jar
</pre></div>
</div>
<hr class="docutils" />
<p>Pi计算（YARN客户端模式）：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># 执行以下指令，成功后，命令行将显示&quot;Pi is roughly 3.1418&quot;
spark-submit \
--class org.apache.spark.examples.SparkPi \
--master yarn-client \
--driver-memory 1g \
--executor-memory 1g \
--executor-cores 1 \
$SPARK_HOME/lib/spark-examples-1.6.0-hadoop2.6.0.jar
</pre></div>
</div>
<hr class="docutils" />
<p>（3）容器外访问Spark</p>
<p>如果用户需要从容器外访问Spark环境，则需要设置YARN_CONF_DIR环境变量。参见相关资源部分的Spark镜像仓库，即可见yarn-remote-client文件夹。此文件夹内置远程访问的配置信息：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">YARN_CONF_DIR</span><span class="o">=</span><span class="s2">&quot;`pwd`/yarn-remote-client&quot;</span>
</pre></div>
</div>
<hr class="docutils" />
<p>用户只能使用根用户访问Docker的HDFS环境。当用户从容器集群外部使用非根用户访问Spark环境时，则需要配置HADOOP_USER_NAME环境变量：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">HADOOP_USER_NAME</span><span class="o">=</span><span class="n">root</span>
</pre></div>
</div>
</section>
<section id="id62">
<span id="id63"></span><h4>3.相关资源<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h4>
<p>Spark的相关资源如下：</p>
<ul class="simple">
<li><p>Spark官网：<a class="reference external" href="http://spark.apache.org/">http://spark.apache.org/</a></p></li>
<li><p>Spark官方仓库：<a class="reference external" href="https://github.com/apache/spark">https://github.com/apache/spark</a></p></li>
<li><p>Spark
2.0更新点：<a class="reference external" href="http://spark.apache.org/releases/spark-release-2-0-0.html">http://spark.apache.org/releases/spark-release-2-0-0.html</a></p></li>
<li><p>Spark镜像：<a class="reference external" href="https://hub.docker.com/r/sequenceiq/spark/">https://hub.docker.com/r/sequenceiq/spark/</a></p></li>
<li><p>Spark镜像仓库：<a class="reference external" href="https://github.com/sequenceiq/docker-spark">https://github.com/sequenceiq/docker-spark</a></p></li>
</ul>
</section>
</section>
<section id="storm">
<h3><a class="toc-backref" href="#id142">5.3 Storm</a><a class="headerlink" href="#storm" title="Permalink to this headline">¶</a></h3>
<p>Apache Storm是一个实时流计算框架，由Twitter在2014年正式开源，遵循Eclipse
Public License 1.0，基于Clojure等语言实现。</p>
<p><img alt="image33" src="../_images/docker_storm0001.png" /></p>
<p>Storm集群与Hadoop集群在工作方式上十分相似，唯一区别在于Hadoop上运行的是MapReduce任务，在Storm上运行的则是topology。MapReduce任务完成处理即会结束，而topology则永远在等待消息并处理（直到停止）。</p>
<p>Storm集群中有两种节点：主节点和工作节点，主节点运行一个叫“Nimbus”的守护进程（daemon），与Hadoop的“任务跟踪器”（Jobtracker）类似。Nimbus负责向集群中分发代码，向各机器分配任务，以及监测故障。工作节点运行“Supervisor”守护进程，负责监听Nimbus指派到机器的任务，根据指派信息来管理工作者进程（worker
process），每一个工作者进程执行一个topology的任务子集。</p>
<p>Nimbus和Supervisors之间的所有协调调度通过Zookeeper集群来完成。另外，Nimbus守护进程和Supervisor守护进程都是快速失败和无状态的，实现极高的稳定度。</p>
<section id="composestorm">
<h4>1.使用Compose搭建Storm集群<a class="headerlink" href="#composestorm" title="Permalink to this headline">¶</a></h4>
<p>利用Docker Compose模板，用户可以在本地单机Docker环境快速地搭建一个Apache
Storm集群，进行应用开发测试。</p>
<p>（1）Storm示例架构</p>
<p>Storm示例架构如图</p>
<p>Storm示例架构</p>
<p><img alt="image34" src="../_images/docker_storm0002.png" /></p>
<p>其中包含如下容器：</p>
<p>·zookeeper：Apache Zookeeper三节点部署；</p>
<p>·nimbus：Storm Nimbus；</p>
<p>·ui：Storm UI；</p>
<p>·supervisor：Storm Supervisor(一个或多个)；</p>
<p>·topology：Topology部署工具，其中示例应用基于官方示例storm-starter代码构建。</p>
<p>本节的Docker
Compose文件和示例应用等可以从<a class="reference external" href="https://github.com/denverdino/docker-storm">https://github.com/denverdino/docker-storm</a>
获得。</p>
<p>（2）本地开发测试</p>
<p>首先从Github下载需要的代码：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ git clone https://github.com/denverdino/docker-storm.git
$ <span class="nb">cd</span> docker-swarm/local
</pre></div>
</div>
<hr class="docutils" />
<p>代码库中的docker-compose.yml文件描述了典型的Storm应用架构：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>version: <span class="s1">&#39;2&#39;</span>
services:
    zookeeper1:
        image: baqend/storm:3.4.8
        container_name: zk1.cloud
        environment:
            - <span class="nv">SERVER_ID</span><span class="o">=</span><span class="m">1</span>
            - <span class="nv">ADDITIONAL_ZOOKEEPER_1</span><span class="o">=</span>server.1<span class="o">=</span><span class="m">0</span>.0.0.0:2888:3888
            - <span class="nv">ADDITIONAL_ZOOKEEPER_2</span><span class="o">=</span>server.2<span class="o">=</span>zk2.cloud:2888:3888
            - <span class="nv">ADDITIONAL_ZOOKEEPER_3</span><span class="o">=</span>server.3<span class="o">=</span>zk3.cloud:2888:3888
    zookeeper2:
        image: baqend/storm:3.4.8
        container_name: zk2.cloud
        environment:
            - <span class="nv">SERVER_ID</span><span class="o">=</span><span class="m">2</span>
            - <span class="nv">ADDITIONAL_ZOOKEEPER_1</span><span class="o">=</span>server.1<span class="o">=</span>zk1.cloud:2888:3888
            - <span class="nv">ADDITIONAL_ZOOKEEPER_2</span><span class="o">=</span>server.2<span class="o">=</span><span class="m">0</span>.0.0.0:2888:3888
            - <span class="nv">ADDITIONAL_ZOOKEEPER_3</span><span class="o">=</span>server.3<span class="o">=</span>zk3.cloud:2888:3888
    zookeeper3:
        image: baqend/storm:3.4.8
        container_name: zk3.cloud
        environment:
            - <span class="nv">SERVER_ID</span><span class="o">=</span><span class="m">3</span>
            - <span class="nv">ADDITIONAL_ZOOKEEPER_1</span><span class="o">=</span>server.1<span class="o">=</span>zk1.cloud:2888:3888
            - <span class="nv">ADDITIONAL_ZOOKEEPER_2</span><span class="o">=</span>server.2<span class="o">=</span>zk2.cloud:2888:3888
            - <span class="nv">ADDITIONAL_ZOOKEEPER_3</span><span class="o">=</span>server.3<span class="o">=</span><span class="m">0</span>.0.0.0:2888:3888
    ui:
        image: baqend/storm:1.0.0
        command: ui -c nimbus.host<span class="o">=</span>nimbus
        environment:
            - <span class="nv">STORM_ZOOKEEPER_SERVERS</span><span class="o">=</span>zk1.cloud,zk2.cloud,zk3.cloud
        restart: always
        container_name: ui
        ports:
            - <span class="m">8080</span>:8080
        depends_on:
            - nimbus
    nimbus:
        image: baqend/storm:1.0.0
        command: nimbus -c nimbus.host<span class="o">=</span>nimbus
        restart: always
        environment:
            - <span class="nv">STORM_ZOOKEEPER_SERVERS</span><span class="o">=</span>zk1.cloud,zk2.cloud,zk3.cloud
        container_name: nimbus
        ports:
            - <span class="m">6627</span>:6627
    supervisor:
        image: baqend/storm:1.0.0
        command: supervisor -c nimbus.host<span class="o">=</span>nimbus -c supervisor.slots.ports<span class="o">=</span> <span class="o">[</span><span class="m">6700</span>,6701,6702,6703<span class="o">]</span>
        restart: always
        environment:
            - affinity:role!<span class="o">=</span>supervisor
            - <span class="nv">STORM_ZOOKEEPER_SERVERS</span><span class="o">=</span>zk1.cloud,zk2.cloud,zk3.cloud
        depends_on:
            - nimbus
    topology:
        build: ../storm-starter
        command: -c nimbus.host<span class="o">=</span>nimbus jar /topology.jar org.apache.storm.starter. RollingTopWords production-topology remote
        depends_on:
            - nimbus
networks:
    default:
        external:
            name: test-storm
</pre></div>
</div>
<hr class="docutils" />
<p>用户可以直接运行下列命令构建测试镜像：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker-compose build
</pre></div>
</div>
<hr class="docutils" />
<p>现在可以用下面的命令来一键部署一个Storm应用：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker-compose up -d
</pre></div>
</div>
<hr class="docutils" />
<p>部署完毕，检查Storm应用状态：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker-compose ps
</pre></div>
</div>
<p>当UI容器启动后，用户可以访问容器的8080端口来打开操作界面，如图</p>
<p>Storm UI</p>
<p><img alt="image35" src="../_images/docker_storm_UI.png" /></p>
<p>利用如下命令，可以伸缩supervisor的数量，比如伸缩到3个实例：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker-compose scale supervisor=3
</pre></div>
</div>
<hr class="docutils" />
<p>用户也许会发现Web界面中并没有运行中的topology。这是因为Docker
Compose目前只能保证容器的启动顺序，无法确保所依赖容器中的应用是否已经完全启动并可以正常访问。</p>
<p>为了解决这个问题，用户需要运行下面的命令来再次启动“topolgoy”服务应用来提交更新的拓扑：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker-compose start topology
</pre></div>
</div>
<hr class="docutils" />
<p>稍后刷新Storm UI，可以发现Storm应用已经部署成功了。</p>
</section>
<section id="id64">
<span id="id65"></span><h4>2.相关资源<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h4>
<p>Storm的相关资源如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>·Storm官网：http://storm.apache.org/
·Storm镜像：https://hub.docker.com/r/baqend/storm/
</pre></div>
</div>
</section>
</section>
<section id="elasticsearch">
<h3><a class="toc-backref" href="#id143">5.4 Elasticsearch</a><a class="headerlink" href="#elasticsearch" title="Permalink to this headline">¶</a></h3>
<p>Elasticsearch是基于Lucene的开源搜索服务（Java实现）。它是分布式、多租户的全文搜索引擎，支持RESTful
Web接口。Elasticse
arch支持实时分布式数据存储和分析查询功能，可以轻松扩展到上百台服务器，同时支持处理PB级结构化或非结构化数据。如果配合Logstash、Kibana等组件，可以快速构建一套日志消息分析平台。</p>
<p><img alt="image36" src="../_images/docker_elasticsearch001.png" /></p>
<section id="id66">
<span id="id67"></span><h4>1.使用官方镜像<a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h4>
<p>可以使用官方镜像，快速运行Elasticsearch容器：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d elasticsearch
937c1cb21b39a322ab6c5697e31af22a5329f08408d40f64e27465fed6597e34
</pre></div>
</div>
<hr class="docutils" />
<p>也可以在启动时传入一些额外的配置参数：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d elasticsearch elasticsearch -Des.node.name<span class="o">=</span><span class="s2">&quot;TestNode&quot;</span>
2c0ae96f73ca01779c60f7c6103481696c34c510266f5c503610a2640dc6f50a
</pre></div>
</div>
<hr class="docutils" />
<p>目前使用的镜像内含默认配置文件，包含预先定义好的默认配置。如果要使用自定义配置，可以使用数据卷，挂载自定义配置文件至/usr/share/elasticsearch/config：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -v <span class="s2">&quot;</span><span class="nv">$PWD</span><span class="s2">/config&quot;</span>:/usr/share/elasticsearch/config elasticsearch
43333bfdbbfe156512ba9786577ca807c676f9a767353222c106453020ac7020
</pre></div>
</div>
<hr class="docutils" />
<p>如果需要数据持久化，可以使用数据卷指令，挂载至/usr/share/elasticsearch/data：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -v <span class="s2">&quot;</span><span class="nv">$PWD</span><span class="s2">/esdata&quot;</span>:/usr/share/elasticsearch/data elasticsearch
3feddf6a8454534b209b32df06c2d65022d772a8f511593371218f6bd064e80e
</pre></div>
</div>
<hr class="docutils" />
<p>此镜像会暴露9200和9300两个默认的HTTP端口，可以通过此端口进行服务访问。9200端口是对外提供服务的API使用的端口，9300端口是内部通信端口，这些通信包括心跳、集群内部信息同步。</p>
<p>如果通过docker stack
deploy或docker-compose使用Elasticsearch，则可以参考以下stack.yml：</p>
<hr class="docutils" />
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">version</span><span class="p">:</span> <span class="s">&#39;3.1&#39;</span>
<span class="nt">services</span><span class="p">:</span>
    <span class="nt">elasticsearch</span><span class="p">:</span>
        <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">elasticsearch</span>
    <span class="nt">kibana</span><span class="p">:</span>
        <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">kibana</span>
        <span class="nt">ports</span><span class="p">:</span>
            <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">5601:5601</span>
</pre></div>
</div>
<hr class="docutils" />
<p>运行docker stack deploy-c stack.yml elasticsearch或docker-compose-f
stack.yml
up，等待初始化完成后，直接访问<a class="reference external" href="http://swarm-ip:5601/">http://swarm-ip:5601</a>
、<a class="reference external" href="http://localhost:5601/">http://localhost:5601</a>
或<a class="reference external" href="http://host-ip:5601/">http://host-ip:5601</a> 。</p>
</section>
<section id="id68">
<span id="id69"></span><h4>2.相关资源<a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h4>
<p>Elasticsearch的相关资源如下：</p>
<ul class="simple">
<li><p>Elasticsearch官网：<a class="reference external" href="https://www.elastic.co/products/elasticsearch/">https://www.elastic.co/products/elasticsearch/</a></p></li>
<li><p>Elasticsearch官方仓库：<a class="reference external" href="https://github.com/elastic/elasticsearch">https://github.com/elastic/elasticsearch</a></p></li>
<li><p>Elasticsearch官方镜像：<a class="reference external" href="https://hub.docker.com/_/elasticsearch/">https://hub.docker.com/_/elasticsearch/</a></p></li>
<li><p>Elasticsearch官方镜像仓库：<a class="reference external" href="https://www.docker.elastic.co/">https://www.docker.elastic.co/</a></p></li>
</ul>
</section>
</section>
</section>
<section id="id70">
<h2><a class="toc-backref" href="#id144">6.编程开发</a><a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h2>
<p>本章主要介绍如何使用Docker快速部署主流编程语言的开发、编译环境及其常用框架，包括C/C++、Java、Python、Javascript、Go等。通过本章学习，读者在今后采用编程语言开发和测试时，将再也不用花费大量时间进行环境配置了，只需要简单获取容器镜像，即可快速拥有相关的环境。</p>
<p>本章内容需要读者事先对相关语言的基础概念和工具栈有所了解，可自行查看语言相应的技术文档。</p>
<section id="c-c">
<h3><a class="toc-backref" href="#id145">6.1 C/C++</a><a class="headerlink" href="#c-c" title="Permalink to this headline">¶</a></h3>
<p>C是一门古老的语言，在今天仍然是系统领域和高性能计算的主要选择，在1969年由贝尔实验室设计开发。C语言具有高效、灵活、功能丰富、表达力强和較高的可移植性等特点。C++在C的基础上，支持了数据的抽象与封装、面向对象和泛型编程。功能与性能的平衡使C++成为了目前应用最广泛的系统编程语言之一。</p>
<p><img alt="image37" src="../_images/docker_c01.png" /></p>
<p>本节将介绍三款流行的C/C++开发工具：GCC、LLVM和Clang。</p>
<section id="gcc">
<h4>1.关于GCC<a class="headerlink" href="#gcc" title="Permalink to this headline">¶</a></h4>
<p>GCC（GNU Compiler
Collection）是一套由GNU开发的编程语言编译器，是一套以GPL及LGPL许可证所发行的自由软件，也是GNU计划的关键部分。GCC（特别是其中的C语言编译器）通常被认为是跨平台编译器的事实标准。GCC可处理C/C++，以及Fortran、Pascal、Objective-C、Java、Ada等多种语言。</p>
</section>
<section id="id71">
<span id="id72"></span><h4>（1）使用官方镜像<a class="headerlink" href="#id71" title="Permalink to this headline">¶</a></h4>
<p>将C/C++代码运行在容器内的最简方法，就是将编译指令写入Dockerfile中，然后使用此Dockerfile构建自定义镜像，最后直接运行此镜像，即可启动程序。</p>
<p>如果对GCC版本有要求，可以在以上命令中加入镜像标签，并在下一步的Dockerfile的FROM指令中明确GCC版本号。然后，在Dockerfile中，加入需要执行的GCC编译命令：</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">gcc:4.9</span>
<span class="k">COPY</span> . /usr/src/myapp
<span class="k">WORKDIR</span><span class="s"> /usr/src/myapp</span>
<span class="k">RUN</span> gcc -o myapp main.c
<span class="k">CMD</span> <span class="p">[</span><span class="s2">&quot;./myapp&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>编辑main.c，内容如下：</p>
<hr class="docutils" />
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<hr class="docutils" />
<p>现在，就可以使用Dockerfile来构建镜像my-gcc-app：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t gcc-image .
……
Successfully built 881d3fd0d574
</pre></div>
</div>
<p>用户可以使用docker images指令查看生成的镜像：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY  TAG     IMAGE ID      CREATED          VIRTUAL SIZE
gcc-image   latest  881d3fd0d574  <span class="m">35</span> seconds ago   <span class="m">1</span>.129 GB
</pre></div>
</div>
<hr class="docutils" />
<p>创建并运行此容器，会编译并运行程序，输出Hello World语句：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm --name gcc-container gcc-image
Hello World
</pre></div>
</div>
<hr class="docutils" />
<p>如果只需要容器编译程序，而不需要运行它，可以使用如下命令：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --rm -v <span class="s2">&quot;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&quot;</span>:/usr/src/myapp -w /usr/src/myapp gcc gcc -o myapp main.c
</pre></div>
</div>
<hr class="docutils" />
<p>以上命令会将当前目录（“$（pwd）”）挂载到容器的/usr/src/myapp目录，并执行gcc-o
myapp
myapp.c.。GCC将会编译myapp.c代码，并将生成的可执行文件输出至/usr/src/myapp文件夹。</p>
<p>如果项目已经编写好了Makefile，也可以在容器中直接执行make命令：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --rm -v <span class="s2">&quot;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&quot;</span>:/usr/src/myapp -w /usr/src/myapp gcc make<span class="sb">`</span>
</pre></div>
</div>
</section>
<section id="id73">
<h4>（2）定制镜像<a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h4>
<p>下面，笔者给出了基于buildpack-deps：wheezy镜像创建GCC镜像的Dockerfile供读者参考：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># https://registry.hub.docker.com/u/snormore/llvm/dockerfile/</span>
FROM buildpack-deps:wheezy
<span class="c1"># https://gcc.gnu.org/mirrors.html</span>
RUN gpg --keyserver pgp.mit.edu --recv-key <span class="se">\</span>
    B215C1633BCA0477615F1B35A5B3A004745C015A <span class="se">\</span>
    B3C42148A44E6983B3E4CC0793FA9B1AB75C61B8 <span class="se">\</span>
    90AA470469D3965A87A5DCB494D03953902C9419 <span class="se">\</span>
    80F98B2E0DAB6C8281BDF541A7C8C3B2F71EDF1C <span class="se">\</span>
    7F74F97C103468EE5D750B583AB00996FC26A641 <span class="se">\</span>
    33C235A34C46AA3FFB293709A328C3A2C3C45C06
ENV GCC_VERSION <span class="m">4</span>.9.1
<span class="c1"># 下载需要的 tar 格式源码并解压安装</span>
RUN apt-get update <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get install -y curl flex wget <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm -r /var/lib/apt/lists/* <span class="se">\</span>
    <span class="o">&amp;&amp;</span> curl -SL <span class="s2">&quot;http://ftpmirror.gnu.org/gcc/gcc-</span><span class="nv">$GCC_VERSION</span><span class="s2">/gcc-</span><span class="nv">$GCC_VERSION</span><span class="s2">.tar.bz2&quot;</span> -o gcc.tar.bz2 <span class="se">\</span>
    <span class="o">&amp;&amp;</span> curl -SL <span class="s2">&quot;http://ftpmirror.gnu.org/gcc/gcc-</span><span class="nv">$GCC_VERSION</span><span class="s2">/gcc-</span><span class="nv">$GCC_VERSION</span><span class="s2">.tar.bz2.sig&quot;</span> -o gcc.tar.bz2.sig <span class="se">\</span>
    <span class="o">&amp;&amp;</span> gpg --verify gcc.tar.bz2.sig <span class="se">\</span>
    <span class="o">&amp;&amp;</span> mkdir -p /usr/src/gcc <span class="se">\</span>
    <span class="o">&amp;&amp;</span> tar -xvf gcc.tar.bz2 -C /usr/src/gcc --strip-components<span class="o">=</span><span class="m">1</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm gcc.tar.bz2* <span class="se">\</span>
    <span class="o">&amp;&amp;</span> <span class="nb">cd</span> /usr/src/gcc <span class="se">\</span>
    <span class="o">&amp;&amp;</span> ./contrib/download_prerequisites <span class="se">\</span>
    <span class="o">&amp;&amp;</span> <span class="o">{</span> rm *.tar.* <span class="o">||</span> true<span class="p">;</span> <span class="o">}</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> <span class="nv">dir</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>mktemp -d<span class="k">)</span><span class="s2">&quot;</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> <span class="nb">cd</span> <span class="s2">&quot;</span><span class="nv">$dir</span><span class="s2">&quot;</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> /usr/src/gcc/configure <span class="se">\</span>
        --disable-multilib <span class="se">\</span>
        --enable-languages<span class="o">=</span>c,c++ <span class="se">\</span>
    <span class="o">&amp;&amp;</span> make -j<span class="s2">&quot;</span><span class="k">$(</span>nproc<span class="k">)</span><span class="s2">&quot;</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> make install-strip <span class="se">\</span>
    <span class="o">&amp;&amp;</span> <span class="nb">cd</span> .. <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm -rf <span class="s2">&quot;</span><span class="nv">$dir</span><span class="s2">&quot;</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get purge -y --auto-remove curl gcc g++ wget
</pre></div>
</div>
</section>
<section id="llvm">
<h4>2.LLVM<a class="headerlink" href="#llvm" title="Permalink to this headline">¶</a></h4>
<p>LLVM（Low Level Virtual
Machine）是美国伊利诺伊大学的一个研究项目，试图提供一个现代化的、基于SSA的编译策略，同时支持静态和动态编程语言。和之前为大家所熟知的JVM以及.net
Runtime这样的虚拟机不同，这个虚拟系统提供了一套中立的中间代码和编译基础设施，并围绕这些设施提供了一套全新的编译策略（使得优化能够在编译、连接、运行环境执行过程中，以及安装之后以有效的方式进行）和其他一些非常有意思的功能。</p>
<p>LLVM包括若干重要的子项目，其中Clang将在后面讲解。</p>
<p>DockerHub中已经有用户提供了LLVM镜像，读者可以直接下载使用，不再赘述：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker pull imiell/llvm
</pre></div>
</div>
<hr class="docutils" />
<p>还可以基于前面提到的SSHD基础镜像来定制GCC镜像，构建后直接运行。也可以使用Docker
Hub中提供的第三方Dockerfile，定制或修改后构建镜像，然后运行容器即可。</p>
</section>
<section id="clang">
<h4>3.Clang<a class="headerlink" href="#clang" title="Permalink to this headline">¶</a></h4>
<p>Clang是一个由Apple公司用C++实现、基于LLVM的C/C++/Objective-C/Objective-C++编译器，其目标就是超越GCC成为标准的C/C++编译器，它遵循LLVM
BSD许可。Clang很好地兼容了GCC。</p>
<p>Clang特性包括：</p>
<p>·快：在OS X上的测试中，Clang比GCC 4.0快2.5倍；</p>
<p>·内存占用小：Clang内存占用一般比GCC要小的多；</p>
<p>·诊断信息可读性强：Clang对于错误的语法不但有源码提示，还会在错误的调用和相关上下文上有更好的提示；</p>
<p>·基于库的模块化设计：Clang将编译过程分成彼此分离的几个阶段，将大大增强IDE对于代码的操控能力。</p>
<p>在DockerHub中已经有用户提供了Clang的镜像，读者可以直接下载使用：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker pull bowery/clang
</pre></div>
</div>
<hr class="docutils" />
<p>还可以基于SSHD镜像自定义Dockerfile。也可以使用DockerHub中的第三方镜像构建Clang容器。这里以ubuntu：bionic系统为例，给出了示例Dockerfile文件：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># https://registry.hub.docker.com/u/rsmmr/clang/dockerfile</span>
FROM ubuntu:bionic
<span class="c1"># 设置环境变量</span>
ENV PATH /opt/llvm/bin:<span class="nv">$PATH</span>
<span class="c1"># 确定默认的启动命令</span>
CMD bash
<span class="c1"># 安装依赖包Setup packages.</span>
RUN apt-get update <span class="o">&amp;&amp;</span> apt-get -y install cmake git build-essential vim python
<span class="c1"># 将 install-clang 拷贝至本目录</span>
ADD . /opt/install-clang
<span class="c1"># 编译和安装 LLVM/clang</span>
RUN /opt/install-clang/install-clang -j <span class="m">4</span> -C /opt/llvm
</pre></div>
</div>
</section>
<section id="id74">
<span id="id75"></span><h4>4.相关资源<a class="headerlink" href="#id74" title="Permalink to this headline">¶</a></h4>
<p>GCC和LLVM的相关资源如下：</p>
<ul class="simple">
<li><p>官网：<a class="reference external" href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></p></li>
<li><p>GCC官方镜像：<a class="reference external" href="https://hub.docker.com/_/gcc/">https://hub.docker.com/_/gcc/</a></p></li>
<li><p>GCC官方镜像仓库：<a class="reference external" href="https://github.com/docker-library/gcc">https://github.com/docker-library/gcc</a></p></li>
<li><p>LLVM官网：<a class="reference external" href="http://llvm.org/">http://llvm.org/</a></p></li>
</ul>
</section>
</section>
<section id="java">
<h3><a class="toc-backref" href="#id146">6.2 Java</a><a class="headerlink" href="#java" title="Permalink to this headline">¶</a></h3>
<p>Java是一种跨平台、面向对象、泛型编程的编译型语言，广泛应用于企业级应用开发和移动应用开发领域，由SUN公司在1995年推出。Java是基于类的面向对象的高级语言，其设计理念是尽可能地减少部署依赖，致力于允许Java应用的开发者“开发一次，到处运行”。这就意味着Java的二进制编码不需要再次编译，即可运行在异构的JVM上。Java在大型互联网项目，特别是互联网金融和电子商务项目中非常受欢迎。OpenJDK（Open
Java Development Kit）是免费开源的Java平台，支持Java SE（Standard
Edition）。从Java 7开始，OpenJDK就是官方的Java SE环境。</p>
<p><img alt="image38" src="../_images/docker_java00001.png" /></p>
<section id="id76">
<span id="id77"></span><h4>1.使用官方镜像<a class="headerlink" href="#id76" title="Permalink to this headline">¶</a></h4>
<p>在容器中运行Java代码最简单的方法就是将Java编译指令直接写入Dockerfile，然后使用此Dockerfile构建并运行此镜像，即可启动程序。具体步骤如下。</p>
<p>首先，从官方仓库获取某版本Java基础镜像</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker pull java:7
</pre></div>
</div>
<p>然后，在本地新建一个空目录，在其中创建Dockerfile文件。在Dockerfile中，加入需要执行的Java编译命令，例如：</p>
<hr class="docutils" />
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">FROM openjdk:7</span>
<span class="l l-Scalar l-Scalar-Plain">COPY . /usr/src/javaapp</span>
<span class="l l-Scalar l-Scalar-Plain">WORKDIR /usr/src/javaapp</span>
<span class="l l-Scalar l-Scalar-Plain">RUN javac HelloWorld.java</span>
<span class="l l-Scalar l-Scalar-Plain">CMD [&quot;java&quot;, &quot;HelloWorld&quot;]</span>
</pre></div>
</div>
<hr class="docutils" />
<p>如果我们希望使用最新的Java 10，可以修改基础镜像为FROM
openjdk：10。下面我们继续使用此Dockerfile构建镜像java-image：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker build -t java-image .
……
Successfully built 406d480c8fde
</pre></div>
</div>
<hr class="docutils" />
<p>可以通过docker images指令查看生成的镜像：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
java-image latest 406d480c8fde <span class="m">56</span> seconds ago <span class="m">587</span>.7 MB
</pre></div>
</div>
<hr class="docutils" />
<p>然后，运行此镜像即自动编译程序并执行：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm --name java-container java-image
Hello, World
</pre></div>
</div>
<hr class="docutils" />
<p>如果只需要容器中编译Java程序，而不需要运行，则可以使用如下命令：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --rm -v <span class="s2">&quot;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&quot;</span>:/usr/src/javaapp -w /usr/src/javaapp java:7 javac HelloWorld.java
</pre></div>
</div>
<hr class="docutils" />
<p>以上命令会将当前目录（“$（pwd）”）挂载为容器的工作目录，并执行javac
Hello
World.java命令编译HelloWorld.java代码，然后生成的HelloWorld.class类文件至当前目录下：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ls -la
total <span class="m">24</span>
drwxr-xr-x  <span class="m">5</span> faxi  staff  <span class="m">170</span> Feb  <span class="m">2</span> <span class="m">12</span>:35 .
drwxr-xr-x  <span class="m">3</span> faxi  staff  <span class="m">102</span> Feb  <span class="m">2</span> <span class="m">11</span>:52 ..
-rw-r--r--  <span class="m">1</span> faxi  staff  <span class="m">114</span> Feb  <span class="m">2</span> <span class="m">12</span>:01 Dockerfile
-rw-r--r--  <span class="m">1</span> faxi  staff  <span class="m">426</span> Feb  <span class="m">2</span> <span class="m">12</span>:29 HelloWorld.class
-rw-r--r--  <span class="m">1</span> faxi  staff  <span class="m">182</span> Feb  <span class="m">2</span> <span class="m">11</span>:59 HelloWorld.java
</pre></div>
</div>
<p>使用Docker搭建Java开发环境</p>
<p>Dockerfile</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="c1"># 基于Java 9</span>
<span class="l l-Scalar l-Scalar-Plain">FROM java:openjdk-8</span>

<span class="l l-Scalar l-Scalar-Plain"># 设置工作目录</span>
<span class="l l-Scalar l-Scalar-Plain">WORKDIR /app</span>

<span class="l l-Scalar l-Scalar-Plain"># 复制文件到工作目录</span>
<span class="l l-Scalar l-Scalar-Plain">COPY . /app</span>

<span class="l l-Scalar l-Scalar-Plain"># 设置Java环境变量</span>
<span class="l l-Scalar l-Scalar-Plain">ENV PATH=$PATH:$JAVA_HOME/bin</span>
<span class="l l-Scalar l-Scalar-Plain">ENV JRE_HOME=${JAVA_HOME}/jre</span>
<span class="l l-Scalar l-Scalar-Plain">ENV CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib</span>

<span class="l l-Scalar l-Scalar-Plain"># 编译</span>
<span class="l l-Scalar l-Scalar-Plain">RUN [&quot;/usr/lib/jvm/java-8-openjdk-amd64/bin/javac&quot;,&quot;Hello.java&quot;]</span>

<span class="l l-Scalar l-Scalar-Plain"># 运行</span>
<span class="l l-Scalar l-Scalar-Plain">ENTRYPOINT [&quot;/usr/lib/jvm/java-8-openjdk-amd64/bin/java&quot;, &quot;Hello&quot;]</span>
</pre></div>
</div>
<p>Hello.java</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//引入命名空间</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="p">;</span>
<span class="c1">//类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span><span class="p">{</span>
    <span class="c1">//程序入口</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">){</span>
        <span class="c1">//打印字符串（控制台）</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Hello World!&quot;</span><span class="p">);</span>
        <span class="c1">//打印当前时间</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="k">new</span> <span class="n">Date</span><span class="p">());</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>构建Docker镜像</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@docker java<span class="o">]</span><span class="c1"># docker build -t java-hello:latest . --rm -f &quot;Dockerfile&quot;</span>
</pre></div>
</div>
<p>运行镜像</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@docker java<span class="o">]</span><span class="c1"># docker run java-hello:latest</span>
</pre></div>
</div>
<p>Docker
Linux容器使用Linux内核的CGroup机制来实现限制容器的资源使用。CGroup（Control
Groups）是Linux内核提供的一种可以限制、记录、隔离进程组所使用的物理资源（如CPU、MEMORY、磁盘I/O等）的机制，被LXC、Docker等很多项目用于实现进程资源控制。</p>
<p>资源限制</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>root@docker java<span class="o">]</span><span class="c1"># docker run java-hello:latest --cpu 4 --memory 100m</span>
</pre></div>
</div>
</section>
<section id="spring-boot">
<h4>2.关于Spring Boot<a class="headerlink" href="#spring-boot" title="Permalink to this headline">¶</a></h4>
<p><img alt="image39" src="../_images/docker_spring00001.png" /></p>
<p>Spring
Boot是由Pivotal团队开发的框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式进行配置，从而使开发人员不再需要定义样板化的配置。Spring
Boot致力于在蓬勃发展的快速应用开发领域成为领导者。</p>
<p>Spring
Boot项目旨在简化创建产品级的Spring应用和服务，通过它来选择不同的Spring平台。可创建独立的Java应用和Web应用，同时提供了命令行工具来支持spring
scripts。</p>
<p>下图显示Spring Boot在Spring生态中的位置。</p>
<p>Spring生态</p>
<p><img alt="image40" src="../_images/docker_spring_boot01.png" /></p>
<p>Spring Boot特性包括：</p>
<p>·创建独立Spring应用；</p>
<p>·内嵌Tomcat，Jetty或Undertow（无须部署WAR文件）；</p>
<p>·提供starter POM，简化Maven配置；</p>
<p>·尽可能地实现Spring项目配置自动化；</p>
<p>·提供工业级特性，如metrics，健康检查等；</p>
<p>·不生成代码，不需要XML配置。</p>
<p>下面介绍如何使用compose来搭建Spring
Boot应用，环境要求是JDK1.8或以上版本，Maven3.0或以上版本。</p>
<p>第一步 ，创建一个Spring Boot应用。</p>
<p>首先，下载并解压Spring Boot应用模板代码：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>git clone https://github.com/spring-guides/gs-spring-boot-docker.git<span class="s1">&#39;</span>
<span class="s1">&#39;</span><span class="nb">cd</span> gs-spring-boot-docker
</pre></div>
</div>
<hr class="docutils" />
<p>然后，编辑代码文件src/main/java/hello/Application.java，内容如下：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>package hello<span class="p">;</span>
import org.springframework.boot.SpringApplication<span class="p">;</span>
import org.springframework.boot.autoconfigure.SpringBootApplication<span class="p">;</span>
import org.springframework.boot.bind.RelaxedPropertyResolver<span class="p">;</span>
import org.springframework.web.bind.annotation.RequestMapping<span class="p">;</span>
import org.springframework.web.bind.annotation.RestController<span class="p">;</span>
@SpringBootApplication
@RestController
public class Application <span class="o">{</span>
    @RequestMapping<span class="o">(</span><span class="s2">&quot;/&quot;</span><span class="o">)</span>
    public String home<span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s2">&quot;Hello Docker World&quot;</span><span class="p">;</span>
    <span class="o">}</span>
    public static void main<span class="o">(</span>String<span class="o">[]</span> args<span class="o">)</span> <span class="o">{</span>
        SpringApplication.run<span class="o">(</span>Application.class, args<span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<hr class="docutils" />
<p>&#64;SpringBootApplication和&#64;RestController注解表示Java类Application已经准备好被spring
MVC所调用，并提供HTTP服务。注解&#64;RequestMapping（“/”）表示context
path“/”的请求路由到方法home中进行处理，main方法中的SpringApplication.run（）用来启动一个Spring
Boot应用。</p>
<p>第二步 ，容器化Spring Boot应用。</p>
<p>首先，新建src/main/docker/Dockerfile，内容如下：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>FROM java:8
VOLUME /tmp
ADD gs-spring-boot-docker-0.1.0.jar app.jar
RUN bash -c <span class="s1">&#39;touch /app.jar&#39;</span>
ENTRYPOINT <span class="o">[</span><span class="s2">&quot;java&quot;</span>,<span class="s2">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="s2">&quot;-jar&quot;</span>,<span class="s2">&quot;/app.jar&quot;</span><span class="o">]</span>
</pre></div>
</div>
<hr class="docutils" />
<p>然后，使用docker-maven-plugin构建镜像，pom.xml文件内容如下：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&lt;properties&gt;
      &lt;docker.image.prefix&gt;registry.aliyuncs.com/linhuatest&lt;/docker.image.prefix&gt;
&lt;/properties&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.spotify&lt;/groupId&gt;
            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;0.2.3&lt;/version&gt;
            &lt;configuration&gt;
                &lt;imageName&gt;<span class="si">${</span><span class="nv">docker</span><span class="p">.image.prefix</span><span class="si">}</span>/<span class="si">${</span><span class="nv">project</span><span class="p">.artifactId</span><span class="si">}</span>&lt;/imageName&gt;
                &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;
                &lt;resources&gt;
                    &lt;resource&gt;
                        &lt;targetPath&gt;/&lt;/targetPath&gt;
                        &lt;directory&gt;<span class="si">${</span><span class="nv">project</span><span class="p">.build.directory</span><span class="si">}</span>&lt;/directory&gt;
                        &lt;include&gt;<span class="si">${</span><span class="nv">project</span><span class="p">.build.finalName</span><span class="si">}</span>.jar&lt;/include&gt;
                    &lt;/resource&gt;
                &lt;/resources&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</pre></div>
</div>
<hr class="docutils" />
<p>pom.xml中指定了以下属性：</p>
<p>·镜像的名称，此处为registry.aliyuncs.com/linhuatest/gs-spring-boot-docker其中registry.aliyuncs.com是阿里云镜像仓库的域名，linhuatest是用户的命名空间，gs-spring-boot-docker是用户某个仓库的名称，此处没有镜像tag，默认为latest；</p>
<p>·Dockerfile文件所在的目录，该目录可以理解为Dockerfile的context，保存Dockerfile依赖的资源；</p>
<p>·将何种资源拷贝到Dockerfile文件所在的目录，即context中，此处用户只需要编译出来的jar文件。</p>
<p>最后，可以构建和推送镜像到任何一个镜像仓库，如下所示：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ mvn package docker:build <span class="c1"># 此处必须要有docker 客户端连接到docker daemon 方能构建</span>
$ docker push springio/gs-spring-boot-docker
</pre></div>
</div>
</section>
<section id="id78">
<span id="id79"></span><h4>3.相关资源<a class="headerlink" href="#id78" title="Permalink to this headline">¶</a></h4>
<p>Java和Spring Boot的相关资源如下：</p>
<ul class="simple">
<li><p>Java官方镜像：<a class="reference external" href="https://registry.hub.docker.com/_/java/">https://registry.hub.docker.com/_/java/</a></p></li>
<li><p>Java官方镜像标签：<a class="reference external" href="https://registry.hub.docker.com/_/java/tags/manage/">https://registry.hub.docker.com/_/java/tags/manage/</a></p></li>
<li><p>Spring Boot官网：<a class="reference external" href="http://projects.spring.io/spring-boot/">http://projects.spring.io/spring-boot/</a></p></li>
</ul>
</section>
</section>
<section id="python">
<h3><a class="toc-backref" href="#id147">6.3 Python</a><a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h3>
<p>Python是一种解释型动态语言，是功能强大的面向对象语言，集成了模块（modules）、异常处理（exceptions）、动态类型（dynamic
typing）、高级数据结构（元组、列表、序列）、类（classes）等高级特性。Python设计精良，语法简约，表达能力很强。目前，所有主流操作系统（Windows、Linux、类Unix系统）都支持Python。</p>
<p><img alt="image41" src="../_images/docker_python000001.png" /></p>
<p>下面我们看下如何使用Docker部署Python环境，以及部署Python技术栈中的主流框架。</p>
<section id="id80">
<h4>使用Python官方镜像<a class="headerlink" href="#id80" title="Permalink to this headline">¶</a></h4>
<p>首先推荐用户使用Docker官方提供的Python镜像作为基础镜像，主要步骤如下。</p>
<p>第一步，新建项目目录py-official，进入此目录，然后使用docker
pull命令拉取官方镜像：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker pull python
</pre></div>
</div>
<hr class="docutils" />
<p>接下来，在项目中新建一个Dockerfile文件，内容如下：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>FROM python:3

WORKDIR /usr/src/app

COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD <span class="o">[</span> <span class="s2">&quot;python&quot;</span>, <span class="s2">&quot;./your-daemon-or-script.py&quot;</span> <span class="o">]</span>
</pre></div>
</div>
<hr class="docutils" />
<p>新建<code class="docutils literal notranslate"><span class="pre">your-daemon-or-script.py</span></code>文件，计算Fibonacci数列：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>def fib<span class="o">(</span>n<span class="o">)</span>:
    a, <span class="nv">b</span> <span class="o">=</span> <span class="m">0</span>, <span class="m">1</span>
    <span class="k">while</span> a &lt; n:
        print<span class="o">(</span>a, <span class="nv">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">)</span>
        a, <span class="nv">b</span> <span class="o">=</span> b, a+b
    print<span class="o">()</span>
fib<span class="o">(</span><span class="m">1000</span><span class="o">)</span>
</pre></div>
</div>
<hr class="docutils" />
<p>新建requirements.txt依赖文件，读者可以在此文件中加入项目依赖程序，如Django等。此处仅新建空文件：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ touch requirements.txt
$ cat requirements.txt
flask
</pre></div>
</div>
<hr class="docutils" />
<p>第二步，使用docker build命令构建名为py2.7-sample-app的镜像：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t my-python-app .
Sending build context to Docker daemon  <span class="m">4</span>.096kB
Step <span class="m">1</span>/6 : FROM python:3
<span class="m">3</span>: Pulling from library/python
Digest: sha256:ad7fb5bb4770e08bf10a895ef64a300b288696a1557a6d02c8b6fba98984b86a
Status: Downloaded newer image <span class="k">for</span> python:3
 ---&gt; 4f7cd4269fa9
Step <span class="m">2</span>/6 : WORKDIR /usr/src/app
 ---&gt; Running <span class="k">in</span> d0ace5d37598
Removing intermediate container d0ace5d37598
 ---&gt; 2dcdb2d50d17
Step <span class="m">3</span>/6 : COPY requirements.txt ./
 ---&gt; 8a32641bd95a
Step <span class="m">4</span>/6 : RUN pip install --no-cache-dir -r requirements.txt
 ---&gt; Running <span class="k">in</span> d771acccb728
Collecting flask
  Downloading Flask-1.1.2-py2.py3-none-any.whl <span class="o">(</span><span class="m">94</span> kB<span class="o">)</span>
Collecting itsdangerous&gt;<span class="o">=</span><span class="m">0</span>.24
Removing intermediate container 5b38a07152b7
 ---&gt; 6dd5fea5db98
Successfully built 6dd5fea5db98
Successfully tagged my-python-app:latest
</pre></div>
</div>
<hr class="docutils" />
<p>可见至此用户已经成功构建了镜像，用户可以通过docker images命令进行查看：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY       TAG            IMAGE ID         CREATED            VIRTUAL SIZE
py3-image        latest         23edbf58654a     <span class="m">12</span> seconds ago    <span class="m">693</span>.1 MB
</pre></div>
</div>
<hr class="docutils" />
<p>第三步，通过docker[container]run命令创建并运行容器：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm --name my-running-app my-python-app
<span class="m">0</span> <span class="m">1</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">5</span> <span class="m">8</span> <span class="m">13</span> <span class="m">21</span> <span class="m">34</span> <span class="m">55</span> <span class="m">89</span> <span class="m">144</span> <span class="m">233</span> <span class="m">377</span> <span class="m">610</span> <span class="m">987</span>
</pre></div>
</div>
<hr class="docutils" />
<p>如果读者只需要运行单个Python脚本，那么无须使用Dockerfile构建自定义镜像，而是通过以下命令直接使用官方Python镜像，带参数运行容器：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>docker run -it --rm --name my-running-script -v <span class="s2">&quot;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&quot;</span>:/usr/src/myapp -w /usr/src/myapp python:3 python your-daemon-or-script.py
</pre></div>
</div>
<hr class="docutils" />
<p>如果读者希望深入了解Python的官方镜像，包括镜像的原始Dockerfile、ONBUILD指令的具体执行内容等，<code class="docutils literal notranslate"><span class="pre">可以参考Github上的docker-library/official-images仓库。</span></code></p>
</section>
<section id="pypy">
<h4>使用PyPy<a class="headerlink" href="#pypy" title="Permalink to this headline">¶</a></h4>
<p>PyPy是一个Python实现的Python解释器和即时编译（JIT）工具，它专注于速度、效率，与CPython完全兼容。PyPy通过JIT技术可以使得Python运行速度提高近十倍，同时保证兼容性。下面介绍如何使用官方镜像。</p>
<p><img alt="image42" src="../_images/docker_pypy00001.png" /></p>
<p>首先，设置项目目录，并新建hi.py实例程序：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">animal</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;mouse&quot;</span><span class="p">]:</span>
    <span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is a mammal&quot;</span> <span class="o">%</span> <span class="n">animal</span>
</pre></div>
</div>
<hr class="docutils" />
<p>然后，在根目录新建Dockerfile，基于pypy3的onbuild版本镜像如下：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">pypy</span><span class="p">:</span><span class="mi">3</span><span class="o">-</span><span class="n">onbuild</span>
<span class="n">CMD</span> <span class="p">[</span> <span class="s2">&quot;pypy3&quot;</span><span class="p">,</span> <span class="s2">&quot;./hi.py&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<hr class="docutils" />
<p>如果用户需要使用pypy2，则可以使用：FROM pypy：2-onbuild。</p>
<p>onbuild版本的镜像内含若干onbuild触发器，它们可以在镜像构建期间完成一些必要的初始化操作，便于项目的直接运行。pypy的onbuild镜像会拷贝一个requirements.txt依赖文件，运行RUN
pip install安装依赖程序，然后将当前目录拷贝至/usr/src/app。</p>
<p>下面，开始构建和运行此镜像：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker build -t my-python-app .
$ docker run -it --rm --name my-running-app my-python-app
</pre></div>
</div>
<hr class="docutils" />
<p>如果用户只需要运行单个pypy脚本，并希望避免新建Dockerfile，那么可以直接使用如下指令：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm --name my-running-script -v &quot;$PWD&quot;:/usr/src/myapp -w /usr/src/myapp pypy:3 pypy3 your-daemon-or-script.py
</pre></div>
</div>
<hr class="docutils" />
<p>如果需要使用pypy2运行，则可以使用如下指令：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm --name my-running-script -v &quot;$PWD&quot;:/usr/src/myapp -w /usr/src/myapp pypy:2 pypy your-daemon-or-script.py
</pre></div>
</div>
</section>
<section id="flask">
<h4>使用Flask<a class="headerlink" href="#flask" title="Permalink to this headline">¶</a></h4>
<p>Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug
WSGI工具箱和Jinja2模板引擎，Flask使用BSD授权。Flask也被称为“microframework”，因为它仅仅使用简单的核心，使用extension来增加其他功能。</p>
<p><img alt="image43" src="../_images/docker_flask00001.png" /></p>
<p>Flask的特色如下：</p>
<p>·内置开发用服务器和debugger；</p>
<p>·集成单元测试（unit testing）；</p>
<p>·RESTful request dispatching；</p>
<p>·使用Jinja2模板引擎；</p>
<p>·支持secure cookies（client side sessions）；</p>
<p>·100%WSGI 1.0兼容；</p>
<p>·基于Unicode</p>
<p>·详细的文件、教学；</p>
<p>·Google App Engine兼容；</p>
<p>·可用Extensions增加其他功能。</p>
<p>Flask是目前广受欢迎的常用Python Web方案之一。</p>
<section id="dockerhub-2">
<span id="id81"></span><h5>1.使用Dockerhub镜像<a class="headerlink" href="#dockerhub-2" title="Permalink to this headline">¶</a></h5>
<p>第一步，项目准备工作：构建Flask App目录：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ tree
.
└── src
    ├── app
    │   ├── __init__.py
    │   ├── __init__.pyc
    │   ├── static
    │   ├── templates
    │   ├── views.py
    │   └── views.pyc
    └── run.py
</pre></div>
</div>
<hr class="docutils" />
<p>run.py内容如下：</p>
<hr class="docutils" />
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="ch">#!flask/bin/python</span>
<span class="kn">from</span> <span class="nn">app</span> <span class="kn">import</span> <span class="n">app</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;Hello World! Yes I do  Yeey&quot;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">&quot;/hujianli&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;This is index! ......&quot;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
<p>_init.py内容如下：</p>
<hr class="docutils" />
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">app</span> <span class="kn">import</span> <span class="n">views</span>
</pre></div>
</div>
<hr class="docutils" />
<p>第二步，获取Docker Hub的Flask镜像：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker pull verdverm/flask
</pre></div>
</div>
<hr class="docutils" />
<p>第三步，创建并运行Flask容器（Flask的App代码作为Docker数据卷）：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d --name flask-app <span class="se">\</span>
    -v /path/to/app/src:/src <span class="se">\</span>
    -p <span class="m">5000</span>:5000 <span class="se">\</span>
    verdverm/flask
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="composeflask-mongodb">
<h5>2.使用Compose构建Flask+MongoDB服务<a class="headerlink" href="#composeflask-mongodb" title="Permalink to this headline">¶</a></h5>
<p>MongoDB是一个基于分布式文件存储的数据库，旨在为Web应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。Flask与MongoDB结合使用，是一种简单高效的Web服务架构，可以以较高的性能支撑图片服务等各种常见Web服务。</p>
<p>第一步，新建mongo-flask项目文件夹，并新建flask框架的核心文件app.py，内容如下：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">render_template</span>
<span class="kn">from</span> <span class="nn">pymongo</span> <span class="kn">import</span> <span class="n">MongoClient</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">MongoClient</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DB_PORT_27017_TCP_ADDR&#39;</span><span class="p">],</span>
        <span class="mi">27017</span><span class="p">)</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">tododb</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">todo</span><span class="p">():</span>
    <span class="n">_items</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">tododb</span><span class="o">.</span><span class="n">find</span><span class="p">()</span>
    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">_items</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;index.html&#39;</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="n">items</span><span class="p">)</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/new&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">new</span><span class="p">():</span>
    <span class="n">item_doc</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
        <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">db</span><span class="o">.</span><span class="n">tododb</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">item_doc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;todo&#39;</span><span class="p">))</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
<p>新建templates文件夹，放置Flask框架的前端模版文件index.html，内容如下：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">form</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;/new&quot;</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;POST&quot;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nb">input</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;text&quot;</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="o">&gt;&lt;/</span><span class="nb">input</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nb">input</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;text&quot;</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;description&quot;</span><span class="o">&gt;&lt;/</span><span class="nb">input</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nb">input</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;submit&quot;</span><span class="o">&gt;&lt;/</span><span class="nb">input</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">form</span><span class="o">&gt;</span>
<span class="p">{</span><span class="o">%</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span> <span class="o">%</span><span class="p">}</span>
<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span> <span class="p">{{</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="p">}}</span> <span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="p">{{</span> <span class="n">item</span><span class="o">.</span><span class="n">description</span> <span class="p">}}</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
<span class="p">{</span><span class="o">%</span> <span class="n">endfor</span> <span class="o">%</span><span class="p">}</span>
</pre></div>
</div>
<hr class="docutils" />
<p>回到项目根目录，新建requirements.txt文件，内容如下：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">flask</span>
<span class="n">pymongo</span>
</pre></div>
</div>
<hr class="docutils" />
<p>新建Dockerfile文件，内容如下：</p>
<hr class="docutils" />
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="c1">#基础镜像</span>
<span class="l l-Scalar l-Scalar-Plain">FROM python:2.7</span>
<span class="l l-Scalar l-Scalar-Plain">ADD . /webdir</span>
<span class="l l-Scalar l-Scalar-Plain">#确定工作目录</span>
<span class="l l-Scalar l-Scalar-Plain">WORKDIR /webdir</span>
<span class="l l-Scalar l-Scalar-Plain">#安装依赖程序</span>
<span class="l l-Scalar l-Scalar-Plain">RUN pip install -r requirements.txt</span>
<span class="l l-Scalar l-Scalar-Plain">#暴露80端口</span>
<span class="l l-Scalar l-Scalar-Plain">EXPOSE 80</span>
<span class="l l-Scalar l-Scalar-Plain">#确定`flask`运行指令</span>
<span class="l l-Scalar l-Scalar-Plain">ENTRYPOINT [&quot;python&quot;, &quot;-u&quot;, &quot;/webdir/app.py&quot;]</span>
</pre></div>
</div>
<hr class="docutils" />
<p>新建docker-compose.yml文件，内容如下：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cat docker-compose.yml
web:
    build: .
    ports:
        - <span class="s2">&quot;80&quot;</span>
    links:
        - db
db:
    image: registry.aliyuncs.com/wangbs/mongodb
    ports:
        - <span class="s2">&quot;27017&quot;</span>
</pre></div>
</div>
<p>镜像已经上传到阿里云，可直接使用的docker-compose.yml文件如下：</p>
<hr class="docutils" />
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">web</span><span class="p">:</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">registry.aliyuncs.com/wangbs/mongo-flask:master</span>
    <span class="nt">ports</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="s">&quot;80&quot;</span>
    <span class="nt">links</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">db</span>
<span class="nt">db</span><span class="p">:</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">registry.aliyuncs.com/wangbs/mongodb</span>
    <span class="nt">ports</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="s">&quot;27017&quot;</span>
</pre></div>
</div>
</section>
</section>
<section id="id82">
<span id="id83"></span><h4>相关资源<a class="headerlink" href="#id82" title="Permalink to this headline">¶</a></h4>
<p>Python的相关资源如下：</p>
<ul class="simple">
<li><p>Python官网：<a class="reference external" href="https://www.python.org/">https://www.python.org/</a></p></li>
<li><p>PyPy官网：<a class="reference external" href="http://pypy.org/">http://pypy.org/</a></p></li>
<li><p>Flask官网：<a class="reference external" href="http://flask.pocoo.org/">http://flask.pocoo.org/</a></p></li>
<li><p>uwsgi官方仓库：<a class="reference external" href="https://github.com/unbit/uwsgi">https://github.com/unbit/uwsgi</a></p></li>
</ul>
</section>
</section>
<section id="javascript">
<h3><a class="toc-backref" href="#id148">6.4 JavaScript</a><a class="headerlink" href="#javascript" title="Permalink to this headline">¶</a></h3>
<p>JavaScript是目前所有主流浏览器上唯一支持的脚本语言，这也是早期JavaScript的唯一用途。Node.js自2009年发布，使用Google
Chrome浏览器的V8引擎。Node.js的出现，让服务端应用也可以基于JavaScript进行编写，它采用事件驱动，性能优异，同时还提供了很多系统级API，如文件操作，Socket、HTTP网络编程等，支持主流操作系统。Node.js应用通过非驻塞IO和异步事件将系统吞吐能力和效率最大化。</p>
<p><img alt="image44" src="../_images/docker_js00001.png" /></p>
<p>下面，笔者将简述如何使用Docker搭建和使用Node.js环境。</p>
<section id="node-js">
<h4>1.使用Node.js<a class="headerlink" href="#node-js" title="Permalink to this headline">¶</a></h4>
<p>在Node环境中，用户可以快速运行一个Node.js的简单应用。</p>
<p><img alt="image45" src="../_images/docker_nodejs.png" /></p>
<p>首先，创建一个helloworld.js文件：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Hello World&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>然后通过node指令执行即可启动Node.js的hello world：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ node helloworld.js
</pre></div>
</div>
<hr class="docutils" />
<p>1.使用DockerHub镜像</p>
<p>Node.js拥有3种官方镜像：node：、node：onbuild、node：slim。其中常用的是带有版本标签的，以及带有onbuild标签的node镜像。</p>
<p>首先，在Node.js项目中新建一个Dockerfile：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">node</span><span class="p">:</span><span class="mi">4</span><span class="o">-</span><span class="n">onbuild</span>
<span class="n">EXPOSE</span> <span class="mi">8888</span>
</pre></div>
</div>
<hr class="docutils" />
<p>然后，新建server.js文件，内容如下：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
<span class="n">var</span> <span class="n">connect</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s1">&#39;connect&#39;</span><span class="p">);</span>
<span class="n">var</span> <span class="n">serveStatic</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s1">&#39;serve-static&#39;</span><span class="p">);</span>
<span class="n">var</span> <span class="n">app</span> <span class="o">=</span> <span class="n">connect</span><span class="p">();</span>
<span class="n">app</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">serveStatic</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;index.html&#39;</span><span class="p">]}));</span>
<span class="n">app</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;MyApp is ready at http://localhost:8080&#39;</span><span class="p">);</span>
</pre></div>
</div>
<hr class="docutils" />
<p>之后，通过npm init命令来新建node项目必须的package.json文件：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.
See &#39;npm help json&#39; for definitive documentation on these fields
and exactly what they do.
Use &#39;npm install &lt;pkg&gt; --save&#39; afterwards to install a package and
save it as a dependency in the package.json file.
Press ^C at any time to quit.
name: (node) node
version: (1.0.0)
description: node-sample
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to /Users/faxi/Docker/js/node/package.json:
{
    &quot;name&quot;: &quot;node&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;node-sample&quot;,
    &quot;main&quot;: &quot;index.js&quot;,
    &quot;scripts&quot;: {
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
    },
    &quot;author&quot;: &quot;&quot;,
    &quot;license&quot;: &quot;ISC&quot;
}
Is this ok? (yes) yes
</pre></div>
</div>
<hr class="docutils" />
<p>下面使用docker build指令构建node镜像：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker build -t node-image .
…
Successfully built f698a32b5d9b
</pre></div>
</div>
<hr class="docutils" />
<p>用户可以通过docker images指令查看已创建的node镜像：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY        TAG        IMAGE ID          CREATED              VIRTUAL SIZE
node-image        latest     f698a32b5d9b      29 seconds ago       642.7 MB
</pre></div>
</div>
<hr class="docutils" />
<p>最后，创建并运行node容器：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run -it -P node-image
MyApp is ready at http://localhost:8080
</pre></div>
</div>
<hr class="docutils" />
<p>此时可以使用浏览器查看到MyApp应用的服务页面，如图14-2所示。</p>
<p><img alt="image46" src="../_images/docker_nodejs02.png" /></p>
<p>图14-2　Node.js容器启动页面</p>
<p>首先，使用docker ps指令查看端口绑定情况：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker ps
CONTAINER ID  IMAGE      COMMAND     CREATED   STATUS PORTS                   NAMES
7b6f666d4808  node-image &quot;npm start&quot; xxxago    Up xx  0.0.0.0:32771-&gt;8888/tcp node-container
</pre></div>
</div>
<hr class="docutils" />
<p>也可以使用curl指令访问：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ curl http://192.168.99.100:32771/
hello, node!
</pre></div>
</div>
<hr class="docutils" />
<p>如果出现无法访问等问题，可以使用entrypoint参数进入容器进行操作：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run --entrypoint bash -it node-image
root@3d845d373a04:/usr/src/app# ls
Dockerfile  index.html    node_modules  package.json  server.js
</pre></div>
</div>
<hr class="docutils" />
<p>如果需要netstat等网络工具，可以在容器内使用以下指令进行安装：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># apt-get update &amp;&amp; apt-get install net-tools</span>
</pre></div>
</div>
<hr class="docutils" />
<p>如果需要查看容器日志，可以使用docker log指令：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker logs &lt;container id&gt;
</pre></div>
</div>
<hr class="docutils" />
<p>如果用户只需要运行单个node脚本的容器，则无须通过Dockerfile构建镜像，用户可以使用以下指令：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm --name my-running-script -v <span class="s2">&quot;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&quot;</span>:/usr/src/myapp -w /usr/src/myapp node:0.10 node your-daemon-or-script.js
</pre></div>
</div>
<hr class="docutils" />
<p>读者也可以参考node官方提供的最佳实践：<a class="reference external" href="https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md">https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md</a>
。</p>
<p>2.使用alpine精简版node镜像</p>
<p>随着Docker官方提供基于alpine精简系统的各类镜像，这种平均大小只有10MB的镜像可以方便地应用于各种开发测试或生产环境中。</p>
<p>首先，新建项目目录并新建Dockerfile：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>FROM alpine:3.3
# ENV VERSION=v0.10.44 CFLAGS=&quot;-D__USE_MISC&quot; NPM_VERSION=2
# ENV VERSION=v0.12.13 NPM_VERSION=2
ENV VERSION=v4.4.4 NPM_VERSION=2
# ENV VERSION=v5.11.1 NPM_VERSION=3
# ENV VERSION=v6.1.0 NPM_VERSION=3
# For base builds
# ENV CONFIG_FLAGS=&quot;--without-npm&quot; RM_DIRS=/usr/include
ENV CONFIG_FLAGS=&quot;--fully-static --without-npm&quot; DEL_PKGS=&quot;libgcc libstdc++&quot; RM_DIRS=/usr/include
RUN apk add --no-cache curl make gcc g++ binutils-gold python linux-headers paxctl libgcc libstdc++ gnupg &amp;&amp; \
    gpg --keyserver pool.sks-keyservers.net --recv-keys 9554F04D7259F04124DE6B476D5A82AC7E37093B &amp;&amp; \
    ...
    curl -o node-${VERSION}.tar.gz -sSL https://nodejs.org/dist/${VERSION}/node-${VERSION}.tar.gz &amp;&amp; \
    curl -o SHASUMS256.txt.asc -sSL https://nodejs.org/dist/${VERSION}/SHASUMS256.txt.asc &amp;&amp; \
    gpg --verify SHASUMS256.txt.asc &amp;&amp; \
    grep node-${VERSION}.tar.gz SHASUMS256.txt.asc | sha256sum -c - &amp;&amp; \
    tar -zxf node-${VERSION}.tar.gz &amp;&amp; \
    cd /node-${VERSION} &amp;&amp; \
    ./configure --prefix=/usr ${CONFIG_FLAGS} &amp;&amp; \
    make -j$(grep -c ^processor /proc/cpuinfo 2&gt;/dev/null || 1) &amp;&amp; \
    make install &amp;&amp; \
...
</pre></div>
</div>
<hr class="docutils" />
<p>然后，用户使用docker build指令构建镜像：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker build -t apline-node .
...
Successfully built 881d3fd0d574
</pre></div>
</div>
<hr class="docutils" />
<p>最后，通过docker[container]run指令运行：</p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run alpine-node node --version
v6.1.0
$ docker run alpine-node npm --version
3.8.8
</pre></div>
</div>
</section>
<section id="id84">
<span id="id85"></span><h4>2.相关资源<a class="headerlink" href="#id84" title="Permalink to this headline">¶</a></h4>
<p>JavaScript和Node.js相关资源如下：</p>
<ul class="simple">
<li><p>JavaScript入门：<a class="reference external" href="http://www.w3schools.com/js/">http://www.w3schools.com/js/</a></p></li>
<li><p>Node.js官网：<a class="reference external" href="http://www.nodejs.org/">http://www.nodejs.org/</a></p></li>
<li><p>Node.js官方镜像：<a class="reference external" href="https://registry.hub.docker.com/_/node/">https://registry.hub.docker.com/_/node/</a></p></li>
<li><p>Node.js官方镜像标签：<a class="reference external" href="https://registry.hub.docker.com/_/node/tags/manage/">https://registry.hub.docker.com/_/node/tags/manage/</a></p></li>
</ul>
</section>
</section>
<section id="go">
<h3><a class="toc-backref" href="#id149">6.5 Go</a><a class="headerlink" href="#go" title="Permalink to this headline">¶</a></h3>
<p>Go语言（也称Golang）是一个由Google主导研发的编程语言，于2009年推出。它的语法清晰明了，设计精良，拥有一些先进的特性，还有一个庞大的标准库。Go的基本设计理念是：编译效率、运行效率和开发效率要三者兼顾。使用Go开发，一方面有很多灵活的语法支持，另一方面可以媲美C/C++的运行和编译效率。此外，Go提供了轻量级的协程，支持大规模并发的场景。</p>
<p><img alt="image47" src="../_images/docker_go000001.png" /></p>
<section id="id86">
<span id="id87"></span><h4>1.使用官方镜像<a class="headerlink" href="#id86" title="Permalink to this headline">¶</a></h4>
<p>运行Go语言环境的最简方法是使用官方Golang镜像。用户可以使用docker
run指令直接启动Go语言的交互环境：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it golang /bin/bash
root@79afc2b64b06:/go# go versiongo version go1.7 linux/amd64
</pre></div>
</div>
<p>用户还可以将Go编译指令写入Dockerfile中，基于此Dockerfile构建自定义镜像。具体步骤如下。</p>
<p>第一步，新建项目文件夹，并在根目录新建Dockerfile：</p>
<p>FROM golang：1.6-onbuild#显示声明基础镜像版本，利于后期维护。</p>
<p>onbuild版本Dockerfile的具体内容如下：</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">golang:1.6</span>
<span class="k">RUN</span> mkdir -p /go/src/app
<span class="k">WORKDIR</span><span class="s"> /go/src/app</span>
<span class="c"># 通过 &#39;go-wrapper&#39; 程序执行当前目录下的主函数ONBUILD</span>
<span class="k">CMD</span> <span class="p">[</span><span class="s2">&quot;go-wrapper&quot;</span><span class="p">,</span> <span class="s2">&quot;run&quot;</span><span class="p">]</span>
<span class="c"># 拷贝当前项目代码至运行目录ONBUILD</span>
<span class="k">COPY</span> . /go/src/app
<span class="c"># 下载依赖，具体实现参考 &#39;go-wrapper&#39;源码ONBUILD</span>
<span class="k">RUN</span> go-wrapper download
<span class="c"># 安装依赖，具体实现参考 &#39;go-wrapper&#39;源码</span>
<span class="k">RUN</span> go-wrapper install
<span class="c"># `go-wrapper`源码地址：`https://github.com/docker-library/golang/blob/master/go-wrapper`</span>
<span class="c"># Dockerfile 源码地址: `https://github.com/docker-library/golang/blob/master/1.6/onbuild/Dockerfile`</span>
</pre></div>
</div>
<p>第二步，新建自定义Go程序go-sample.go：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello, 世界&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>第三步，使用docker build指令构建镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t golang-image .
……
Successfully built d1328c2d5e04
</pre></div>
</div>
<p>可以使用docker images指令查看构建成功的镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY    TAG    IMAGE ID      CREATED              VIRTUAL SIZE
golang-image  latest d1328c2d5e04  About a minute ago   <span class="m">499</span>.2 MB
</pre></div>
</div>
<hr class="docutils" />
<p>第四步，使用docker[container]run指令运行Go容器</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -it --rm --name golang-container golang-image
+ <span class="nb">exec</span> app
Hello, 世界
</pre></div>
</div>
<p>至此用户已经成功运行了Go语言的实例容器。如果用户需要在容器中编译Go代码，但是不需要在容器中运行它，那么可以执行：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --rm -v <span class="s2">&quot;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&quot;</span>:/usr/src/myapp -w /usr/src/myapp golang go build -v _/usr/src/myapp
</pre></div>
</div>
<p>以上指令会将Go项目文件夹作为Docker数据卷挂载起来并作为运行目录。</p>
<p>然后，Docker会在工作目录中编译代码，执行go
build并输出可执行文件至myapp。</p>
<p>如果项目含有Makefile，那么用户可以在容器中执行：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --rm -v <span class="s2">&quot;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&quot;</span>:/usr/src/myapp -w /usr/src/myapp golang make
</pre></div>
</div>
<p>如果此时Go没有找到Makefile，则会显示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span><span class="p">:</span> <span class="o">***</span> <span class="n">No</span> <span class="n">targets</span> <span class="n">specified</span> <span class="ow">and</span> <span class="n">no</span> <span class="n">makefile</span> <span class="n">found</span><span class="o">.</span>  <span class="n">Stop</span><span class="o">.</span>
</pre></div>
</div>
<p>如果需要在常用的<code class="docutils literal notranslate"><span class="pre">linux\amd64</span></code>架构之外的其他架构的平台（如windows/386）编译Go应用，则可以在指令中加入cross标签：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --rm -v <span class="s2">&quot;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&quot;</span>:/usr/src/myapp -w /usr/src/myapp -e <span class="nv">GOOS</span><span class="o">=</span>windows -e <span class="nv">GOARCH</span><span class="o">=</span><span class="m">386</span> golang:1.3.1-cross go build -v
</pre></div>
</div>
</section>
<section id="id88">
<h4>2.Go项目容器化<a class="headerlink" href="#id88" title="Permalink to this headline">¶</a></h4>
<p>上一节，用户讲述了如何运行一个Go语言的hello
world容器。下面用户讲述如何将一个标准的Go语言项目容器化。首先，用户下载Golang官方提供的outyet示例项目：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ mkdir outyet
$ <span class="nb">cd</span> outyet
<span class="c1"># 使用 go get 下载：</span>
$ go get github.com/golang/example/outyet
<span class="c1"># 或者直接使用wget下载：</span>
$ wget https://github.com/golang/example/archive/master.zip
$ unzip master.zip
$ <span class="nb">cd</span> example-master/outyet
$ ls
Dockerfile      containers.yaml main.go         main_test.go
</pre></div>
</div>
<p>示例项目搭建成功后，用户可以按照以下模板去自定义项目的Dockerfile：</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="c"># 使用golang基础镜像。基于Debian系统，安装最新版本的golang环境。工作空间（GOPATH）配置是&quot;/go&quot;</span>
<span class="k">FROM</span> <span class="s">golang</span>
<span class="c"># 将本地的包文件拷贝至容器工作目录。</span>
<span class="k">ADD</span> . /go/src/github.com/golang/example/my-go
<span class="c"># 在容器中构建my-go。用户可以在这里手动或者自动（godep）的管理依赖关系。</span>
<span class="k">RUN</span> go install github.com/golang/example/my-go
<span class="c"># 设定容器自动时自动运行my-go。</span>
<span class="k">ENTRYPOINT</span> /go/bin/my-go-app
<span class="c"># 监听8080端口。</span>
<span class="k">EXPOSE</span><span class="s"> 8080</span>
</pre></div>
</div>
<p>如果使用onbuild版本的基础镜像，那么源文件拷贝，构建与配置等过程就会自动完成，无须在Dockerfile中逐一配置：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>FROM golang:onbuild
EXPOSE <span class="m">8080</span>
</pre></div>
</div>
<p>下面用户开始构建与运行此Golang项目。用户在outyet项目根目录执行docker
build指令，使用本地目录下的Dockerfile：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span> docker build -t outyet .
...
Successfully built 96e19c2cf942
</pre></div>
</div>
<hr class="docutils" />
<p>构建过程中，Docker会从DockerHub中获取Golang基础镜像，拷贝本地包文件，构建项目并给镜像打上outyet标签。下面，用户使用docker
run指令运行此镜像：</p>
<hr class="docutils" />
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --publish <span class="m">6060</span>:8080 --name <span class="nb">test</span> --rm outyet
<span class="c1">#  --publish 标签配置端口映射，将容器的8080端口映射至外部6060端口。</span>
<span class="c1">#  --name 标签给容器命名，易于调用。</span>
<span class="c1">#  --rm 标签配置运行状态，如果 outyet 服务退出则删除镜像。</span>
</pre></div>
</div>
<hr class="docutils" />
<p>此时，用户的实例项目的容器已经在运行状态。用户打开浏览器访问<a class="reference external" href="http://localhost:6060/">http://localhost:6060/</a>
即可看到运行界面。</p>
<p>Golang示例项目运行界面</p>
<p><img alt="image48" src="../_images/docker_go000002.png" /></p>
<p>需要结束容器时，打开新的命令行窗口，输入docker stop
test即可。如果需要了解更多Golang项目容器化细节，可以参考Golang官方提供的容器化指引：<a class="reference external" href="https://blog.golang.org/docker">https://blog.golang.org/docker</a>
。</p>
</section>
<section id="id89">
<span id="id90"></span><h4>3.相关资源<a class="headerlink" href="#id89" title="Permalink to this headline">¶</a></h4>
<p>Go语言相关资源如下：</p>
<ul class="simple">
<li><p>Go语言官站：<a class="reference external" href="https://golang.org">https://golang.org</a></p></li>
<li><p>Go官方镜像：<a class="reference external" href="https://registry.hub.docker.com/_/golang/">https://registry.hub.docker.com/_/golang/</a></p></li>
<li><p>Google Go镜像：<a class="reference external" href="https://registry.hub.docker.com/u/google/golang/">https://registry.hub.docker.com/u/google/golang/</a></p></li>
</ul>
</section>
</section>
</section>
<section id="id91">
<h2><a class="toc-backref" href="#id150">7.容器与云服务</a><a class="headerlink" href="#id91" title="Permalink to this headline">¶</a></h2>
<p>Docker目前已经得到了众多公有云平台的支持，并成为除虚拟机之外的核心云业务。除了AWS、Google、Azure、Docker官方云服务等，国内的各大公有云厂商，基本上也都已支持了容器服务，有些甚至还专门推出了容器云业务。</p>
<p>本章将介绍国际和国内知名的公共云容器服务以及容器云的现状、功能与特性，并以阿里云和时速云为例讲解具体使用过程，方便希望使用云服务的读者进行选型。</p>
<section id="id92">
<h3><a class="toc-backref" href="#id151">7.1 公有云容器服务</a><a class="headerlink" href="#id92" title="Permalink to this headline">¶</a></h3>
<p>公有云（Public Cloud）是标准云计算（Cloud
Computing）的一种服务模式。服务供应商创造公有计算资源，如网络和存储资源。公众与企业可以通过公共网络获取这些资源。目前国内已经有很多公有云厂商，他们都提供可以运行Docker环境的虚拟机，同时一部分公有云厂商已经发布了自己的容器服务。</p>
<section id="aws">
<h4>1. AWS<a class="headerlink" href="#aws" title="Permalink to this headline">¶</a></h4>
<p>AWS（Amazon Web
Services）是亚马逊公司的IaaS和PaaS平台服务。AWS提供了一整套基础设施和应用程序服务，使用户几乎能够在云中运行一切应用程序：从企业应用程序和大数据项目，到社交游戏和移动应用程序。AWS面向用户提供包括弹性计算、存储、数据库、应用程序在内的一整套云计算服务，能够帮助企业降低IT投入成本和维护成本。</p>
<p><img alt="image49" src="../_images/docker_aws00001.png" /></p>
<p>自2006年初起，亚马逊AWS开始在云中为各种规模的公司提供技术服务平台。利用亚马逊AWS，软件开发人员可以轻松购买计算、存储、数据库和其他基于Internet的服务来支持其应用程序。开发人员能够灵活选择任何开发平台或编程环境，以便于其尝试解决问题。由于开发人员只需按使用量付费，无须前期资本支出，亚马逊AWS是向最终用户交付计算资源、保存的数据和其他应用程序的一种经济划算的方式。</p>
<p>2015年AWS正式发布了EC2容器服务（ECS），如图15-1所示。ECS的目的是让Docker容器变得更加简单，它提供了一个集群和编排的层，用来控制主机上的容器部署，以及部署之后集群内的容器生命周期管理。ECS是诸如Docker
Swarm、Kubernetes、Mesos等工具的替代，都工作在同一个层，但ECS是作为一个服务来提供的。这些工具和ECS不同的地方在于，前者需要用户自己来部署和管理，而ECS是“作为服务”来提供的。</p>
<p>AWS容器服务</p>
<p><img alt="image50" src="../_images/docker_aws00002.png" /></p>
</section>
<section id="google-cloud-platform">
<h4>2. Google Cloud Platform<a class="headerlink" href="#google-cloud-platform" title="Permalink to this headline">¶</a></h4>
<p><img alt="image51" src="../_images/docker_google00001.png" /></p>
<p>谷歌云（Google Cloud
Platform，GCP）提供了丰富全面的云产品，可以让企业专注于自己的业务，而将IT底层架构托管给谷歌。谷歌云平台支持App引擎、容器引擎、容器仓库，还支持丰富的数据库、网络、安全、大数据，甚至机器学习产品。Google云平台发布了Google容器引擎，图15-2描述了如何在开发场景中使用Google容器引擎。</p>
<p>Google容器引擎有以下特性：</p>
<p>·自动化容器管理：Google容器引擎是一个强大的集群管理和编排系统，可以按需将Docker容器编排至集群中自动运行，同时可以自定义CPU和内存等配置。此引擎基于Kubernetes，可以提供弹性、高可用的云基础服务；</p>
<p>·分钟级构建集群：使用谷歌容器服务，用户可以在分钟级别构建完整的集群，包含健康检查、日志服务以及应用管理系统；</p>
<p>·弹性与开源：Red Hat、Microsoft、IBM、Mirantis
OpenStack以及VMware都完成了它们的系统与Kubernetes的兼容或集成。用户可以平滑搭建混合云，也可以平滑迁移系统到云上。</p>
<p>GCP容器服务的开发场景</p>
<p><img alt="image52" src="../_images/docker_google00002.png" /></p>
</section>
<section id="azure">
<h4>3. Azure<a class="headerlink" href="#azure" title="Permalink to this headline">¶</a></h4>
<p>微软Azure在国内是由世纪互联运营的，它是在中国大陆独立运营的公有云平台，与全球其他地区由微软运营的Azure服务在物理上和逻辑上是独立的。采用微软服务于全球的Azure技术，为客户提供全球一致的服务质量保障。位于上海和北京的数据中心在距离相隔1000公里以上的地理位置提供异地复制，为Azure服务提供了业务连续性支持，实现了数据的可靠性。</p>
<p>在容器方面，从2014年开始，Azure首先采取了在Linux虚拟机上兼容Docker的方式来吸引社区的开发者。2014年进一步宣布与Google和Docker合作，以此支持Kubernetes和Swarm开源项目在其云平台上的运行。Docker官方也推出了Docker
Machine的Azure版本。2015年，Azure发布了容器服务（Azure Container
Service，ACS），同时支持Docker Swarm和Apache Mesos集群编排工具。</p>
<p>ACS具有以下特点：</p>
<p>·创建托管解决方案的优化型容器：为Azure优化了常用开源工具和技术的配置，获得的开放解决方案为容器和应用程序配置提供可移植性。用户只需选择大小、主机数和Orchestrator工具选项，容器服务会自动处理所有其他事项；</p>
<p>·使用熟悉的工具管理容器应用程序：将容器工作负荷迁移到云时，无须更改现有的管理措施。使用用户所熟悉的应用程序管理工具，通过标准的适用于所选Orchestrator的API终结点进行连接；</p>
<p>·使用DC/OS或Docker
Swarm进行缩放和协调：选择最能满足Docker容器业务流程和缩放操作需求的工具和解决方案。使用基于Mesos的DC/OS，或者使用Docker
Swarm和Compose以获得纯粹的Docker体验；</p>
<p>·使用常用的开源工具：使用用户了解的开源工具。因为ACS公开了业务流程引擎的标准API终结点，所以最常用的工具将与Azure容器服务兼容，且大多数情况是现成可用的，包括可视化工具、监视工具、持续集成工具、命令行工具甚至未来将推出的工具；</p>
<p>·通过Azure来回迁移容器工作负荷：单个容器可移植并不意味着应用程序可移植。Azure容器服务在业务流程层中仅使用开放源组件为完整应用程序（而不仅是单个容器）提供可移植性，以便用户能随意与Azure进行无缝来回迁移。</p>
</section>
<section id="id93">
<h4>4. 腾讯云<a class="headerlink" href="#id93" title="Permalink to this headline">¶</a></h4>
<p>腾讯云在架构方面经过多年积累，有着多年对海量互联网服务的经验。不管是社交、游戏还是其他领域，都有多年的成熟产品来提供产品服务。腾讯在云端完成重要部署，为开发者及企业提供云服务、云数据、云运营等整体一站式服务方案。</p>
<p>具体包括云服务器、云存储、云数据库和弹性Web引擎等基础云服务；腾讯云分析（MTA）、腾讯云推送（信鸽）等腾讯整体大数据能力；以及QQ互联、QQ空间、微云、微社区等云端链接社交体系。这些正是腾讯云可以提供给这个行业的差异化优势，造就了可支持各种互联网使用场景的高品质的腾讯云技术平台。</p>
<p>2015年1月6日，腾讯云正式宣布成支持Docker
Machine，并将自身定位于Docker基础设施的服务商。与此同时，在支持Docker
Machine前提下，腾讯云也推出了常用系统的标准版Docker镜像，方便用户创建容器。</p>
</section>
<section id="id94">
<h4>5. 阿里云<a class="headerlink" href="#id94" title="Permalink to this headline">¶</a></h4>
<p>阿里云创立于2009年，是中国较早的云计算平台。阿里云致力于提供安全、可靠的计算和数据处理能力。阿里云的客户群体中，活跃着微博、知乎、魅族、锤子科技、小咖秀等一大批明星互联网公司。在天猫双11全球狂欢节等极富挑战的应用场景中，阿里云保持着良好的运行纪录。</p>
<p><img alt="image53" src="../_images/docker_aliyun0001.png" /></p>
<p>阿里云容器服务提供了高性能、可伸缩的容器应用管理服务，支持在一组云服务器上通过Docker容器来进行应用生命周期管理。容器服务极大简化了用户对容器管理集群的搭建工作，无缝整合了阿里云虚拟化、存储、网络和安全能力。容器服务提供了多种应用发布方式和流水线般的持续交付能力，原生支持微服务架构，助力用户无缝上云和跨云管理。</p>
</section>
<section id="id95">
<h4>6. 华为云<a class="headerlink" href="#id95" title="Permalink to this headline">¶</a></h4>
<p>华为云已经正式推出了云容器服务CCE（Cloud Container
Engine，云容器引擎），该服务基于以Docker为代表的容器技术，旨在提供从开发、构建、部署/托管、监控、弹性伸缩、故障恢复等全生命周期的一站式解决方案。CCE容器引擎自上线以来，已经在多个行业市场取得重大进展，在互联网、金融、政企等领域与多家合作伙伴达成合作。</p>
<p><img alt="image54" src="../_images/docker_huawei00001.png" /></p>
<p>通过CCE容器引擎，可以创建自己的私有集群，系统支持容器集群的全生命周期管理和可视化监控运维。还可以秒级构建不同形态和规模的应用程序，兼容业界Docker等生态，并支持应用的弹性伸缩和丰富的监控告警服务，参见图</p>
<p>华为云CCE产品架构</p>
<p><img alt="image55" src="../_images/docker_huawei00002.png" /></p>
<p>CCE主要功能包括：</p>
<p>·容器镜像仓库：支持私有、公有镜像仓库；</p>
<p>·容器集群管理：支持大规模集群和高性能并发部署；</p>
<p>·图形化编排工具：图形化编排部署，轻松拖拽定义复杂应用的容器编排部署，降低用户使用门槛；</p>
<p>·自动化运维管理：基于容器服务实现自动化运维，基于实时日志快速定位问题，界面化操作和短信通知实现24小时自动监控。</p>
<p>CCE容器引擎具有以下特点：</p>
<p>·敏捷高效：一键创建容器集群，秒级启动海量Docker容器；</p>
<p>·高安全性：用户私享专属容器集群，量身打造容器安全解决方案；</p>
<p>·简单易用：提供简单、直观的图形化编排工具，可视化设计各种应用；</p>
<p>·容器监控：支持自动化的容器管理、故障自动恢复；支持容器弹性伸缩，以满足用户对计算能力和容量的需求，对业务不产生任何影响。</p>
</section>
<section id="ucloud">
<h4>7. UCloud<a class="headerlink" href="#ucloud" title="Permalink to this headline">¶</a></h4>
<p>UCloud是基础云计算服务提供商，长期专注于移动互联网领域，深度了解移动互联网业务场景和用户需求。针对特定场景，UCloud通过自主研发提供一系列专业解决方案，包括计算资源、存储资源和网络资源等企业必须的基础IT架构服务，满足互联网研发团队在不同场景下的各类需求。已有数千家移动互联网团队将其核心业务迁移至UCloud云计算服务平台上。依托位于国内、亚太、北美的全球10大数据中心以及北、上、广、深、杭等全国11地线下服务站，UCloud已为近4万家企业级客户提供服务。</p>
<p><img alt="image56" src="../_images/docker_ucloud0001.png" /></p>
<p>UCloud容器集群服务是可灵活便捷使用的容器服务，资源可分布于多个可用区，具有更高容灾能力。支持用户自由创建管理，可以灵活绑定一个或多个EIP并具有独立的内网IP及独立的防火墙。</p>
<p>主要优势如下：</p>
<ul class="simple">
<li><p>独立内网IP：每个容器均有独立内网IP，与云主机、物理机、数据库等的内网通信方便快捷；</p></li>
<li><p>独立公网IP：容器允许绑定外网EIP，甚至多个EIP，需要时可直接对外提供服务；</p></li>
<li><p>独立防火墙：每个容器可独立绑定防火墙，更具业务灵活性；</p></li>
<li><p>跨可用区容灾：容器集群为地域级产品，资源可分布于多个可用区，具有更高容灾能力。</p></li>
</ul>
<p>UDocker的功能如下：</p>
<ul class="simple">
<li><p>资源池管理：允许创建和管理多个资源池，资源池可以添加和删除节点，允许不同配置的节点资源池支持外网且多个资源池可共享外网带宽；</p></li>
<li><p>节点管理：允许创建和添加多个节点，允许不同配置的节点，节点支持开启、关闭、删除等操作；</p></li>
<li><p>容器管理：允许在节点上批量创建和删除容器，每个容器都拥有独立内网IP，容器可以绑定EIP，容器可以配制防火墙；</p></li>
<li><p>监控信息：节点和容器都拥有独立完整的监控信息，如CPU利用率、内存利用率、磁盘IO、网络IO等。</p></li>
</ul>
</section>
</section>
<section id="id96">
<h3><a class="toc-backref" href="#id152">7.2 容器云服务</a><a class="headerlink" href="#id96" title="Permalink to this headline">¶</a></h3>
<p>容器即服务（Contaner as a
Service，CaaS）可以按需提供容器化环境和应用服务。具体说来，CaaS提供一个受控的、安全的应用环境，让开发人员以自助的方式构建和部署应用。</p>
<section id="id97">
<h4>1.基本要素与关键特性<a class="headerlink" href="#id97" title="Permalink to this headline">¶</a></h4>
<p>一般而言，CaaS应该可以提供容器运行的平台，并管理容器所需资源；基于IaaS提供灵活的网络与部署能力，支持多租户，支持高弹性。具体而言，CaaS有以下基本要素：</p>
<ul class="simple">
<li><p>容器调度：调度和管理容器；</p></li>
<li><p>服务发现：将容器化的服务，注册到服务发现工具，确保服务之间的通信；</p></li>
<li><p>网络配置：用户可访问容器，并实现跨主机容器通信；</p></li>
<li><p>安全配置：只开放容器监听的端口；</p></li>
<li><p>负载均衡：避免单点过载；</p></li>
<li><p>数据持久化：容器内数据云端持久化；</p></li>
<li><p>容错与高可用：日志与管理，容器监控。</p></li>
</ul>
<p>CaaS的关键特性：</p>
<ul class="simple">
<li><p>开发角色和运维角色的进一步有机融合；</p></li>
<li><p>容器化应用程序生命周期的所有阶段；</p></li>
<li><p>让开发者更加关注构建应用本身，而无须关注运行环境；</p></li>
<li><p>支持多种底层基础设施，包括多种操作系统和平台；</p></li>
<li><p>API变得越来越重要，不同服务之间通过API相互调用</p></li>
</ul>
</section>
<section id="id98">
<h4>2.网易蜂巢<a class="headerlink" href="#id98" title="Permalink to this headline">¶</a></h4>
<p>网易蜂巢是网易基于自研IaaS平台深度优化，推出的一款采用Docker容器化技术的新一代云计算平台，全面助力加速研发全流程，架构图参见图15-5。拥有BGP多线接入，全万兆网络，全SSD存储等优质硬件资源，自底向上确保安全、极速、稳定的研发体验。网易蜂巢主要提供三大产品：</p>
<p><img alt="image57" src="../_images/docker_wangyifengcao00001.png" /></p>
<p>·容器云：蜂巢提供企业级的容器云平台，支持应用集群一键部署，云计算资源弹性扩展，Docker官方镜像加速。此外蜂巢还支持负载均衡以及镜像仓库服务；</p>
<p>·平台服务：蜂巢提供高性能、高可用、高可靠的数据库和缓存服务，与容器云相辅相成，让开发者可以专注于应用开发和业务发展。此外蜂巢平台服务还提供对象存储以及安全服务；</p>
<p>·运维工具：蜂巢提供性能监控、报警，日志采集等运维工具，提升开发、运维效率，同时提供OpenAPI，灵活管理资源。</p>
<p>容器是蜂巢提供的计算资源最小单位，而要实现一个可水平扩展的产品服务端架构，则需要引入集群的概念，在网易蜂巢中称之为“服务”，集群的运维如发布、回滚、扩容、缩容以及集群的成员管理需要引入编排服务来实现。网易蜂巢的编排服务基于开源项目Kubernetes，编排服务将受控的资源抽象为三个层次：</p>
<p>·容器：软件及运行环境；</p>
<p>·Pod：相关联的容器的组合，相互间通信无须跨网络，例如应用服务器和本地缓存，可以容纳一个或多个容器；</p>
<p>·Node：提供计算、网络、存储的资源节点，可以容纳一个或多个Pod。</p>
</section>
<section id="id99">
<h4>3.时速云<a class="headerlink" href="#id99" title="Permalink to this headline">¶</a></h4>
<p>时速云是国内领先的容器云平台和解决方案提供商。基于Docker为代表的容器技术，为开发者和企业提供应用的镜像构建、发布、持续集成/交付、容器部署、运维管理的新一代云计算平台。其中包括标准化、高可用的镜像构建，存储服务、大规模、可伸缩的容器托管服务，及自有主机集群混合云服务。时速云致力打造下一代以应用为中心的云计算平台，帮助客户优化开发运维环节，提高业务效率，降低IT成本，实现持续创新。</p>
<p>网易蜂巢CaaS架构示意图</p>
<p><img alt="image58" src="../_images/docker_shisu00001.png" /></p>
<p><img alt="image59" src="../_images/docker_shishu000002.png" /></p>
<p>时速云做基于Kubernetes的CaaS平台，以容器化应用作为交付的标准，立足于公有云，为开发者和企业提供了一个快速构建、集成、部署、运行容器化应用的平台，帮助开发者和企业提高应用开发的迭代效率，简化运维环节，降低运维成本。客户包括华大基因、京东方、中国移动、新浪、腾讯等重量级用户。</p>
<p>时速云拥有四大核心产品线，包括：</p>
<p>·企业级容器云平台：兼具IaaS的便利，PaaS的简单，原生集群快速创建，上千节点集群的快速调度、部署；</p>
<p>·企业级镜像仓库：集群化部署、多角色权限控制、集成企业LDAP、增强扩展组件、可视化管理；</p>
<p>·持续集成和持续交付（CI/CD）：轻松云端构建、定制集成、部署规则、事件触发定义、关键环节审核；</p>
<p>·镜像及安全服务中心：多层次镜像扫描、服务安全防护、可视化审查、第三方规则接入。</p>
</section>
<section id="daocloud">
<h4>4.DaoCloud<a class="headerlink" href="#daocloud" title="Permalink to this headline">¶</a></h4>
<p>DaoCloud成立于2014年末，是新一代容器云计算领域的知名企业。DaoCloud产品线涵盖互联网应用的开发、交付、运维和运营全生命周期，并提供公有云、混合云和私有云等多种交付方式。核心团队由来自微软、EMC、VMware等知名企业的高管和技术专家组成，公司总部位于中国上海。</p>
<p><img alt="image60" src="../_images/docker_daocloud000001.png" /></p>
<p>除了公有云服务开始商用之外，DaoCloud还公布了面向大型企业用户，以混合云方式交付的托管云和私有云服务。在企业既有IT框架内，针对具体企业业务需求，定制高度可控的跨云跨网的混合式容器云平台（参见图15-6），帮助企业打造支撑互联网级业务的基础设施。</p>
<p>DaoCloud对国内容器技术社区有不间断的技术和资源投入，Docker
Hub加速器在国内被开发者广泛使用，并承诺为开发者提供永久免费的社区资源服务。</p>
<p>DaoCloud CaaS平台 <img alt="image61" src="../_images/docker_daocloud_caas001.png" /></p>
</section>
<section id="id100">
<h4>5.灵雀云<a class="headerlink" href="#id100" title="Permalink to this headline">¶</a></h4>
<p>灵雀云（Alauda）成立于2014年10月，总部位于美国西雅图市，是微软创投加速器成员。云雀科技致力于提供简单快捷的云平台和服务，帮助客户提高开发部署效率，降低客户IT成本，并使客户可以专注于核心业务。云雀科技产品线以容器这个新一代应用交付件为中心，全方位支持云端应用创建、编译、集成、部署、运行的每一个环节。</p>
<p><img alt="image62" src="../_images/doker_alauda00001.png" /></p>
<p>灵雀云产品线包括Docker托管服务和镜像服务。Docker托管服务提供高效、高可用的运行环境，并支持自动化部署，还提供自动修复、自动扩展、负载均衡等服务，并在此基础之上提供可扩展的监控、日志管理系统。镜像服务提供高性能本地Registry服务用于创建私有、公有镜像仓库，提供上传、下载、构建及托管的全方位镜像服务。目前，灵雀云已经在北京区，上海区和香港区搭建了基于Azure的CaaS服务体系，其架构参见图</p>
<p>灵雀云容器服务架构</p>
<p><img alt="image63" src="../_images/docker_lingque00001.png" /></p>
</section>
<section id="id101">
<h4>6.数人云<a class="headerlink" href="#id101" title="Permalink to this headline">¶</a></h4>
<p>数人云由原Google架构师王璞博士于2014年创立，其核心团队来自于Google、RedHat和HP。数人科技致力于打造下一代轻量级PaaS平台（DCOS），将应用弹性做到极致，DCOS架构参见图15-8。“数人云”是一款部署在公有云、私有云以及混合云之上的企业级云操作系统，旨在帮助用户在云端快速建立并稳定运行一个高性能生产环境，将应用弹性做到极致，实现一站式的微服务架构集群系统。</p>
<p><img alt="image64" src="../_images/docker_shuren00001.png" /></p>
<p>“数人云”的云操作系统是一款部署在公有云或者私有云（IDC）之上的应用运维软件，旨在帮助用户在云端快速建立并稳定运维一个高性能生产环境。基于领先的Mesos和Docker技术，数人云可为用户的业务系统带来高可用的服务质量、快速的性能伸缩、高效的资源利用以及便捷的可视化管理和监控；同时，数人云保证用户的计算资源和数据完全为用户私有可控。</p>
<p>数人云DCOS</p>
<p><img alt="image65" src="../_images/docker_shurenren001.png" /></p>
</section>
</section>
<section id="id102">
<h3><a class="toc-backref" href="#id153">7.3 阿里云容器服务</a><a class="headerlink" href="#id102" title="Permalink to this headline">¶</a></h3>
<p>ACS（Alicloud Container
Service，阿里云容器服务）是一种高性能可伸缩的容器管理服务，支持在一组云服务器上通过Docker容器来运行或编排应用。ACS让用户可以轻松地进行容器管理集群的搭建。此外，ACS整合了负载均衡、专有网络等丰富的阿里云工具，足以支撑企业级IT架构的云化、容器化、微服务化。用户还可以通过阿里云控制台或Restful
API（兼容Docker API）进行容器生命周期管理。</p>
<p><img alt="image66" src="../_images/docker_aliyun00001.png" /></p>
<p>ACS容器服务具有以下优势：</p>
<p>·简单易用：一键创建容器集群，全兼容Docker
Compose模板编排应用，支持图形化界面和Open
API，一站式网络、存储、日志、监控、调度、路由和持续发布管理；</p>
<p>·安全可控：用户拥有并独占云服务器，支持定制安全组和专有网络VPC安全规则，集群级别基于证书的认证体系，支持证书刷新，容器级别的资源隔离和流控，支持集群级别和子账号级别的权限管理；</p>
<p>·协议兼容：兼容标准Docker Swarm
API，支持应用无缝迁云、混合云场景，兼容Docker
Compose模板协议，支持通过API对接实现第三方的调度下发和系统集成；</p>
<p>·高效可靠：支持海量容器秒级启动，支持容器的异常恢复和自动伸缩，支持跨可用区的高可用。</p>
<p>1.Web应用容器化部署</p>
<p>主要功能包括：</p>
<p>Web应用容器化部署架构</p>
<p><img alt="image67" src="../_images/docker_web00001.png" /></p>
<p>·容器服务支持自动化地配置负载均衡SLB和后端云服务器ECS，通过选择Web应用对应的Docker镜像，一键部署；</p>
<p>·支持多种灰度发布策略，包括蓝绿发布和金丝雀发布，保证应用平滑升级；</p>
<p>·支持查看容器和系统等不同维度的监控，并配置扩容和弹性伸缩的策略；</p>
<p>·支持通过声明的方式配置后端的数据库等云服务。</p>
<p>2.持续集成系统构建</p>
<p>主要功能架构参见图15-10，说明如下：</p>
<p>·在阿里云容器镜像服务创建一个自动构建类型的镜像仓库，选择关联代码源到Github或云Code。当代码提交后，会触发Docker镜像的自动构建。</p>
<p>·在镜像Webhook里配置容器服务的trigger
API，这样当镜像构建完毕后，就会触发容器的自动部署，实现流水线般的持续集成和持续交付。</p>
<p>持续集成架构</p>
<p><img alt="image68" src="../_images/docker_cicd00001.png" /></p>
<p>3.微服务架构系统构建</p>
<p>微服务架构系统构建架构参见图</p>
<p>15-11，说明如下：</p>
<p>·将用户现有的系统从业务领域或横向扩展等维度拆分成多个微服务，每个微服务的内容用一个镜像管理；</p>
<p>·通过Docker
Compose编排模板描述微服务之间的依赖关系和配置，在容器服务选择编排模板一键创建应用。</p>
<p>微服务架构系统构建架构</p>
<p><img alt="image69" src="../_images/docker_aliyun00002.png" /></p>
<p>4.常用工具</p>
<p>为了进一步提高容器服务的易用性和可用性，阿里云容器服务提供了许多常用工具，如阿里云版本docker-machine、阿里云容器加速器、阿里云容器Hub服务等。</p>
<p>如果想要了解更多信息，可以访问阿里云官方网站：<a class="reference external" href="https://www.aliyun.com/">https://www.aliyun.com</a>
。</p>
</section>
<section id="id103">
<h3><a class="toc-backref" href="#id154">7.4 时速云介绍</a><a class="headerlink" href="#id103" title="Permalink to this headline">¶</a></h3>
<p>时速云成立于2014年10月，是新一代容器云计算领域的领军企业，业务涵盖容器PaaS平台、DevOps、微服务治理、AIOps等领域。时速云是国内首个基于Kubernetes的企业级容器PaaS平台，2018年1月公司完成近亿元B轮融资，公司的核心使命是通过容器云计算帮助企业实现数字化转型。时速云拥有金融、能源、运营商、制造、广电、汽车等领域的诸多大型企业及世界500强客户。时速云总部位于中国北京，并设立了上海、深圳、广州、武汉等分支机构。</p>
<p>时速云是全球云原生应用CNCF基金会银牌会员，也是Linux基金会会员，以及开源容器编排技术Kubernetes、容器引擎Docker、分布式存储Ceph等的贡献者。2017年3月，时速云成功加入中国开源云联盟组织以及超融合联盟。公司拥有多名Kubernetes、Docker等开源技术的核心源码贡献者，是国内第一家从事Kubernetes研发与应用的公司。</p>
<p>时速云的产品体系以容器技术为核心，围绕PaaS、DevOps、微服务帮助企业IT提升业务应用的快速交付，给企业应用架构带来更高的灵活性和敏捷性，其架构如图15-12所示。包含如下解决方案。</p>
<section id="paas">
<h4>1.企业级容器PaaS平台<a class="headerlink" href="#paas" title="Permalink to this headline">¶</a></h4>
<p>基于容器技术打造云原生的容器PaaS产品，立足企业开发、测试及IT管理需求，提供一站式容器云平台，从而帮助企业IT数字化转型，为企业提供轻量、快速、高效、更友好的服务运行及开发环境。</p>
</section>
<section id="devops">
<h4>2.开发运维一体化DevOps<a class="headerlink" href="#devops" title="Permalink to this headline">¶</a></h4>
<p>提供自动化的持续集成能力（包括代码构建、代码分析、自动测试、编译环境、文档生成、事件通知、定时器、人工审核等），帮助用户尽早发现集成错误，实现人工干预，让开发运维协调一致，优化企业应用交付流程。</p>
<p>时速云架构</p>
<p><img alt="image70" src="../_images/docker_shisucloudjiagou00001.png" /></p>
</section>
<section id="id104">
<h4>3.微服务治理<a class="headerlink" href="#id104" title="Permalink to this headline">¶</a></h4>
<p>时速云微服务治理平台是基于Spring
Cloud和Pinpoint等开源组件开发的面向企业的容器化微服务架构应用托管平台，帮助企业简化部署、监控、运维、治理与微服务生命周期的管理，并实现不同环境之间的跨系统、跨协议的服务互通。</p>
</section>
<section id="id105">
<h4>4.容器超融合一体机<a class="headerlink" href="#id105" title="Permalink to this headline">¶</a></h4>
<p>超融合基础架构（Hyper-Converged
Infrastructure，HCI）是指在同一套单元设备中不仅仅具备计算、网络、存储和服务器虚拟化等资源和技术，形成统一的资源池。目前超融合一体机产品更适合部署在企业内部的IT系统中，在为企业提供相关IT服务的同时，为企业降低运维综合成本，提供更加高可靠、高可用的IT基础设施。</p>
<p>如果希望了解关于时速云的更多信息，可以访问其官方网站：<a class="reference external" href="https://www.tenxcloud.com/">https://www.tenxcloud.com</a>
。</p>
</section>
</section>
</section>
<section id="id106">
<h2><a class="toc-backref" href="#id155">8.容器实战思考</a><a class="headerlink" href="#id106" title="Permalink to this headline">¶</a></h2>
<p>在开发和运维实践中大量使用容器技术之后，相信读者都会产生或多或少的心得体会。此时进行经验总结十分有必要。</p>
<p>在本章中，笔者将分享自己在容器实践中的一些思考体会，包括Docker之所以能成功的根本原因，作为开发人员该如何看待容器，DevOps团队该如何使用容器，以及生产环境中部署容器的一些技巧等。</p>
<p>希望读者在阅读完本章内容后，对容器的理解能更上一层楼，在实践应用上也能融会贯通。</p>
<section id="docker">
<h3><a class="toc-backref" href="#id156">Docker为什么会成功</a><a class="headerlink" href="#docker" title="Permalink to this headline">¶</a></h3>
<p>Docker实现所依赖的各种基础技术（cgroups、namespace、分层文件系统等）在Docker之前已经存在很多年。并且，其前身的LXC也在诸多企业的生产环境中得到了大量的应用实践，并得到了极为明显的性能优势。Google大规模容器集群的性能比传统虚拟机要高很多，接近于Bare
Metal。与传统虚拟机相比，容器集群让这些公司拥有秒级而非分钟级的弹性计算伸缩能力，同时使用更少的机器运行更多实例。</p>
<p>既然容器技术有如此大的优势，为什么Docker之前，容器并没有引发广泛的关注呢？核心问题在于易用性。前人走完了九十九步，而Docker迈出了最后的一步，引发了从量变到质变的突破。</p>
<p>Docker首次创造了一种简单易行并且覆盖应用全生命周期的工作流。用户可以通过简单的指令或Restful
API来拉取、打包、运行和维护容器。这种简化从根本上降低了应用程序部署的难度，极大地提高了应用运行时环境的部署与维护的效率。用户可以不依赖类似于Ansible、Chef、Puppet这类配置管理和发布系统，不需要一次部署中同时关注基础系统与软件的安装配置，以及应用的安装调试。</p>
<p>Docker提供了一种统一的实践方法，每个服务（或应用）维护一个Dockerfile文件。即便使用编排工具如Docker
Compose，一个服务（或应用）也只需维护一个docker-compose.yml文件。应用程序及其运行时环境全部打包到一个简单易读的Dockerfile或Compose文件中，开发团队和运维团队都可以透明地合作维护这个文件，极大地降低了沟通成本与部署成本，满足了研发团队与DevOps团队、运维团队之间的沟通需求，清晰划分了责任边界。</p>
<p>Docker正以一种前所未有的方式让用户可以在各种Linux发行版、各种开发环境中快速切换，这对应用开发者来说真是一种福音。使用各种开发环境的用户，再也不必担心破坏主机的系统环境（如环境变量）和应用程序。系统架构师们也可以使用Docker来快速搭建各种网络架构的系统，且可以方便地管理这些系统之间的数据连接和共享。目前Docker发展迅速，基于Docker的PaaS平台也层出不穷。这让技术创业者无须折腾服务器部署，只需专注业务代码的实现即可。</p>
<p>完整解决用户痛点，真正带来效率的提升，正是一个产品和技术能最终成功的关键！</p>
</section>
<section id="id107">
<h3><a class="toc-backref" href="#id157">研发人员该如何看待容器</a><a class="headerlink" href="#id107" title="Permalink to this headline">¶</a></h3>
<p>很多研发工程师经常会问：我是搞开发的，不做运维，容器技术跟我有关吗？其实，笔者在实践过程中发现，合理应用容器技术，不仅能提升开发效率，而且还能提升技术水平。</p>
<section id="id108">
<h4>1.快速上手新技术<a class="headerlink" href="#id108" title="Permalink to this headline">¶</a></h4>
<p>众所周知，新技术的学习往往从学习简单示例（例如Hello
World）开始，这是学习新知识的标准思路：最小系统原则，即从变量最少的最小系统开始，循序渐进地学习。</p>
<p>现实生活中，简单的事物背后往往蕴含着复杂的机制。用户在构建最小系统的时候，首先面对的就是环境（或者说前置条件）的搭建。虽然随着程序语言自身的发展，周边工具越来越多，但学习成本仍然居高不下，各大技术论坛中关于环境安装的问题总是层出不穷。</p>
<p>通过Docker的使用，用户可以将精力和注意力都尽快地放在语言本身的学习上，而无须折腾系统环境的各种配置。Docker官网的口号就包含了以上含义：Build，Ship
and Run Any
App，Anywhere，即“任何应用都可以自动构建、发布、运行于任何环境”，将环境的影响因素降至最低，全面掌控应用整个生命周期。</p>
<p>目前Docker官方支持的编程语言镜像已达几十种，涵盖所有的主流编程语言的开发环境。除此之外，常用数据库、缓存系统、主流Web框架等都有官方的镜像。除此之外，Docker
Hub还提供了丰富的第三方镜像。</p>
</section>
<section id="id109">
<h4>2.容器化的代码仓库提升开发速度<a class="headerlink" href="#id109" title="Permalink to this headline">¶</a></h4>
<p>经常整理和收集常用代码库是软件工程师实现高效交付的“秘诀”。</p>
<p>在技术团队中，为何行业新人和资深工程师之间的生产力可以有几十倍的差距呢？暂且不论基础技能和经验的差距，同样是做一件任务，新人首先面对的就是工具的选择，然后需要解决工程实践中的各种“坑”。而资深工程师接手后，可以快速规划所需要的资源，并在最短时间内利用积累的模块搭建起系统，从而可以快速完成任务。</p>
<p>另外，研发过程中的各种发布版本，也可以用Docker容器的方式保存。以后遇到类似的需求，可以直接运行、调试并复用代码。</p>
</section>
<section id="id110">
<h4>3.面向业务编程<a class="headerlink" href="#id110" title="Permalink to this headline">¶</a></h4>
<p>软件开发，除非是算法比赛，否则本质上还是要能解决业务问题，满足需求方的要求。最近几年，各种新的技术和工具层出不穷，虽然万变不离其宗，但能快速掌握新的业务需求和新的技术栈，是对一个优秀技术人员的迫切要求。</p>
<p>笔者根据Docker的特性，给出一个可行方案：使用Docker快速掌握新技术要点并完成适当的技术储备。下面，举一个简单的例子，假定读者是Python技术栈的后端工程师，熟悉常规网站的后台建设，那么如何快速实现移动应用的Restful
API Sever呢？可以去Docker
Hub搜索适合做API服务器的Python快速开发框架，根据自身业务需求修改Dockerfile，定制符合要求的镜像，然后快速启动一套能满足相关API的系统。</p>
<p>可见，容器技术可以帮助软件工程师更加专注地面向业务需求，快速启用新技能。</p>
</section>
<section id="docker-hub">
<h4>4.使用Docker Hub发布开源项目<a class="headerlink" href="#docker-hub" title="Permalink to this headline">¶</a></h4>
<p>技术人员从社区借鉴和学习各种好用的工具和技能时，也需要积极反馈社区，共同营造一个良好的生态环境。</p>
<p>笔者在此建议：读者如果参与开源项目的建设，那么可以通过Docker完成程序的打包、测试、发布和部署，通过Docker
Hub来管理和维护镜像，这样可以统一又清晰地管理整个开源项目。</p>
</section>
</section>
<section id="id111">
<h3><a class="toc-backref" href="#id158">容器化开发模式</a><a class="headerlink" href="#id111" title="Permalink to this headline">¶</a></h3>
<p>传统开发模式会涉及多种环境和团队。开发团队在开发环境中完成软件开发，本地完成单元测试，测试通过，则可提交到代码版本管理库；测试团队打包进行进一步测试。运维团队把应用部署到测试环境，开发团队或测试团队再次进行测试，通过后通知部署人员发布到生产环境。</p>
<p>在上述过程中涉及的三个环境（开发、测试和生产）以及三个团队（开发、测试、运维），彼此之间需要进行大量人工交互，很容易出现由于环境不一致而导致出错的情况，浪费不必要的人力物力。</p>
<p>在容器化开发模式中，应用是以容器的形式存在，所有和该应用相关的依赖都会在容器中，因此移植非常方便，避免了因为环境不一致而出错的风险。</p>
<p>图16-1比较了两种模式下的不同流程。</p>
<p>图16-1　传统模式vs容器模式下的工作流程比较</p>
<p><img alt="image71" src="../_images/docker_vs_chuantong001.png" /></p>
<section id="id112">
<h4>1.操作流程<a class="headerlink" href="#id112" title="Permalink to this headline">¶</a></h4>
<p>在容器化的应用中，项目架构师和开发人员的作用贯穿整个开发、测试、生产三个环节。</p>
<p>项目伊始，架构师根据项目预期创建好基础的base镜像，如Nginx、Tomcat、MySQL镜像，或者将Dockerfile分发给所有开发人员。开发人员根据Dockerfile创建的容器或者从内部仓库下载的镜像来进行开发，达到开发环境的充分一致。若开发过程中需要添加新的软件，只需要向架构师申请修改基础的base镜像的Dockerfile即可。</p>
<p>开发任务结束后，架构师调整Dockerfile或者Docker镜像，然后分发给测试部门，测试部门马上就可以进行测试，消除了部署困难等难缠的问题。</p>
</section>
<section id="id113">
<h4>2.场景示例<a class="headerlink" href="#id113" title="Permalink to this headline">¶</a></h4>
<p>假如有一个200人左右的软件企业，主要使用Java作为开发语言，使用Tomcat、WebLogic作为中间件服务器，后台数据库使用Oracle、MySQL等。在应用容器之前，开发到测试的流程如图16-2所示。</p>
<p>可见，因为环境不一样，开发、测试、运维三个部门做了很多重复的工作。</p>
<p>而容器化开发正好可以解决这个问题，大大简化工作流程，如图16-3所示。</p>
<p>　传统的开发流程</p>
<p><img alt="image72" src="../_images/docker_vs_chuantong00002.png" /></p>
<p>利用容器环境开发的流程</p>
<p><img alt="image73" src="../_images/docker_vs_chuantong00003.png" /></p>
</section>
<section id="id114">
<h4>3.注意事项<a class="headerlink" href="#id114" title="Permalink to this headline">¶</a></h4>
<p>首先，在开发和测试环境中，推荐使用-v共享文件夹来存储开发人员的程序代码，避免频繁打包操作。</p>
<p>其次，利用基础的base镜像的继承特性来调整镜像的轻微变更。例如当需要测试程序对不同版本的JDK的支持情况时，只需改变base镜像的JDK设置，然后其他依赖它的镜像在重新创建的过程中就可以自动完成更新。</p>
<p>最后，测试部门应当注意Docker以及镜像的版本，并经常对部署后的应用程序进行性能上的测试。</p>
</section>
</section>
<section id="id115">
<h3><a class="toc-backref" href="#id159">容器与生产环境</a><a class="headerlink" href="#id115" title="Permalink to this headline">¶</a></h3>
<p>对于生产环境，不同的产品技术团队可能有不同的解读。在这里，生产环境是指企业运行其商业应用的IT环境，是相对于开发环境、预发布环境和测试环境而言的。</p>
<p>在生产环境中，容器既可以作为API后端服务器，也可以作为业务应用的Web服务器，还可以作为微服务中的服务节点。但是不管用户将容器用于哪种场景，在生产环境中运行容器与其他环境相比，对安全性与稳定性等方面都有更高的要求。</p>
<p>Docker算是IT生产环境与基础设施的新成员。近些年，Docker在DevOps和基础设施领域中快速风靡起来。Google、IBM、Amazon、Microsoft，以及几乎所有云计算供应商都宣布支持Docker。很多容器领域中的创业公司都在2014年或2015年初获得了风险投资。同时，Docker公司在2015年的估值也达到了10亿美元。</p>
<p>尽管Docker获得广大公有云厂商的大力支持，但是目前容器技术生态中已经存在许多分支与分歧，如rkt项目。为了解决容器生态中的差异化问题，为了从根本上解决生产环境中运用Docker的风险，Google、Intel、Microsoft、IBM、Amazon、VMware、Oracle、HPE、Facebook等IT巨头于2015年6月共同宣布成立OCI（Open
Container Initiative）组织
[<a class="reference external" href="http://reader.epubee.com/books/mobile/5e/5ed586449ceaa3f619488a147cd76a01/text00126.html#ch1_back">1]</a>
。OCI组织的目标在于建立通用的容器技术标准。除了保障与延续既有容器服务的生命周期外，还通过不断推出标准的、创新的容器解决方案赋能开发者。而OCI成员企业也会秉持开放、安全、弹性等核心价值观来发展容器生态。客观而言，OCI组织的出现确立了容器技术的标准，避免容器技术被单一厂商垄断。统一技术标准后，广大企业不用担心未来新兴的容器技术不兼容Docker。</p>
<p>2016年开始，大量企业应用开始云化，部分已经云化的企业，开始实施全面容器化和微服务化。不过，用户不应该把容器当作“银弹”，并不是所有应用和服务都适合容器化。对于“12
factor”类型应用
[<a class="reference external" href="http://reader.epubee.com/books/mobile/5e/5ed586449ceaa3f619488a147cd76a01/text00126.html#ch2_back">2]</a>
，容器化是非常容易和平滑的。因为这些应用是无状态的，而且它们在微服务架构中可以在很短时间内完成启停，高度保证了整个服务的可用性。传统数据库或有状态的应用、对网络吞吐性能有高要求的应用，并不适合容器化。</p>
<p>可以说，绝大部分分层架构的企业架构，都可以平滑地在生产环境中容器化。而绝大部分完成容器化的企业架构，都可以通过代码重构完成微服务化，这样可以从服务层面进一步提高可用性，进一步降低IT固定成本。降低持续集成与部署成本。</p>
<p>现在越来越多的企业正在生产环境中使用Docker。2016年，DockerHub镜像下载量超过100亿次。最近某容器服务的研究显示，八成的IT从业者了解和接触过Docker，四成的组织目前正在生产环境中使用Docker，预计这个比例会在未来两年内还会继续上升。</p>
<p>在生产环境中使用容器，这里提供一些基本建议供大家参考：</p>
<p>·如果Docker出现不可控的风险，是否考虑了备选的解决方案；</p>
<p>·是否需要对Docker容器做资源限制，以及如何限制，如CPU、内存、网络、磁盘等；</p>
<p>·目前，Docker对容器的安全管理做得不够完善，在应用到生产环境之前可以使用第三方工具来加强容器的安全管理，如使用apparmor对容器的能力进行限制，使用更加严格的iptable规则，禁止root用户登录，限制普通用户权限以及做好系统日志的记录；</p>
<p>·公司内部私有仓库的管理、镜像的管理问题是否解决。目前官方提供的私有仓库管理工具功能并不十分完善，若在生产环境中使用还需要更多的完善措施。</p>
<p>[<a class="reference external" href="http://reader.epubee.com/books/mobile/5e/5ed586449ceaa3f619488a147cd76a01/text00126.html#ch1">1]</a>
OCI组织官网：<a class="reference external" href="https://www.opencontainers.org/">https://www.opencontainers.org/</a></p>
<p>[<a class="reference external" href="http://reader.epubee.com/books/mobile/5e/5ed586449ceaa3f619488a147cd76a01/text00126.html#ch2">2]</a>
12Factor App：<a class="reference external" href="https://12factor.net/">https://12factor.net/</a></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="08.%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.html" class="btn btn-neutral float-left" title="使用Dockerfile创建镜像" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="10.Docker%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF.html" class="btn btn-neutral float-right" title="Docker核心实现技术" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>