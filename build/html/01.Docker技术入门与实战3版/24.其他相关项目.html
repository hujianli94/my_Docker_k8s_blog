<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>其他相关项目 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="附录" href="25.%E9%99%84%E5%BD%95.html" />
    <link rel="prev" title="Kubernetes-生产级容器集群平台" href="23.Kubernetes-%E7%94%9F%E4%BA%A7%E7%BA%A7%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%B9%B3%E5%8F%B0.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> 小健_Docker_K8s_Blog
            <img src="../_static/docker-k8s.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">01.Docker技术入门与实战3版</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01.%E5%88%9D%E8%AF%86Docker%E4%B8%8E%E5%AE%B9%E5%99%A8.html">初识Docker与容器</a></li>
<li class="toctree-l2"><a class="reference internal" href="02.Docker%E9%95%9C%E5%83%8F%E7%9A%84%E4%BD%BF%E7%94%A8.html">Docker镜像的使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="03.%E6%93%8D%E4%BD%9CDocker%E5%AE%B9%E5%99%A8.html">操作Docker容器</a></li>
<li class="toctree-l2"><a class="reference internal" href="04.%E8%AE%BF%E9%97%AEDocker%E4%BB%93%E5%BA%93.html">访问Docker仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="05.%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html">搭建本地私有仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="06.Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86.html">Docker数据管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="07.Docker%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C.html">Docker使用网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="08.%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.html">使用Dockerfile创建镜像</a></li>
<li class="toctree-l2"><a class="reference internal" href="09.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B.html">实战案例</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.Docker%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF.html">Docker核心实现技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="11.%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html">配置私有仓库</a></li>
<li class="toctree-l2"><a class="reference internal" href="12.%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E4%B8%8E%E9%85%8D%E7%BD%AE.html">安全防护与配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="13.%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD.html">高级网络功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="14.libnetwork%E6%8F%92%E4%BB%B6%E5%8C%96%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD.html">libnetwork插件化网络功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="15.Etcd%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93.html">Etcd高可用的键值数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="16.Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Compose.html">Docker三剑客之Docker-Compose</a></li>
<li class="toctree-l2"><a class="reference internal" href="17.Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Swarm.html">Docker三剑客之Docker-Swarm</a></li>
<li class="toctree-l2"><a class="reference internal" href="18.Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Machine.html">Docker三剑客之Docker-Machine</a></li>
<li class="toctree-l2"><a class="reference internal" href="19.%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAWeb%E5%BA%94%E7%94%A8%E6%A0%88.html">搭建一个Web应用栈</a></li>
<li class="toctree-l2"><a class="reference internal" href="20.Docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E5%AE%9E%E6%88%98.html">Docker高级网络实战</a></li>
<li class="toctree-l2"><a class="reference internal" href="21.%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.html">服务发现</a></li>
<li class="toctree-l2"><a class="reference internal" href="22.Mesos-%E4%BC%98%E7%A7%80%E7%9A%84%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0.html">Mesos—优秀的集群资源调度平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="23.Kubernetes-%E7%94%9F%E4%BA%A7%E7%BA%A7%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%B9%B3%E5%8F%B0.html">Kubernetes-生产级容器集群平台</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">其他相关项目</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">1.持续集成</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">2.容器管理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#portainer">2.1 Portainer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#panamax">2.2 Panamax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#seagull">2.3 Seagull</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">3.编程开发</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#docker-py">3.1 安装docker-py</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">3.2 使用示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">4.网络支持</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pipework">4.1 Pipework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#flannel">4.2 Flannel项目</a></li>
<li class="toctree-l4"><a class="reference internal" href="#weave-net">4.3 Weave Net项目</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calico">4.4 Calico项目</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">5.日志处理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#docker-fluentd">5.1 Docker-Fluentd</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logspout">5.2 logspout</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sematext-agent-docker">5.3 Sematext-agent-docker</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id8">6.服务代理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#traefik">6.1 Traefik</a></li>
<li class="toctree-l4"><a class="reference internal" href="#muguet">6.2 Muguet</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nginx-proxy">6.3 nginx-proxy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id9">7.标准与规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#runc">7.1 runC标准</a></li>
<li class="toctree-l4"><a class="reference internal" href="#appc">7.2 appC标准</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">7.3 开放容器规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">7.4 云应用12要素</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id12">8.其他项目</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#coreos">8.1 CoreOS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#openstack">8.2 OpenStack支持</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dockerize">8.3 dockerize</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unikernel">8.4 Unikernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">8.5 容器化的虚拟机</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="25.%E9%99%84%E5%BD%95.html">附录</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../02.Kubernetes%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/index.html">02.Kubernetes实战指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03.Docker%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B/index.html">03.Docker经典实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04.Prometheus%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/index.html">04.Prometheus监控运维实战</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05.Kubernetes%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/index.html">05.Kubernetes入门到实践</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">小健_Docker_K8s_Blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">01.Docker技术入门与实战3版</a> &raquo;</li>
      <li>其他相关项目</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/01.Docker技术入门与实战3版/24.其他相关项目.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id14">其他相关项目</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id15">1.持续集成</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id16">2.容器管理</a></p>
<ul>
<li><p><a class="reference internal" href="#portainer" id="id17">2.1 Portainer</a></p></li>
<li><p><a class="reference internal" href="#panamax" id="id18">2.2 Panamax</a></p></li>
<li><p><a class="reference internal" href="#seagull" id="id19">2.3 Seagull</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id4" id="id20">3.编程开发</a></p>
<ul>
<li><p><a class="reference internal" href="#docker-py" id="id21">3.1 安装docker-py</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id22">3.2 使用示例</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id6" id="id23">4.网络支持</a></p>
<ul>
<li><p><a class="reference internal" href="#pipework" id="id24">4.1 Pipework</a></p></li>
<li><p><a class="reference internal" href="#flannel" id="id25">4.2 Flannel项目</a></p></li>
<li><p><a class="reference internal" href="#weave-net" id="id26">4.3 Weave Net项目</a></p></li>
<li><p><a class="reference internal" href="#calico" id="id27">4.4 Calico项目</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id7" id="id28">5.日志处理</a></p>
<ul>
<li><p><a class="reference internal" href="#docker-fluentd" id="id29">5.1 Docker-Fluentd</a></p></li>
<li><p><a class="reference internal" href="#logspout" id="id30">5.2 logspout</a></p></li>
<li><p><a class="reference internal" href="#sematext-agent-docker" id="id31">5.3 Sematext-agent-docker</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id8" id="id32">6.服务代理</a></p>
<ul>
<li><p><a class="reference internal" href="#traefik" id="id33">6.1 Traefik</a></p></li>
<li><p><a class="reference internal" href="#muguet" id="id34">6.2 Muguet</a></p></li>
<li><p><a class="reference internal" href="#nginx-proxy" id="id35">6.3 nginx-proxy</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id9" id="id36">7.标准与规范</a></p>
<ul>
<li><p><a class="reference internal" href="#runc" id="id37">7.1 runC标准</a></p></li>
<li><p><a class="reference internal" href="#appc" id="id38">7.2 appC标准</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id39">7.3 开放容器规范</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id40">7.4 云应用12要素</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id12" id="id41">8.其他项目</a></p>
<ul>
<li><p><a class="reference internal" href="#coreos" id="id42">8.1 CoreOS</a></p></li>
<li><p><a class="reference internal" href="#openstack" id="id43">8.2 OpenStack支持</a></p></li>
<li><p><a class="reference internal" href="#dockerize" id="id44">8.3 dockerize</a></p></li>
<li><p><a class="reference internal" href="#unikernel" id="id45">8.4 Unikernel</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id46">8.5 容器化的虚拟机</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="id1">
<h1><a class="toc-backref" href="#id14">其他相关项目</a><a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<section id="id2">
<h2><a class="toc-backref" href="#id15">1.持续集成</a><a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>目前，Drone项目利用Docker技术实现持续集成平台服务。</p>
<p>Drone是开源的持续集成平台项目，基于Go语言实现，遵循Apache
2.0协议。项目官方网站为http://drone.io，代码在https://github.com/drone/drone维护。该项目最初由Drone公司在2014年2月发起，目前还处于开发阶段。Drone公司基于它，提供支持Github、Bitbucket和Google
Code等第三方代码托管平台的持续集成服务，如图</p>
<p>Drone公司主页</p>
<p><img alt="image0" src="../_images/image-20220713093059857.png" /></p>
<p>Drone基于Docker和AUFS实现，为用户提供基于网站的操作。用户登录网站后，可以选择源码的存放服务。</p>
<p>此处选择Github服务，进入Github仓库，如图所示。然后从仓库列表中选择项目。</p>
<p>Github仓库</p>
<p><img alt="image1" src="../_images/image-20220713093212205.png" /></p>
<p>配置项目的语言种类，如图</p>
<p>配置项目的语言</p>
<p><img alt="image2" src="../_images/image-20220713093253269.png" /></p>
<p>接下来需要检查创建命令是否正确，并根据具体情况进行调整，如图</p>
<p>创建命令</p>
<p><img alt="image3" src="../_images/image-20220713093328920.png" /></p>
<p>最后，项目就可以在Drone平台上进行持续集成管理了，如图所示。</p>
<p>在Drone平台进行持续集成管理</p>
<p><img alt="image4" src="../_images/image-20220713093358976.png" /></p>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id16">2.容器管理</a><a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>Docker官方工具已经提供了十分强大的管理功能。目前，已经有若干开源项目试图实现更为强大和便捷的Docker管理工具，包括Portainer、Panamax等。</p>
<section id="portainer">
<h3><a class="toc-backref" href="#id17">2.1 Portainer</a><a class="headerlink" href="#portainer" title="Permalink to this heading">¶</a></h3>
<p>Portainer项目前身为DockerUI项目，定位于管理本地或远端（需要开启网络访问）的容器资源。官方网站为https://portainer.io/，目前支持对Docker和Swarm进行管理。</p>
<p>该项目最早于2013年12月发起，主要基于HTML/JS语言实现，遵循MIT许可。用户可以通过下面的命令简单测试该工具：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker volume create portainer_data
$ docker run -d -p <span class="m">9000</span>:9000 <span class="se">\</span>
    -v /var/run/docker.sock:/var/run/docker.sock <span class="se">\</span>
    -v portainer_data:/data <span class="se">\</span>
    portainer/portainer
</pre></div>
</div>
<p>运行成功后，打开浏览器，访问http://:9000管理本地的容器和镜像,如图:</p>
<p><img alt="image5" src="../_images/image-20220713093647411.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">docker-compose.yaml</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">version</span><span class="p">:</span> <span class="s1">&#39;3&#39;</span>

<span class="n">services</span><span class="p">:</span>
  <span class="n">Portainer</span><span class="p">:</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">portainer</span><span class="o">/</span><span class="n">portainer</span><span class="p">:</span><span class="n">latest</span>
    <span class="n">restart</span><span class="p">:</span> <span class="n">always</span>
    <span class="n">container_name</span><span class="p">:</span> <span class="n">portainer</span><span class="o">-</span><span class="n">ui</span>
    <span class="n">volumes</span><span class="p">:</span>
      <span class="o">-</span> <span class="s2">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span>
      <span class="o">-</span> <span class="s2">&quot;./portainer_data:/data&quot;</span>
      <span class="o">-</span> <span class="s2">&quot;./public:/public&quot;</span>
    <span class="n">ports</span><span class="p">:</span>
      <span class="o">-</span> <span class="mi">9000</span><span class="p">:</span><span class="mi">9000</span>
</pre></div>
</div>
</section>
<section id="panamax">
<h3><a class="toc-backref" href="#id18">2.2 Panamax</a><a class="headerlink" href="#panamax" title="Permalink to this heading">¶</a></h3>
<p>项目官方网站为http://panamax.io，代码在https://github.com/CenturyLinkLabs/panamax-ui维护。</p>
<p>Panamax项目诞生于2014年3月，由CenturyLink实验室发起（是该实验室孵化出的第一个开源项目），希望通过一套优雅的界面来实现对复杂的Docker容器应用的管理，例如利用简单拖曳来完成操作。Panamax项目基于Docker、CoreOS和Fleet，可以提供对容器的自动化管理和任务调度，其主页如图所示。</p>
<p>Panamax官方网站</p>
<p><img alt="image6" src="../_images/image-20220713093938229.png" /></p>
<p>Panamax项目基于Ruby语言，遵循Apache
2许可，可以部署在Google、Amazon等云平台甚至本地环境。此外，Panamax还提供了开源应用的模板库来集中管理不同应用的配置和架构。</p>
</section>
<section id="seagull">
<h3><a class="toc-backref" href="#id19">2.3 Seagull</a><a class="headerlink" href="#seagull" title="Permalink to this heading">¶</a></h3>
<p>Seagull是由小米团队发起的Docker容器和镜像的Web界面监控工具，支持同时监控多个Docker环境，代码已开源在https://github.com/tobegit3hub/seagull。</p>
<p>如图</p>
<p>Seagull官方网站</p>
<p><img alt="image7" src="../_images/image-20220713094109261.png" /></p>
<p>seagull基于Go和JavaScript实现，集成了Beego、AngularJS、Bootstrap、Bower、JQuery和Docker等工具。它在本地运行一个Web服务，通过Beego实现的API服务器不断请求Docker本地套接字以管理Docker。使用方法介绍如下。</p>
<p>下载镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker pull tobegit3hub/seagull
</pre></div>
</div>
<p>运行镜像：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p <span class="m">10086</span>:10086 -v /var/run/docker.sock:/var/run/docker.socktobegit3hub/seagull
</pre></div>
</div>
<p>然后就可以通过浏览器访问地址http://127.0.0.1:10086登录管理界面。</p>
<p>安装Go语言环境后，可以通过如下步骤来本地编译和安装：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ go get github.com/astaxie/beego
$ go get github.com/tobegit3hub/seagull
$ go build seagull.go
$ sudo ./seagull
</pre></div>
</div>
</section>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id20">3.编程开发</a><a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>由于Docker服务端提供了REST风格的API，通过对这些API进一步的封装，可以提供给各种开发语言作为Docker的SDK。这里以docker-py项目为例，介绍在Python语言中对Docker相关资源进行操作。</p>
<section id="docker-py">
<h3><a class="toc-backref" href="#id21">3.1 安装docker-py</a><a class="headerlink" href="#docker-py" title="Permalink to this heading">¶</a></h3>
<p>docker-py项目是基于Python语言的Docker客户端，代码开源在https://github.com/docker/docker-py上。最新的稳定版本也已经推送到PyPI上，可以通过pip命令快速安装：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sudo pip install docker[tls]
</pre></div>
</div>
<p>安装后，查看源代码可以发现，代码结构十分清晰，主要提供了Client类，用来封装提供用户可以用Docker命令执行的各种操作，包括build、run、commit、create_container、info等等接口。</p>
<p>对REST接口的调用使用了request库。对于这些API，用户也可以通过curl来进行调用测试。</p>
</section>
<section id="id5">
<h3><a class="toc-backref" href="#id22">3.2 使用示例</a><a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>打开Python的终端，首先创建一个Docker客户端连接：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sudo python
&gt;&gt;&gt; import docker
&gt;&gt;&gt; c = docker.DockerClient(base_url=&#39;unix://var/run/docker.sock&#39;,version=&#39;auto&#39;, timeout=10)
</pre></div>
</div>
<p>通过info()方法查看Docker系统信息：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
<span class="go">{&#39;ID&#39;: &#39;RXBF:A62S:BTI5:...:YAUG:VQ3N&#39;, &#39;Containers&#39;: 0, &#39;ContainersRunning&#39;: 0, &#39;ContainersPaused&#39;: 0, &#39;ContainersStopped&#39;: 0, &#39;Images&#39;: 95, &#39;Driver&#39;: &#39;overlay2&#39;, &#39;DriverStatus&#39;: [[&#39;Backing Filesystem&#39;, &#39;extfs&#39;],...}</span>
</pre></div>
</div>
<p>通过images和containers属性可以查看和操作本地的镜像和容器资源：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">images</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&lt;Image: &#39;node:slim&#39;&gt;, &lt;Image: &#39;node:latest&#39;&gt;, &lt;Image: &#39;docs/docker.github.io:latest&#39;&gt;, ...,]</span>
</pre></div>
</div>
<p>通过create_container()方法来创建一个容器，之后启动它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">container</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">containers</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="s1">&#39;ubuntu:latest&#39;</span><span class="p">,</span> <span class="n">command</span><span class="o">=</span><span class="s1">&#39;bash&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
<span class="go">{u&#39;Id&#39;: u&#39;a8439e4c8e64a94a287d408fdc3ff9a0b4a8577fe3b5e32975b790afb41414af&#39;, u&#39;Warnings&#39;: None}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">container</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>或者更简单地通过如下代码直接运行容器：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">docker</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">docker</span><span class="o">.</span><span class="n">from_env</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">client</span><span class="o">.</span><span class="n">containers</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s2">&quot;ubuntu:16.04&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;echo&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="s2">&quot;World&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>可见，所提供的方法与Docker提供的命令十分类似。实际上，在使用SDK执行Docker命令的时候，也是通过Docker服务端提供的API进行了封装。</p>
</section>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id23">4.网络支持</a><a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<p>围绕Docker网络的管理和使用，现在已经诞生了一些方便用户操作的工具和项目，具有代表性的包括pipework、Flannel、Weave以及Calico项目。</p>
<section id="pipework">
<h3><a class="toc-backref" href="#id24">4.1 Pipework</a><a class="headerlink" href="#pipework" title="Permalink to this heading">¶</a></h3>
<p>Jérôme
Petazzoni编写了一个叫Pipework的shell脚本，代码托管在https://github.com/jpetazzo/pipework上，该工具封装了底层通过ip、brctl等网络设备操作的命令，可以简化在比较复杂的场景中对容器连接的操作命令。</p>
<p>使用该工具，可以轻松地配置容器的IP地址、为容器划分VLan等功能。</p>
<p>例如，分别启动两个终端，在其中创建两个测试容器c1和c2，并查看默认网卡配置。利用Pipework为容器c1和c2添加新的网卡eth1，并将它们连接到新创建的br1网桥上：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ sudo pipework br1 c1 <span class="m">192</span>.168.1.1/24
$ sudo pipework br1 c2 <span class="m">192</span>.168.1.2/24
</pre></div>
</div>
<p>此时在主机系统中查看网桥信息，会发现新创建的网桥br1，并且有两个veth端口连接上去：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
br1             <span class="m">8000</span>.868b605fc7a4       no              veth1pl17805
                                                        veth1pl17880
docker0         <span class="m">8000</span>.56847afe9799       no              veth89934d8
</pre></div>
</div>
<p>此时，容器c1和c2可以通过子网192.168.1.0/16相互连通。</p>
<p>另外，Pipework还支持指定容器内的网卡名称、MAC地址、网络掩码和网关等配置，甚至可以通过macvlan连接容器到本地物理网卡，实现跨主机通信。</p>
<p>pipework代码只有200多行，建议阅读这些代码以理解如何利用Linux系统上的iproute等工具实现容器连接的配置。</p>
</section>
<section id="flannel">
<h3><a class="toc-backref" href="#id25">4.2 Flannel项目</a><a class="headerlink" href="#flannel" title="Permalink to this heading">¶</a></h3>
<p>Flannel由CoreOS公司推出，现在主要面向Kubernetes，为其提供底层的网络虚拟化方案，代码托管在https://github.com/coreos/flannel上。</p>
<p>Flannel采用了典型的覆盖网络的思路，在每个主机上添加一个隧道端点，所有跨主机的流量会经过隧道端点进行隧道封包（典型为VXLAN协议，Docker
Swarm也支持），直接发送到对端，如图</p>
<p>Flannel的设计思路</p>
<p><img alt="image8" src="../_images/image-20220713172310867.png" /></p>
<p>与传统的基于覆盖网络的网络虚拟化方案类似，这种设计的优势在于有很好的扩展性，只要IP连通的主机即可构成同一个虚拟网络，甚至可以跨数据中心。</p>
<p>问题也很明显，一个是隧道协议目前还比较难追踪，另一个是解包和封包处理负载重，如果没有硬件进行处理则往往性能会有损耗。另外，当中间路径存在负载均衡设备时，要避免均衡失效。</p>
</section>
<section id="weave-net">
<h3><a class="toc-backref" href="#id26">4.3 Weave Net项目</a><a class="headerlink" href="#weave-net" title="Permalink to this heading">¶</a></h3>
<p>Weave
Net是由Weave公司开发的面向容器的网络虚拟化方案，项目托管在https://git-hub.com/weaveworks/weave上。解决容器网络跨主机问题的思路主要是打通跨主机容器之间的通信，手段无非是用覆盖网络建立隧道，或者通过更改包头进行转发。</p>
<p>Weave
Net的设计比较有意思，在每个主机上添加一个路由器，在混杂模式下使用pcap在网桥上截获网络数据包。如果该数据包是要发送到其他主机上的，则通过UDP进行转发，到目的主机所在的路由器上。目的路由器执行相反的过程利用pcap解析网包再发送给网桥。整个过程模拟了一种隧道方式，如图</p>
<p><img alt="image9" src="../_images/image-20220713172533453.png" /></p>
<p>Weave Net项目的设计思路</p>
<p>这样设计的好处是可以进行细粒度的管理，整个转发过程很容易追踪；潜在的问题是对管理平面（特别是路由器的自动收敛和学习）要求比较复杂，并且执行pcap过程会比较消耗计算资源。</p>
<p>实际部署中要考虑结合软件定义网络和硬件处理等手段来缓解这两个问题。</p>
<p>​</p>
</section>
<section id="calico">
<h3><a class="toc-backref" href="#id27">4.4 Calico项目</a><a class="headerlink" href="#calico" title="Permalink to this heading">¶</a></h3>
<p>项目官方网站在https://www.projectcalico.org/。</p>
<p><a class="reference external" href="https://projectcalico.docs.tigera.io/about/about-calico">https://projectcalico.docs.tigera.io/about/about-calico</a></p>
<p>Calico的设计则更为直接，干脆不支持网络虚拟化，直接采用传统的路由转发机制，也是在每个节点上配置一个vRouter，负责处理跨主机的流量。vRouter之间通过BGP自动学习转发策略,详细内容查看官方文档。</p>
<p>由于Calico不采用隧道格式，而是依赖于传统的IP转发，这就限制了它的应用场景，无法跨数据中心，无法保障中间路径安全。但反之带来了容易管理、转发性能会好的一些优势。</p>
<p>Calico目前支持VM、Docker、Kubernetes、Openstack等多个项目的容器网络功能。</p>
<p>Calico项目目前正在与Flannel项目共同发起Canal项目，整合了两者的优势，项目地址在https://github.com/projectcalico/canal。</p>
</section>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id28">5.日志处理</a><a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h2>
<p>Docker默认将日志输出到标准输出，也支持包括syslog等标准的日志协议，因此很容易跟已有的日志采集工具进行整合。本节介绍三个日志处理项目。</p>
<section id="docker-fluentd">
<h3><a class="toc-backref" href="#id29">5.1 Docker-Fluentd</a><a class="headerlink" href="#docker-fluentd" title="Permalink to this heading">¶</a></h3>
<p>代码托管在https://github.com/kiyoto/docker-fluentd。Docker-Fluentd以容器运行，使用fluentd收集其他容器的运行日志，重定向到文件或者第三方的分析引擎中。</p>
<p>使用方法很简单，直接启动一个本地采集容器即可：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -v /var/lib/docker/containers:/var/lib/docker/containers kiyoto/docker-fluentd
</pre></div>
</div>
<p>如果要重定向到其他分析引擎，比如Elasticsearch，可以更改dockerfile，加入如下内容：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="p">[</span><span class="s2">&quot;apt-get&quot;</span><span class="p">,</span> <span class="s2">&quot;update&quot;</span><span class="p">]</span>
<span class="n">RUN</span> <span class="p">[</span><span class="s2">&quot;apt-get&quot;</span><span class="p">,</span> <span class="s2">&quot;install&quot;</span><span class="p">,</span> <span class="s2">&quot;--yes&quot;</span><span class="p">,</span> <span class="s2">&quot;make&quot;</span><span class="p">,</span> <span class="s2">&quot;libcurl4-gnutls-dev&quot;</span><span class="p">]</span>
<span class="n">RUN</span> <span class="p">[</span><span class="s2">&quot;/usr/local/bin/gem&quot;</span><span class="p">,</span> <span class="s2">&quot;install&quot;</span><span class="p">,</span> <span class="s2">&quot;fluent-plugin-elasticsearch&quot;</span><span class="p">,</span> <span class="s2">&quot;--no-rdoc&quot;</span><span class="p">,</span> <span class="s2">&quot;--no-ri&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>同时修改fluent.conf如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;source&gt;
    type tail
    path /var/lib/docker/containers/*/*-json.log
    pos_file /var/log/fluentd-docker.pos
    time_format %Y-%m-%dT%H:%M:%S
    tag docker.*
    type record_reformer
    container_id ${tag_parts[5]}
    tag docker.all
&lt;/match&gt;
&lt;match docker.all&gt;
    type elasticsearch
    log_level info
    host YOUR_ES_HOST
    port YOUR_ES_PORT
    include_tag_key true
    logstash_format true
    flush_intercal 5s
&lt;/match&gt;
</pre></div>
</div>
<p>最后重新创建镜像即可。</p>
</section>
<section id="logspout">
<h3><a class="toc-backref" href="#id30">5.2 logspout</a><a class="headerlink" href="#logspout" title="Permalink to this heading">¶</a></h3>
<p>logspout由gliderlabs推出，基于Golang实现，代码托管在https://github.com/gliderlabs/logspout。与Fluentd类似，logspout也是提供一个本地的agent，采集主机上所有容器的标准输出，然后发送到采集端。</p>
<p>logspout支持对所采集的容器进行筛选，并且支持Syslog、Kafka、Redis、Logstash等多种采集后端。</p>
<p>典型的应用是发送到远端的syslog服务器，执行命令也十分简单。需要注意，如果用容器方式启动，则把本地的docker.sock句柄映射到容器内：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run --name<span class="o">=</span><span class="s2">&quot;logspout&quot;</span> <span class="se">\</span>
    --volume<span class="o">=</span>/var/run/docker.sock:/var/run/docker.sock <span class="se">\</span>
    gliderlabs/logspout <span class="se">\</span>
    syslog+tls://your_syslog_server:5000
</pre></div>
</div>
</section>
<section id="sematext-agent-docker">
<h3><a class="toc-backref" href="#id31">5.3 Sematext-agent-docker</a><a class="headerlink" href="#sematext-agent-docker" title="Permalink to this heading">¶</a></h3>
<p>Sematext Docker Agent通过Docker API为SPM Docker
Monitor收集状态统计、事件和日志等信息，它支持多种平台，CoreOS、Rancher
OS、Docker Swarm、Kubernetes等。</p>
<p>代码托管在https://github.com/sematext/sematext-agent-docker。</p>
<p>Sematext提供了丰富的前端显示功能，如图</p>
<p>Sematext的显示功能</p>
<p><img alt="image10" src="../_images/image-20220713175928425.png" /></p>
</section>
</section>
<section id="id8">
<h2><a class="toc-backref" href="#id32">6.服务代理</a><a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h2>
<p>服务代理（又叫反向代理）是指以代理服务器接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>服务代理服务器也可以作为负载均衡器，隐藏后端真正服务器的细节，提高统一访问接口地址，原理如图</p>
<p>服务代理的原理</p>
<p><img alt="image11" src="../_images/image-20220713180039059.png" /></p>
<p>下面介绍支持Docker环境的一些服务代理开源项目。</p>
<section id="traefik">
<h3><a class="toc-backref" href="#id33">6.1 Traefik</a><a class="headerlink" href="#traefik" title="Permalink to this heading">¶</a></h3>
<p>项目官方网址：<a class="reference external" href="https://traefik.io/">https://traefik.io/</a>。</p>
<p>代码网址：<a class="reference external" href="https://github.com/containous/traefik">https://github.com/containous/traefik</a>。</p>
<p>Traefix是一个可以用来简化微服务部署的HTTP代理服务器和负载均衡服务器，支持多种后端服务（Docker、Swarm、Mesos、Marathon、Kubernetes、Consul、Etcd、ZooKeeper、BoltDB、Rest
API、file等）。</p>
<p>传统的代理服务器不适应于动态环境，配置的动态改变一般难以实现，而微服务架构恰恰是动态的，服务的添加、去除和升级经常发生。</p>
<p>Traefix可以监听服务注册/编排的API，当服务状态发生改变时，动态更新反向代理服务器的配置。功能逻辑如图</p>
<p>Traefix的功能逻辑</p>
<p><img alt="image12" src="../_images/image-20220713180304487.png" /></p>
<p>同时提供可视化的WebUI进行配置和状态监测，如图</p>
<p><img alt="image13" src="../_images/image-20220713180344830.png" /></p>
<p>运行方式包括二进制模式和容器模式。</p>
<p>二进制模式的方法为：</p>
<p>下载binary和配置文件：<a class="reference external" href="https://github.com/containous/traefik">https://github.com/containous/traefik</a>/releases和https://raw.githubusercontent.com/containous/traefik/master/traefik.sample.toml，然后直接运行：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ./traefik -c traefik.toml
</pre></div>
</div>
<p>容器模式的方法为：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p <span class="m">8080</span>:8080 -p <span class="m">80</span>:80 -v <span class="nv">$PWD</span>/traefik.toml:/etc/traefik/traefik.toml traefik
</pre></div>
</div>
<blockquote>
<div><p>traefik最新中文文档</p>
<p><a class="reference external" href="https://www.traefik.tech/">https://www.traefik.tech/</a></p>
</div></blockquote>
</section>
<section id="muguet">
<h3><a class="toc-backref" href="#id34">6.2 Muguet</a><a class="headerlink" href="#muguet" title="Permalink to this heading">¶</a></h3>
<p>Muguet提供服务代理和自动DNS解析功能，这样应用可以使用域名来访问容器，而不需要在使用静态端口和IP。</p>
<p>代码网址：<a class="reference external" href="https://github.com/mattallty/muguet">https://github.com/mattallty/muguet</a>。功能逻辑如图</p>
<p><img alt="image14" src="../_images/image-20220713181843314.png" /></p>
<p>安装和使用都比较简单。</p>
<p>安装Muguet：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ npm install -g muguet
</pre></div>
</div>
<p>启动Muguet（as root）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sudo muguet up
</pre></div>
</div>
<p>Muguet提供WebUI，默认域名http://muguet.docker，如图</p>
<p>Muguet的可视化界面</p>
<p><img alt="image15" src="../_images/image-20220713182018636.png" /></p>
</section>
<section id="nginx-proxy">
<h3><a class="toc-backref" href="#id35">6.3 nginx-proxy</a><a class="headerlink" href="#nginx-proxy" title="Permalink to this heading">¶</a></h3>
<p>Nginx除了是强大的Web服务器之外，还是个优秀的代理工具。</p>
<p>nignx-proxy以容器方式自动运行Nginx和docker-gen命令，其中docker-gen负责产生代理配置文件并在容器启动时进行加载。</p>
<p>代码网址：<a class="reference external" href="https://github.com/jwilder/nginx-proxy">https://github.com/jwilder/nginx-proxy</a>。使用方法如下。</p>
<p>首先，运行nignx-proxy：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -p <span class="m">80</span>:80 -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy
</pre></div>
</div>
<p>之后，启动要被代理的容器即可：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -d -e <span class="nv">VIRTUAL_HOST</span><span class="o">=</span>mywebsite.local --expose <span class="m">8080</span> tomcat
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">docker-compose.yaml</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">version</span><span class="p">:</span> <span class="s1">&#39;2&#39;</span>

<span class="n">services</span><span class="p">:</span>
  <span class="n">nginx</span><span class="o">-</span><span class="n">proxy</span><span class="p">:</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">nginxproxy</span><span class="o">/</span><span class="n">nginx</span><span class="o">-</span><span class="n">proxy</span>
    <span class="n">ports</span><span class="p">:</span>
      <span class="o">-</span> <span class="s2">&quot;80:80&quot;</span>
    <span class="n">volumes</span><span class="p">:</span>
      <span class="o">-</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">docker</span><span class="o">.</span><span class="n">sock</span><span class="p">:</span><span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">docker</span><span class="o">.</span><span class="n">sock</span><span class="p">:</span><span class="n">ro</span>

  <span class="n">whoami</span><span class="p">:</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">jwilder</span><span class="o">/</span><span class="n">whoami</span>
    <span class="n">expose</span><span class="p">:</span>
      <span class="o">-</span> <span class="s2">&quot;8000&quot;</span>
    <span class="n">environment</span><span class="p">:</span>
      <span class="c1"># 如果您的DNS设置为将whoami.local转发到运行nginx-proxy的主机，则请求将被路由到设置了VIRTUAL_HOST的容器。</span>
      <span class="c1"># 不支持在VIRTUAL_HOST中提供端口号,可以是容器名</span>
      <span class="o">-</span> <span class="n">VIRTUAL_HOST</span><span class="o">=</span><span class="n">whoami</span><span class="o">.</span><span class="n">local</span>
      <span class="o">-</span> <span class="n">VIRTUAL_PORT</span><span class="o">=</span><span class="mi">8000</span>
</pre></div>
</div>
</section>
</section>
<section id="id9">
<h2><a class="toc-backref" href="#id36">7.标准与规范</a><a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h2>
<p>随着Docker带来的容器技术爆发，社区在不断增强容器技术易用性的同时，也在思考如何更长远地发展容器技术，如兼容不同的容器标准，适应更多类型的操作系统平台以及设计应用等。</p>
<p>目前沿着这个方向努力，已经有了一些组织（如开放容器倡议OCI）在倡导成立一些推荐大家都遵守的容器标准和规范，同时也总结了一些面向云应用的设计实践经验。</p>
<section id="runc">
<h3><a class="toc-backref" href="#id37">7.1 runC标准</a><a class="headerlink" href="#runc" title="Permalink to this heading">¶</a></h3>
<p>runC标准最早由Docker公司在2014年2月左右推出，项目地址为https://github.com/opencontainers/runc，它的目标是打造一套轻量级的标准化的容器运行环境。</p>
<p>通过它，容器可以在多种平台上得到统一的运行时环境以及更好的资源隔离。目前，runC已经贡献成为开放容器标准的重要实现，得到了包括Docker、Google、IBM在内的众多厂家的支持。目前，Docker
1.11+版本中已经默认集成了runC机制的支持。</p>
</section>
<section id="appc">
<h3><a class="toc-backref" href="#id38">7.2 appC标准</a><a class="headerlink" href="#appc" title="Permalink to this heading">¶</a></h3>
<p>appC来自于另外一家容器领域的积极贡献者CoreOS公司，最早在2014年11月左右提出，项目地址为https://github.com/appc。除了对运行时环境进行了一些定义，appC还对容器如何进行打包、如何保持对环境的配置（挂载点、环境变量）、如何验证镜像、如何传输镜像等尝试进行规定。</p>
<p>遵循appC标准，CoreOS公司实现了rkt容器机制。目前，appC也已经贡献给了开放容器倡议组织，尝试推出更开放规范的标准。</p>
</section>
<section id="id10">
<h3><a class="toc-backref" href="#id39">7.3 开放容器规范</a><a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<p>为了推动容器标准化，2015年6月22日，AWS、EMC、IBM、谷歌、Docker、CoreOS、redhat等数十家公司共同牵头成立了开放容器倡议组织（Open
Container
Initiative，OCI），旨在建立一套通用的容器规范OCF。该组织现在受到Linux基金会的支持，其官方网站为https://www.opencontainers.org。</p>
<p>目前，OCI正在推动所提出的开放容器规范（Open Container
Format，OCF），融合了来自runC、appC等多家容器规范，试图打造一套移植性好、开放统一的容器标准。目前已经有了对容器运行时、镜像格式等方面的规范草案。</p>
<p>OCF对标准容器运行时规范制定了5条原则：</p>
<ul class="simple">
<li><p>标准化操作（Standard
operations）：包括创建、删除、打包容器等操作都必须标准化；</p></li>
<li><p>内容无关性（Content
agnostic）：操作应该跟内容无关，保持行为上的一致性；</p></li>
<li><p>平台无关性（Infrastructure
agnostic）：在任何支持OCI的平台上，操作都必须能同等执行；</p></li>
<li><p>设计考虑自动化（Designed for
automation）：标准容器是为自动化而生，其规范必须考虑自动化条件；</p></li>
<li><p>企业级交付（Industrial grade
delivery）：标准容器需要适用于企业级流水线的交付任务。</p></li>
</ul>
</section>
<section id="id11">
<h3><a class="toc-backref" href="#id40">7.4 云应用12要素</a><a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h3>
<p>在云计算时代，应用的整个生命周期将在数据中心里度过，这与传统软件模式极大不同。云应用实际上意味着：代码+配置+运行时环境。那么就会有如下问题：</p>
<ul class="simple">
<li><p>什么样的软件才是可用性和可维护性好的软件？</p></li>
<li><p>什么样的代码才能避免后续开发的上手障碍？</p></li>
<li><p>什么样的实施才能可靠地运行在分布式的环境中？</p></li>
</ul>
<p>Heroku（一家PaaS服务提供者，2010年被Salesforce收购）平台创始人Adam
Winggins提出了“云应用12要素”，对开发者设计和实现云时代（特别是PaaS和SaaS上）高效的应用都有很好的参考意义</p>
<p>（1）Codebase——代码仓库</p>
<p>One codebase tracked in revision control，many deploys.</p>
<p>每个子系统都用独立代码库管理，使用版本管理，实现独立的部署。</p>
<p>即拆分系统为多个分布式应用，每个应用使用自己的代码库进行管理。多个应用之间共享的代码用依赖库的形式提供。</p>
<p>（2）Dependencies——依赖</p>
<p>Explicitly declare and isolate dependencies.</p>
<p>显式声明依赖，通过环境来严格隔离不同依赖。所依赖的跟所声明的要保持一致。并且声明要包括依赖库的版本信息。</p>
<p>（3）Config——配置</p>
<p>Store config in the environment.</p>
<p>在环境变量中保存配置信息，而避免放在源码或配置文件中。</p>
<p>（4）Backing Services——后端服务</p>
<p>Treat backing services as attached resources.</p>
<p>后端服务（数据库、消息队列、缓存等）作为可挂载资源来使用，这样系统跟外部依赖尽量松耦合。</p>
<p>（5）Build，release，run——生命周期管理</p>
<p>Strictly separate build and run stages.</p>
<p>区分不同生命周期的运行环境，包括创建（代码编译为运行包）、发布（多个运行包和配置放一起打包，打包是一次性的，每次修改都是新的release）、运行，各个步骤的任务都很明确，要相互隔离。例如，绝对不允许在运行时去改代码和配置信息（见过太多工程师直接SSH到生产环境修bug了）。</p>
<p>（6）Processes——进程</p>
<p>Execute the app as one or more stateless processes.</p>
<p>以一个或多个无状态的进程来运行应用，即尽量实现无状态，不要在进程中保存数据。尽量通过数据库来共享数据。</p>
<p>（7）Port binding——端口</p>
<p>Export services via port binding.</p>
<p>通过端口绑定来对外提供服务。</p>
<p>可以是HTTP、XMPP、Redis等协议。多个应用之间通过URL来使用彼此的服务。</p>
<p>（8）Concurrency——并发模型</p>
<p>Scale out via the process model.</p>
<p>通过进程控制来扩展，即尽量以多进程模型进行扩展。</p>
<p>（9）Disposability——任意存活</p>
<p>Maximize robustness with fast startup and graceful shutdown.</p>
<p>快速启动（秒级响应），优雅关闭（收到SIGTERM信号后结束正在处理请求，然后退出），并尽量鲁棒（随时kill，随时crash都不应该导致问题）。</p>
<p>（10）Dev/prod parity——减少开发与生产环境的差异性</p>
<p>Keep development，staging，and production as similar as possible.</p>
<p>尽量保持从开发、演练到生产部署环境的相似性。</p>
<p>这点很不容易，要求工程师既懂研发，还得懂运维。</p>
<p>（11）Logs——日志</p>
<p>Treat logs as event streams.</p>
<p>将日志当作事件流来进行统一的管理和维护（使用Logstash等工具）。</p>
<p>应用只需要将事件写出来，例如到标准输出stdout，剩下的由采集系统处理。</p>
<p>（12）Admin processes——管理</p>
<p>Run admin/management tasks as one-off processes.</p>
<p>将管理（迁移数据库、查看状态等）作为一次性的系统服务来使用。</p>
<p>管理代码跟业务代码要放在一起进行代码管理。</p>
</section>
</section>
<section id="id12">
<h2><a class="toc-backref" href="#id41">8.其他项目</a><a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h2>
<section id="coreos">
<h3><a class="toc-backref" href="#id42">8.1 CoreOS</a><a class="headerlink" href="#coreos" title="Permalink to this heading">¶</a></h3>
<p>CoreOS项目基于Python语言，遵循Apache
2.0许可，由CoreOS团队在2013年7月发起，目前已经正式发布首个稳定版本。项目官方网址为https://coreos.com/，代码在https://github.com/coreos维护。</p>
<p>CoreOS项目目标是提供一个基于Rocket容器的轻量级容器化Linux发行版，通过轻量的系统架构和灵活的应用部署能力来简化数据中心的维护成本和复杂度。</p>
<p>CoreOS基于一套精简的Linux环境，不使用包管理工具，而将所有应用都进行容器化，彼此隔离，从而提高了系统的安全性。此外，运行期间，系统分区是只读状态，利用主从分区支持更稳定的无缝升级。</p>
<p>配合Etcd（分布式高可用的键值数据库）、Fleet（分布式init任务管理）、Flannel（Overlay网络管理）等工具，CoreOS也将适用于大规模集群环境。</p>
<p>该项目目前得到了KPCB等多家基金的投资。</p>
</section>
<section id="openstack">
<h3><a class="toc-backref" href="#id43">8.2 OpenStack支持</a><a class="headerlink" href="#openstack" title="Permalink to this heading">¶</a></h3>
<p>OpenStack是近些年Linux基金会发起的，最受欢迎的云开源项目。项目的官方网站在http://www.openstack.org。</p>
<p>项目遵循Apache许可，受到包括IBM、Cisco、AT&amp;T、HP、Rackspace等众多企业的大力支持。</p>
<p>项目的目标是搭建一套开源的架构即服务（Infrastructure as a
Service，IaaS）实现方案，主要基于Python语言实现。</p>
<p>该项目孵化出来的众多子项目已经在业界产生了诸多影响。</p>
<p>OpenStack目前除了可以管理众多虚机外，其计算服务（Nova）已经支持了对Docker的驱动，此外，还支持通过Stack管理引擎Heat子项目来使用模板，从而管理Docker容器。</p>
</section>
<section id="dockerize">
<h3><a class="toc-backref" href="#id44">8.3 dockerize</a><a class="headerlink" href="#dockerize" title="Permalink to this heading">¶</a></h3>
<p>一般来说，要将一个应用放到容器里，需要考虑两方面的因素，一是应用依赖的配置信息；二是应用运行时候的输出日志信息。</p>
<p>dockerize是一个Go程序，试图简化这两方面的管理成本，目前代码在https://github.com/jwilder/dockerize维护。</p>
<p>dockerize主要可以提供两个功能，一是对于依赖于配置文件的应用，能自动提取环境变量并生成配置文件；二是将应用输出的日志信息重定向到STDOUT和STDERR。</p>
<p>下面给出一个简单的例子，比如要创建一个Nginx镜像，标准的Dockerfile内容为：</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="w"> </span><span class="s">ubuntu:16.04</span>
<span class="c"># Install Nginx.</span>
<span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">&quot;deb http://ppa.launchpad.net/nginx/stable/ubuntu trusty main&quot;</span> &gt; /etc/apt/sources.list.d/nginx-stable-trusty.list

<span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">&quot;deb-src http://ppa.launchpad.net/nginx/stable/ubuntu trusty main&quot;</span> &gt;&gt; /etc/apt/sources.list.d/nginx-stable-trusty.list

<span class="k">RUN</span><span class="w"> </span>apt-key adv --keyserver keyserver.ubuntu.com --recv-keys C300EE8C

<span class="k">RUN</span><span class="w"> </span>apt-get update

<span class="k">RUN</span><span class="w"> </span>apt-get install -y nginx

<span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">&quot;daemon off;&quot;</span> &gt;&gt; /etc/nginx/nginx.conf

<span class="k">EXPOSE</span><span class="w"> </span><span class="s">80</span>
<span class="k">CMD</span><span class="w"> </span>nginx
</pre></div>
</div>
<p>到标准输出。</p>
<p>首先，创建配置模板文件为default.tmpl，内容是：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>server {
    listen 80 default_server;
    listen [::]:80 default_server ipv6only=on;
    root /usr/share/nginx/html;
    index index.html index.htm;
    # Make site accessible from http://localhost/
    server_name localhost;
    location / {
        access_log off;
        proxy_pass {{ .Env.PROXY_URL }};
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
</pre></div>
</div>
<p>该模板将接收来自环境变量PROXY_URL的值。</p>
<p>编辑新的Dockerfile内容为：</p>
<div class="highlight-dockerfile notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="w"> </span><span class="s">ubuntu:16.04</span>
<span class="c"># Install Nginx.</span>
<span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">&quot;deb http://ppa.launchpad.net/nginx/stable/ubuntu trusty main&quot;</span> &gt; /etc/apt/sources.list.d/nginx-stable-trusty.list

<span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">&quot;deb-src http://ppa.launchpad.net/nginx/stable/ubuntu trusty main&quot;</span> &gt;&gt; /etc/apt/sources.list.d/nginx-stable-trusty.list

<span class="k">RUN</span><span class="w"> </span>apt-get install -y wget nginx

<span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">&quot;daemon off;&quot;</span> &gt;&gt; /etc/nginx/nginx.conf

<span class="k">RUN</span><span class="w"> </span>wget https://github.com/jwilder/dockerize/releases/download/v0.0.1/dockerize-linux-amd64-v0.0.1.tar.gz

<span class="k">RUN</span><span class="w"> </span>tar -C /usr/local/bin -xvzf dockerize-linux-amd64-v0.0.1.tar.gz

<span class="k">ADD</span><span class="w"> </span>default.tmpl /etc/nginx/sites-available/default.tmpl

<span class="k">EXPOSE</span><span class="w"> </span><span class="s">80</span>
<span class="k">CMD</span><span class="w"> </span>dockerize -template /etc/nginx/sites-available/default.tmpl:/etc/nginx/sites-available/default -stdout /var/log/nginx/access.log -stderr /var/log/nginx/error.log nginx
</pre></div>
</div>
<p>最后的CMD命令中利用-template参数指定了配置模板位置，以及生成的配置文件的位置。</p>
<p>创建镜像后，通过如下的方式启动一个容器，整个过程无须手动添加Nginx的配置文件，并且日志重定向到了标准输出：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker run -p <span class="m">80</span>:80 -e <span class="nv">PROXY_URL</span><span class="o">=</span><span class="s2">&quot;http://jasonwilder.com&quot;</span> --name nginx -d nginx
</pre></div>
</div>
</section>
<section id="unikernel">
<h3><a class="toc-backref" href="#id45">8.4 Unikernel</a><a class="headerlink" href="#unikernel" title="Permalink to this heading">¶</a></h3>
<p>Unikernel是轻量级的精简内核技术，项目地址为http://www.unikernel.org。</p>
<p>不同于传统的支持多用户多应用的操作系统内核，Unikernel技术的目的是为运行的应用编译链接进入所需要的操作系统函数，形成一个单独的编译映像，内核只提供单一地址空间。</p>
<p>无须其他无关的软件，这个映像就可以运行在虚拟机中。</p>
<p>应用实际上仍然运行在各自的超轻量级虚拟机中。比较流行的Unikernel系统包括：</p>
<ul class="simple">
<li><p>ClickOS：NEC提出的专门为网络应用优化的系统，支持C、C++和Python；</p></li>
<li><p>Clive：面向云环境的精简操作系统，基于Golang实现；</p></li>
<li><p>HaLVM：早期Unikernels系统之一，基于Haskell语言实现；</p></li>
<li><p>LING：早期Unikernels系统之一，基于Erlang语言实现；</p></li>
<li><p>MirageOS：早期Unikernels系统之一，基于Ocaml语言实现；</p></li>
<li><p>OSv：基于Java，支持绝大多数jar文件部署和运行。</p></li>
<li><p>Rumprun：基于NetBSD项目，专注于符合POSIX标准的、不需要Fork的应用程序，方便将现有Linux程序移植到Unikernel上；</p></li>
<li><p>runtime.js：基于JavaScript v8引擎的操作系统，支持JavaScript应用。</p></li>
</ul>
<p>目前，专注于Unikernel技术的Unikernel
Systems公司已被Docker公司收购，作为对容器技术未来方向的探索和补充。</p>
</section>
<section id="id13">
<h3><a class="toc-backref" href="#id46">8.5 容器化的虚拟机</a><a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h3>
<p>不少企业应用仍运行在传统的虚拟机中，这些应用希望吸收容器高性能、便捷的优势，也不想放弃虚拟机的安全性特点。</p>
<p>因此，出现了一些开源项目试图让虚拟机的hypervisor来支持容器格式，代表性的有Hyper项目。Hyper项目的官方网址为https://www.hyper.sh/。</p>
<p>Hyper项目试图让容器用户仍然像使用容器一样来操作Hyper容器。</p>
<p>只不过Hyper容器不同于传统的容器，它带有精简的操作系统内核。因此，从核心上说它是一个轻量级的虚拟机镜像，可以直接跑在hypervisor上，但是借鉴了来自容器的优秀设计，提供十分快速的体验。</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="23.Kubernetes-%E7%94%9F%E4%BA%A7%E7%BA%A7%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%B9%B3%E5%8F%B0.html" class="btn btn-neutral float-left" title="Kubernetes-生产级容器集群平台" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="25.%E9%99%84%E5%BD%95.html" class="btn btn-neutral float-right" title="附录" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>