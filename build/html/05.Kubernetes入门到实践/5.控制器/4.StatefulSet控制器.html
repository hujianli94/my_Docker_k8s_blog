<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>StatefulSet控制器 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="其他控制器" href="5.%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E5%99%A8.html" />
    <link rel="prev" title="Job与CronJob控制器" href="3.Job%E4%B8%8ECronJob%E6%8E%A7%E5%88%B6%E5%99%A8.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> 小健_Docker_K8s_Blog
            <img src="../../_static/docker-k8s.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../01.Docker%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%983%E7%89%88/index.html">01.Docker技术入门与实战3版</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../02.Kubernetes%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/index.html">02.Kubernetes实战指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../03.Docker%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B/index.html">03.Docker经典实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../04.Prometheus%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/index.html">04.Prometheus监控运维实战</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">05.Kubernetes入门到实践</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../1.%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/index.html">1.容器的发展史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2.Kubernetes%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/index.html">2.Kubernetes的核心概念</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3.Kubernetes%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/index.html">3.Kubernetes的安装和部署</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4.Pod/index.html">4.Pod的基本操作</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">5.控制器</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="1.Deployment%E6%8E%A7%E5%88%B6%E5%99%A8.html">Deployment控制器</a></li>
<li class="toctree-l3"><a class="reference internal" href="2.DaemonSet%E6%8E%A7%E5%88%B6%E5%99%A8.html">DaemonSet控制器</a></li>
<li class="toctree-l3"><a class="reference internal" href="3.Job%E4%B8%8ECronJob%E6%8E%A7%E5%88%B6%E5%99%A8.html">Job与CronJob控制器</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">StatefulSet控制器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">1.statefulset的组成</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">2.为什么要用StatefulSet控制器？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">3.StatefulSet控制器的基本操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pvcpv">4.PVC及PV的使用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#service">5.无头Service的访问</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pod">6.Pod的重建</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">7.StatefulSet控制器的伸缩与更新</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="5.%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E5%99%A8.html">其他控制器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../6.Service%E5%92%8CIngress/index.html">6.Service和Ingress</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7.%E5%AD%98%E5%82%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/index.html">7.存储与配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8.Kubernetes%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E5%8F%8A%E8%B0%83%E5%BA%A6/index.html">8.Kubernetes资源的管理及调度</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9.API-Server/index.html">9.API-Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10.Kubernetes%E7%9A%84%E6%89%A9%E5%B1%95/index.html">10.Kubernetes的扩展</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11.%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B/index.html">11.项目部署案例</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12.Helm%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/index.html">12.Helm学习指南</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">小健_Docker_K8s_Blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">05.Kubernetes入门到实践</a> &raquo;</li>
          <li><a href="index.html">5.控制器</a> &raquo;</li>
      <li>StatefulSet控制器</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/05.Kubernetes入门到实践/5.控制器/4.StatefulSet控制器.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#statefulset" id="id5">StatefulSet控制器</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id6">1.statefulset的组成</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id7">2.为什么要用StatefulSet控制器？</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id8">3.StatefulSet控制器的基本操作</a></p></li>
<li><p><a class="reference internal" href="#pvcpv" id="id9">4.PVC及PV的使用</a></p></li>
<li><p><a class="reference internal" href="#service" id="id10">5.无头Service的访问</a></p></li>
<li><p><a class="reference internal" href="#pod" id="id11">6.Pod的重建</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id12">7.StatefulSet控制器的伸缩与更新</a></p>
<ul>
<li><p><a class="reference internal" href="#stsdeployment" id="id13">7.1 sts和deployment的滚动更新差异</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="statefulset">
<h1><a class="toc-backref" href="#id5">StatefulSet控制器</a><a class="headerlink" href="#statefulset" title="Permalink to this headline">¶</a></h1>
<p>StatefulSet控制器是一种提供排序和唯一性保证的特殊Pod控制器。当有与部署顺序、持久数据或固定网络等相关的特殊需求时，可
以使用StatefulSet控制器来进行更细粒度的控制。</p>
<p>StatefulSet控制器通常与面向数据的应用程序（如数据库）关联，它即使被重新分配到一个新的节点上，还是需要访问同一个存储卷的。</p>
<p>StatefulSet控制器对应于有状态服务（Deployment控制器对应于无状态服务），前者的功能如下所示。</p>
<ul class="simple">
<li><p>实现稳定的持久化存储：Pod重新调度后还能访问相同的持久化数据，可基于PVC来实现。</p></li>
<li><p>实现稳定的网络标识：Pod重新调度后其PodName和HostName不变，基于无头Service（没有Cluster
IP的Service）来实现。</p></li>
<li><p>实现有序部署、有序伸缩：Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次执行（即从第一个到最后一个依次部
署，在下一个Pod运行之前所有的Pod必须都处于Running或Ready状态）。</p></li>
<li><p>实现有序收缩、有序删除：从最后一个开始，依次删除到第一个。</p></li>
</ul>
<p>创建StatefulSet资源之前，先要保证集群中存在StorageClass，并使用headless
service暴露服务
StatefulSet相较于Deployment，多了volumeClaimTemplates字段，即pvc存储的配置信息</p>
<p>yaml模板</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">apps/v1</span>      <span class="c1">#必填，版本号</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">StatefulSet</span>     <span class="c1">#必填，资源类型</span>
<span class="nt">metadata</span><span class="p">:</span>       <span class="c1">#必填，元数据</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;name&gt;-sts</span>     <span class="c1">#必填，资源名称</span>
  <span class="nt">namespace</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;namespace&gt;</span>    <span class="c1">#Pod所属的命名空间</span>
<span class="nt">spec</span><span class="p">:</span>         <span class="c1">#必填，部署的详细定义</span>
  <span class="nt">selector</span><span class="p">:</span> <span class="c1">#必填，标签选择</span>
    <span class="nt">matchLabels</span><span class="p">:</span> <span class="c1">#必填，标签匹配</span>
      <span class="nt">key</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;value&gt;</span> <span class="c1">#必填，通过此标签匹配对应pod&lt;key: value&gt;</span>
  <span class="nt">serviceName</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span> <span class="c1"># Headless Service资源名称</span>
  <span class="nt">replicas</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">int</span> <span class="c1"># 副本数量</span>
  <span class="nt">template</span><span class="p">:</span> <span class="c1">#必填，应用容器模版定义</span>
    <span class="nt">metadata</span><span class="p">:</span> <span class="c1">#必填，元数据</span>
      <span class="nt">labels</span><span class="p">:</span>  <span class="c1"># 标签</span>
        <span class="nt">key</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;value&gt;</span> <span class="c1">#必填，与上面matchLabels的标签相同</span>
    <span class="nt">spec</span><span class="p">:</span>
      <span class="nt">containers</span><span class="p">:</span> <span class="c1">#此处参考pod的containers</span>
  <span class="nt">volumeClaimTemplates</span><span class="p">:</span> <span class="c1">#必填，+pvc模板</span>
    <span class="p p-Indicator">-</span> <span class="nt">metadata</span><span class="p">:</span>       <span class="c1">#必填，元数据</span>
        <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;name&gt;-depolyment</span>     <span class="c1">#必填，资源名称</span>
      <span class="nt">spec</span><span class="p">:</span>
        <span class="nt">accessModes</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&quot;ReadWriteOnce</span><span class="nv"> </span><span class="s">|</span><span class="nv"> </span><span class="s">ReadOnlyMany</span><span class="nv"> </span><span class="s">|</span><span class="nv"> </span><span class="s">ReadWriteMany&quot;</span> <span class="p p-Indicator">]</span> <span class="c1">#必填，访问模式</span>
        <span class="nt">storageClassName</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">strint</span>  <span class="c1">#存储类名，改为集群中已存在的</span>
        <span class="nt">resources</span><span class="p">:</span> <span class="c1"># 存储卷需要占用的资源量最小值</span>
          <span class="nt">requests</span><span class="p">:</span> <span class="c1"># 请求空间大小</span>
            <span class="nt">storage</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1Gi</span> <span class="c1"># 空间大小值</span>
</pre></div>
</div>
<ul class="simple">
<li><p>yaml示例：以nginx服务使用nfs共享存储为例</p></li>
</ul>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="c1">#先定义了一个名为myapp-svc的Headless Service资源，用于为关联到的每个Pod资源创建DNS资源记录。</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Service</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-svc</span>
  <span class="nt">labels</span><span class="p">:</span>
    <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-svc</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">ports</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">web</span>
  <span class="nt">clusterIP</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">None</span>
  <span class="nt">selector</span><span class="p">:</span>
    <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-pod</span>

<span class="nn">---</span>
<span class="c1"># 定义多个使用NFS存储后端的PV，空间大小为2GB，仅支持单路的读写操作。</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">PersistentVolume</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">nfs-pv</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">capacity</span><span class="p">:</span>
    <span class="nt">storage</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">2Gi</span>
  <span class="nt">accessModes</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">ReadWriteOnce</span>
  <span class="nt">persistentVolumeReclaimPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Recycle</span>
  <span class="nt">storageClassName</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">nfs</span>
  <span class="nt">nfs</span><span class="p">:</span>
    <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/nfs/data1</span>
    <span class="nt">server</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">172.17.0.2</span>
<span class="nn">---</span>
<span class="c1"># 定义了一个名为myapp的StatefulSet资源，它通过Pod模板创建了两个Pod资源副本，并基于volumeClaimTemplates（存储卷申请模板）向nfs存储类请求动态供给PV，从而为每个Pod资源提供大小为1GB的专用存储卷。</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">apps/v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">StatefulSet</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-sts</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">selector</span><span class="p">:</span>
    <span class="nt">matchLabels</span><span class="p">:</span>
      <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-pod</span>
  <span class="nt">serviceName</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-svc</span>
  <span class="nt">replicas</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">2</span>
  <span class="nt">template</span><span class="p">:</span>
    <span class="nt">metadata</span><span class="p">:</span>
      <span class="nt">labels</span><span class="p">:</span>
        <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-pod</span>
    <span class="nt">spec</span><span class="p">:</span>
      <span class="nt">containers</span><span class="p">:</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">nginx</span>
        <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">k8s.gcr.io/nginx-slim:0.8</span>
        <span class="nt">ports</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="nt">containerPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
          <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">web</span>
        <span class="nt">volumeMounts</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-data</span>
          <span class="nt">mountPath</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/usr/share/nginx/html</span>
  <span class="nt">volumeClaimTemplates</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">metadata</span><span class="p">:</span>
      <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-data</span>
    <span class="nt">spec</span><span class="p">:</span>
      <span class="nt">accessModes</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&quot;ReadWriteOnce&quot;</span> <span class="p p-Indicator">]</span>
      <span class="nt">storageClassName</span><span class="p">:</span> <span class="s">&quot;nfs&quot;</span>
      <span class="nt">resources</span><span class="p">:</span>
        <span class="nt">requests</span><span class="p">:</span>
          <span class="nt">storage</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1Gi</span>
</pre></div>
</div>
<section id="id1">
<h2><a class="toc-backref" href="#id6">1.statefulset的组成</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>StatefulSet控制器由3个部分组成</p>
<ul class="simple">
<li><p>无头Service：用于为Pod资源标识符生成可解析的DNS记录。</p></li>
<li><p>volumeClaimTemplates：基于静态或动态PV供给方式为Pod资源提供专有的固定存储。</p></li>
<li><p>StatefulSet：管理Pod资源。</p></li>
</ul>
<p>StatefulSet控制器的组成</p>
<img alt="../../_images/image-20220412190044314.png" src="../../_images/image-20220412190044314.png" />
</section>
<section id="id2">
<h2><a class="toc-backref" href="#id7">2.为什么要用StatefulSet控制器？</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Deployment控制器下的每一个Pod都毫无区别地提供服务。</p>
<p>但StatefulSet控制器下的Pod则不同，虽然各个Pod的定义是一样的，但因为数据不同，所提供的服务是有差异的。</p>
<p>分布式存储系统就适合使用StatefulSet控制器，由Pod
A存储一部分数据并提供相关服务，由Pod B存储另一部分数据并提供相关服务。</p>
<p>又比如有些服务会临时保存客户请求的数据，如使用服务端Session方式存放部分信息的业务网站，由于Session的不同，Pod
A和Pod B能提供的服务也不尽相同，这种场景也适合使用StatefulSet控制器。</p>
<p>因为在上述场景下每一个有状态的Pod提供的服务都不一样，所以每一个Pod不能被随意取代，必须有序分配且必须为其分配唯一的标识。</p>
<p><strong>Pod名称将是它们的唯一标识符，和Deployment控制器下的Pod不同，即使有状态的Pod发生故障并被重建，Pod名称也会和原来的一模一样。</strong></p>
<p><em>因为各个有状态的Pod也必须要拥有一个唯一的网络标识符以访问具体的某个Pod，所以会用到无头Service，无头Service可以给每个</em>
<em>Pod分配一个唯一的DNS名称。</em></p>
<p>有状态的Pod都会使用到持久存储（如果没有持久存储，Pod发生故障时数据就没有了）。</p>
<p>如前所述，有状态的Pod的最大特点是各个Pod中的数据是不一样的，所以各个Pod无法共用同一个存储卷。</p>
<p><strong>需要单独分配各自的PV和PVC</strong></p>
<p>因为每个Pod要有各自专用的存储卷，所以并不是在Pod模板中定义（若在Pod模板中定义，那么每个Pod都用的同一个存储卷）StatefulSet控制器的存储卷配置，而是在StatefulSet控制器模板的volumeClaimTemplate属性中定义存储卷的申请模板，并会为每个
Pod生成不同的PVC且各自绑定PV，从而使各个Pod拥有各自专用的存储卷。</p>
<p><strong>因为每个Pod都会产生各自专用的PVC及PV，所以StatefulSet控制器的存储最好通过StorageClass来动态创建。</strong></p>
<p>当然，也可以通过手动创建各个预设的PV，只是这个过程会相当麻烦。</p>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id8">3.StatefulSet控制器的基本操作</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>定义模板文件，创建一个名为<code class="docutils literal notranslate"><span class="pre">examplestatefulset.yml</span></code>的模板文件</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Service</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplestatefulservice</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">selector</span><span class="p">:</span>
    <span class="nt">example</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">exampleforstateful</span>
  <span class="c1"># headless service</span>
  <span class="nt">clusterIP</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">None</span>
  <span class="nt">ports</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">protocol</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">TCP</span>
      <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">8080</span>
      <span class="nt">targetPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
  <span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ClusterIP</span>

<span class="nn">---</span>
<span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">apps/v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">StatefulSet</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplestatefulset</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">replicas</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">3</span>
  <span class="nt">serviceName</span><span class="p">:</span> <span class="s">&quot;examplestatefulservice&quot;</span>
  <span class="nt">selector</span><span class="p">:</span>
    <span class="nt">matchLabels</span><span class="p">:</span>
      <span class="nt">example</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">exampleforstateful</span>
  <span class="nt">template</span><span class="p">:</span>
    <span class="nt">metadata</span><span class="p">:</span>
      <span class="nt">labels</span><span class="p">:</span>
        <span class="nt">example</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">exampleforstateful</span>
    <span class="nt">spec</span><span class="p">:</span>
      <span class="nt">containers</span><span class="p">:</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">pythonserviceforstateful</span>
        <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">python:3.7</span>
        <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
        <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">]</span>
        <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;The</span><span class="nv"> </span><span class="s">host</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">$(hostname)&quot;</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">/dir/data;</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">&quot;&lt;p&gt;The</span><span class="nv"> </span><span class="s">host</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">$(hostname)&lt;/p&gt;&quot;</span><span class="nv"> </span><span class="s">&gt;</span><span class="nv"> </span><span class="s">index.html;</span><span class="nv"> </span><span class="s">python</span><span class="nv"> </span><span class="s">-m</span><span class="nv"> </span><span class="s">http.server</span><span class="nv"> </span><span class="s">80&#39;</span><span class="p p-Indicator">]</span>

        <span class="nt">volumeMounts</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">statefuldata</span>
          <span class="nt">mountPath</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/dir</span>
        <span class="nt">ports</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">http</span>
          <span class="nt">containerPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>

  <span class="nt">volumeClaimTemplates</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">metadata</span><span class="p">:</span>
        <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">statefuldata</span>
      <span class="nt">spec</span><span class="p">:</span>
        <span class="nt">accessModes</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&quot;ReadWriteOnce&quot;</span> <span class="p p-Indicator">]</span>
        <span class="nt">storageClassName</span><span class="p">:</span> <span class="s">&quot;managed-nfs-storage&quot;</span>
        <span class="nt">resources</span><span class="p">:</span>
          <span class="nt">requests</span><span class="p">:</span>
            <span class="nt">storage</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">200Mi</span>
</pre></div>
</div>
<p>这个模板主要分为3个部分。首先，创建了一个无头Service，其名称为examplestatefulservice。它会通过标签选择器关联到各个标签为
<code class="docutils literal notranslate"><span class="pre">example:</span> <span class="pre">exampleforstateful</span></code>的Pod上。</p>
<p>然后，创建了一个StatefulSet模板。该StatefulSet模板的前半部分的定义和Deployment模板相似，定义了3个Pod副本，其容器为
“python:3.7”镜像，其目的是搭建服务。在启动容器时，会先以追加方式向/dir/data文件写入一串文本”The
host is
<span class="math notranslate nohighlight">\((hostname)&quot;， 这串文本使用\)</span>(hostname)环境变量获取当前Pod名称。/dir目录通过volumeMounts属性映射到名为statefuldata的存储卷申请模板
上，这在写入文本时会直接写入存储卷中。</p>
<p>接下来，执行<code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">&quot;&lt;p&gt;The</span> <span class="pre">host</span> <span class="pre">is</span> <span class="pre">$(hostname)&lt;/p&gt;</span> <span class="pre">&quot;index.html</span></code>命令，将一段HTML代码插入index.html文件中，这样
在访问index.html时就可以知道访问的是哪个Pod。</p>
<p>另外，通过<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">http.server</span> <span class="pre">80</span></code>命令，搭建一个简单的Web服务，并令服务对应的端口为80。</p>
<p>StatefulSet模板的后半部分是存储卷申请模板，其定义的内容和PVC模板的差不多，但要注意，这里批量定义了PVC。
storageClassName属性设置为<strong>managed-nfs-storage</strong>，与上一节中创建的StorageClass名称保持一致。</p>
<p>requests为storage:200Mi，这表示为每一个Pod都申请200MiB的存储空间。</p>
<p>接下来，执行以下命令，创建StatefulSet控制器的相关资源。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplestatefulset.yml
</pre></div>
</div>
<p>在创建过程中，在不同时段通过<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">kubectl</span> <span class="pre">get</span> <span class="pre">pod</span></code>进行查看，会发现Pod是按照顺序依次创建的。</p>
<p>Kubernetes会先创建第一个Pod，第二个Pod处于Pending状态。</p>
<p>第一个Pod创建完毕后创建第二个Pod，此时第三个Pod处于Pending状态。</p>
<p>前两个Pod创建完毕后，再创建第三个Pod。Pod的名称和Deployment控制器下的Pod不一样，名称末尾并没有生成随机字符串，而是按照数字顺序从0开始依次向上累加。</p>
<p>StatefulSet控制器下有序创建的各个Pod</p>
<img alt="../../_images/image-20220418150055712.png" src="../../_images/image-20220418150055712.png" />
<p>通过以下命令，可以查看StatefulSet控制器的总体状态。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ kubectl get statefulset
NAME                 READY   AGE
examplestatefulset   <span class="m">3</span>/3     82s
</pre></div>
</div>
<p>通过以下命令，可以查看StatefulSet控制器的详细信息。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ kubectl describe statefulset examplestatefulset
Name:               examplestatefulset
Namespace:          default
CreationTimestamp:  Mon, <span class="m">18</span> Apr <span class="m">2022</span> <span class="m">14</span>:59:01 +0800
Selector:           <span class="nv">example</span><span class="o">=</span>exampleforstateful
Labels:             &lt;none&gt;
Annotations:        &lt;none&gt;
Replicas:           <span class="m">3</span> desired <span class="p">|</span> <span class="m">3</span> total
Update Strategy:    RollingUpdate
  Partition:        <span class="m">0</span>
Pods Status:        <span class="m">3</span> Running / <span class="m">0</span> Waiting / <span class="m">0</span> Succeeded / <span class="m">0</span> Failed
Pod Template:
  Labels:  <span class="nv">example</span><span class="o">=</span>exampleforstateful
  Containers:
   pythonserviceforstateful:
    Image:      python:3.7
    Port:       <span class="m">80</span>/TCP
    Host Port:  <span class="m">0</span>/TCP
    Command:
      sh
      -c
    Args:
      <span class="nb">echo</span> <span class="s2">&quot;The host is </span><span class="k">$(</span>hostname<span class="k">)</span><span class="s2">&quot;</span> &gt;&gt; /dir/data<span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;&lt;p&gt;The host is </span><span class="k">$(</span>hostname<span class="k">)</span><span class="s2">&lt;/p&gt;&quot;</span> &gt; index.html<span class="p">;</span> python -m http.server <span class="m">80</span>
    Environment:  &lt;none&gt;
    Mounts:
      /dir from statefuldata <span class="o">(</span>rw<span class="o">)</span>
  Volumes:  &lt;none&gt;
Volume Claims:
  Name:          statefuldata
  StorageClass:  managed-nfs-storage
  Labels:        &lt;none&gt;
  Annotations:   &lt;none&gt;
  Capacity:      200Mi
  Access Modes:  <span class="o">[</span>ReadWriteOnce<span class="o">]</span>
Events:
  Type    Reason            Age    From                    Message
  ----    ------            ----   ----                    -------
  Normal  SuccessfulCreate  5m6s   statefulset-controller  create Claim statefuldata-examplestatefulset-0 Pod examplestatefulset-0 <span class="k">in</span> StatefulSet e             xamplestatefulset success
  Normal  SuccessfulCreate  5m6s   statefulset-controller  create Pod examplestatefulset-0 <span class="k">in</span> StatefulSet examplestatefulset successful
  Normal  SuccessfulCreate  5m3s   statefulset-controller  create Claim statefuldata-examplestatefulset-1 Pod examplestatefulset-1 <span class="k">in</span> StatefulSet e             xamplestatefulset success
  Normal  SuccessfulCreate  5m3s   statefulset-controller  create Pod examplestatefulset-1 <span class="k">in</span> StatefulSet examplestatefulset successful
  Normal  SuccessfulCreate  3m47s  statefulset-controller  create Claim statefuldata-examplestatefulset-2 Pod examplestatefulset-2 <span class="k">in</span> StatefulSet e             xamplestatefulset success
  Normal  SuccessfulCreate  3m47s  statefulset-controller  create Pod examplestatefulset-2 <span class="k">in</span> StatefulSet examplestatefulset successful
</pre></div>
</div>
</section>
<section id="pvcpv">
<h2><a class="toc-backref" href="#id9">4.PVC及PV的使用</a><a class="headerlink" href="#pvcpv" title="Permalink to this headline">¶</a></h2>
<p>我们先检查存储卷的使用情况。此时如果通过<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">kubectl</span> <span class="pre">getpvc</span></code>以及<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">kubectl</span> <span class="pre">get</span> <span class="pre">pv</span></code>命令进行查询，可以看到StatefulSet
控制器为每个Pod都创建了各自专用的PVC及PV。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ kubectl get pv<span class="p">|</span>grep default/statefuldata-examplestatefulset
pvc-0bd1af19-8af1-41b1-ba61-8933ac9fb8f2   200Mi      RWO            Delete           Bound    default/statefuldata-examplestatefulset-2               managed-nfs-storage            6m46s
pvc-3144e3df-cf7c-46c6-a285-d2719b9d5161   200Mi      RWO            Delete           Bound    default/statefuldata-examplestatefulset-1               managed-nfs-storage            8m2s
pvc-9fa9ae39-a778-4d31-aa38-37c84de9d7fa   200Mi      RWO            Delete           Bound    default/statefuldata-examplestatefulset-0               managed-nfs-storage            8m4s

$ kubectl get pvc
NAME                                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS          AGE
statefuldata-examplestatefulset-0   Bound    pvc-9fa9ae39-a778-4d31-aa38-37c84de9d7fa   200Mi      RWO            managed-nfs-storage   7m41s
statefuldata-examplestatefulset-1   Bound    pvc-3144e3df-cf7c-46c6-a285-d2719b9d5161   200Mi      RWO            managed-nfs-storage   7m38s
statefuldata-examplestatefulset-2   Bound    pvc-0bd1af19-8af1-41b1-ba61-8933ac9fb8f2   200Mi      RWO            managed-nfs-storage   6m22s
</pre></div>
</div>
<p>任意挑选一个PV，通过<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">kubectl</span> <span class="pre">describe</span> <span class="pre">pv</span></code>命令查看详情，可以看到它在NFS服务器共享目录上创建的专用目录，</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ kubectl describe pv pvc-0bd1af19-8af1-41b1-ba61-8933ac9fb8f2
Name:            pvc-0bd1af19-8af1-41b1-ba61-8933ac9fb8f2
Labels:          &lt;none&gt;
Annotations:     pv.kubernetes.io/provisioned-by: fuseim.pri/ifs
Finalizers:      [kubernetes.io/pv-protection]
StorageClass:    managed-nfs-storage
Status:          Bound
Claim:           default/statefuldata-examplestatefulset-2
Reclaim Policy:  Delete
Access Modes:    RWO
VolumeMode:      Filesystem
Capacity:        200Mi
Node Affinity:   &lt;none&gt;
Message:
Source:
    Type:      NFS (an NFS mount that lasts the lifetime of a pod)
    Server:    192.168.1.60
    Path:      /nfstest/default-statefuldata-examplestatefulset-2-pvc-0bd1af19-8af1-41b1-ba61-8933ac9fb8f2
    ReadOnly:  false
Events:        &lt;none&gt;
</pre></div>
</div>
<p>在NFS服务器上执行以下命令，查看Pod是否已成功向该目录写入文件。</p>
<p>执行结果如下所示，可以看到Pod已成功向它的专属存储卷中写入数据。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cat /data/nfs/nfstest/default-statefuldata-examplestatefulset-0-pvc-9fa9ae39-a778-4d31-aa38-37c84de9d7fa/data
The host is examplestatefulset-0
</pre></div>
</div>
<p>对于其余两个Pod也是一样的，先通过<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">kubectl</span> <span class="pre">describe</span> <span class="pre">pv</span> <span class="pre">pvName</span></code>命令查看其专属目录位置，然后执行命令查看文件是否写入。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ kubectl describe pv pvc-3144e3df-cf7c-46c6-a285-d2719b9d5161
Name:            pvc-3144e3df-cf7c-46c6-a285-d2719b9d5161
Labels:          &lt;none&gt;
Annotations:     pv.kubernetes.io/provisioned-by: fuseim.pri/ifs
Finalizers:      <span class="o">[</span>kubernetes.io/pv-protection<span class="o">]</span>
StorageClass:    managed-nfs-storage
Status:          Bound
Claim:           default/statefuldata-examplestatefulset-1
Reclaim Policy:  Delete
Access Modes:    RWO
VolumeMode:      Filesystem
Capacity:        200Mi
Node Affinity:   &lt;none&gt;
Message:
Source:
    Type:      NFS <span class="o">(</span>an NFS mount that lasts the lifetime of a pod<span class="o">)</span>
    Server:    <span class="m">192</span>.168.1.60
    Path:      /nfstest/default-statefuldata-examplestatefulset-1-pvc-3144e3df-cf7c-46c6-a285-d2719b9d5161
    ReadOnly:  <span class="nb">false</span>
Events:        &lt;none&gt;

$ cat /data/nfs/nfstest/default-statefuldata-examplestatefulset-1-pvc-3144e3df-cf7c-46c6-a285-d2719b9d5161/data
The host is examplestatefulset-1
</pre></div>
</div>
<p>结果：每个Pod都往各自的存储卷中写入了数据。</p>
</section>
<section id="service">
<h2><a class="toc-backref" href="#id10">5.无头Service的访问</a><a class="headerlink" href="#service" title="Permalink to this headline">¶</a></h2>
<p>我们检查Service的发布情况。使用<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">kubectl</span> <span class="pre">get</span> <span class="pre">svc</span></code>命令可以看到已经创建了一个无头Service。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ kubectl get svc
NAME                     TYPE        CLUSTER-IP   EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>    AGE
examplestatefulservice   ClusterIP   None         &lt;none&gt;        <span class="m">8080</span>/TCP   11m
kubernetes               ClusterIP   <span class="m">10</span>.96.0.1    &lt;none&gt;        <span class="m">443</span>/TCP    173d
</pre></div>
</div>
<p>由于这个Service无法由集群内外的机器直接访问，因此只能由Pod访问，而且需要通过DNS形式来访问，具体访问形式为
<code class="docutils literal notranslate"><span class="pre">{ServiceName}.{Namespace}.svc.{ClusterDomain}</span></code>。</p>
<p><strong>svc是Service的缩写（固定格式）；</strong></p>
<p><strong>ClusterDomain表示集群域，本例中默认的集群域为cluster.local；</strong></p>
<p><strong>前面两个字段则是根据Service定义决定的，在这个例子中ServiceName为examplestatefulservice，而Namespace我们没有在yml文件中指定，默认值为Default。</strong></p>
<p>在访问这个地址之前，我们先创建一个测试用的Pod，用它来尝试访问Service。命令如下。</p>
<p><code class="docutils literal notranslate"><span class="pre">examplepodforheadlessservice.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodforheadlessservice</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">testcontainer</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">docker.io/appropriate/curl</span>
    <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">]</span>
    <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;test</span><span class="nv"> </span><span class="s">pod</span><span class="nv"> </span><span class="s">for</span><span class="nv"> </span><span class="s">headless</span><span class="nv"> </span><span class="s">service!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>这个Pod并没有什么特别之处，其镜像为appropriate/curl。该镜像是一种工具箱，里面存放了一些测试网络和DNS使用的工具（例
如curl和nslookup等），可用于测试现在的Service。通过sleep3600命令，可让该容器长期处于运行状态。</p>
<p>通过模板创建Pod。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplepodforheadlessservice.yml
</pre></div>
</div>
<p>Pod创建完成后，就可以通过以下命令进入Pod内部，这样就可以在Pod内部执行命令行。</p>
<p>进入容器内部后，可以执行nslookup命令查询DNS信息，获得这个DNS下面的IP地址列表。之前已经提到，Kubernetes中的DNS资源访
问方式为{ServiceName}.{Namespace}.
svc.{ClusterDomain}，本例中的具体命令如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ kubectl exec -it pod/examplepodforheadlessservice -- /bin/sh
/ # nslookup examplestatefulservice.default.svc.cluster.local
nslookup: can&#39;t resolve &#39;(null)&#39;: Name does not resolve

Name:      examplestatefulservice.default.svc.cluster.local
Address 1: 10.0.16.28 examplestatefulset-1.examplestatefulservice.default.svc.cluster.local
Address 2: 10.0.32.106 examplestatefulset-2.examplestatefulservice.default.svc.cluster.local
Address 3: 10.0.36.231 examplestatefulset-0.examplestatefulservice.default.svc.cluster.local
</pre></div>
</div>
<p>可以看到，一共返回了3个IP地址，这些IP地址正是之前创建的各个Pod的IP地址，<em>而Kubernetes又为每个</em>
<em>Pod地址创建了对应的专属域名。访问这些专属域名就可以访问指定Pod提供的服务</em></p>
<p>当然，<strong>也可以直接使用无头Service的总域名来访问服务，如下面所示。通过这种方式访问的服务是随机的</strong>，这对于Deployment控制
器提供的无状态Pod没有问题，但如前所述，对于StatefulSet控制器提供的有状态Pod而言，每个Pod提供的服务都是不同的，在调用时必须指明调用哪一个Pod提供的服务。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span> <span class="c1"># curl examplestatefulservice.default.svc.cluster.local</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">host</span> <span class="ow">is</span> <span class="n">examplestatefulset</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">/</span> <span class="c1"># curl examplestatefulservice.default.svc.cluster.local</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">host</span> <span class="ow">is</span> <span class="n">examplestatefulset</span><span class="o">-</span><span class="mi">0</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">/</span> <span class="c1"># curl examplestatefulservice.default.svc.cluster.local</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">host</span> <span class="ow">is</span> <span class="n">examplestatefulset</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="o">/</span> <span class="c1"># curl examplestatefulservice.default.svc.cluster.local</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">host</span> <span class="ow">is</span> <span class="n">examplestatefulset</span><span class="o">-</span><span class="mi">2</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>在无头Service中，每一个Pod都会生成专属的访问域名，其访问格式为<code class="docutils literal notranslate"><span class="pre">{PodName}.</span> <span class="pre">{ServiceName}.{Namespace}.svc.</span> <span class="pre">{ClusterDomain}</span></code>。每个域名通过DNS查询都可以解析出Pod的IP地址，例如，使用以下命令</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span> <span class="c1"># nslookup examplestatefulset-0.examplestatefulservice.default.svc.cluster.local</span>
<span class="n">nslookup</span><span class="p">:</span> <span class="n">can</span><span class="s1">&#39;t resolve &#39;</span><span class="p">(</span><span class="n">null</span><span class="p">)</span><span class="s1">&#39;: Name does not resolve</span>

<span class="n">Name</span><span class="p">:</span>      <span class="n">examplestatefulset</span><span class="o">-</span><span class="mf">0.</span><span class="n">examplestatefulservice</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">svc</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">local</span>
<span class="n">Address</span> <span class="mi">1</span><span class="p">:</span> <span class="mf">10.0</span><span class="o">.</span><span class="mf">36.231</span> <span class="n">examplestatefulset</span><span class="o">-</span><span class="mf">0.</span><span class="n">examplestatefulservice</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">svc</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">local</span>


<span class="o">/</span> <span class="c1"># nslookup examplestatefulset-1.examplestatefulservice.default.svc.cluster.local</span>
<span class="n">nslookup</span><span class="p">:</span> <span class="n">can</span><span class="s1">&#39;t resolve &#39;</span><span class="p">(</span><span class="n">null</span><span class="p">)</span><span class="s1">&#39;: Name does not resolve</span>

<span class="n">Name</span><span class="p">:</span>      <span class="n">examplestatefulset</span><span class="o">-</span><span class="mf">1.</span><span class="n">examplestatefulservice</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">svc</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">local</span>
<span class="n">Address</span> <span class="mi">1</span><span class="p">:</span> <span class="mf">10.0</span><span class="o">.</span><span class="mf">16.28</span> <span class="n">examplestatefulset</span><span class="o">-</span><span class="mf">1.</span><span class="n">examplestatefulservice</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">svc</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">local</span>


<span class="o">/</span> <span class="c1"># nslookup examplestatefulset-2.examplestatefulservice.default.svc.cluster.local</span>
<span class="n">nslookup</span><span class="p">:</span> <span class="n">can</span><span class="s1">&#39;t resolve &#39;</span><span class="p">(</span><span class="n">null</span><span class="p">)</span><span class="s1">&#39;: Name does not resolve</span>

<span class="n">Name</span><span class="p">:</span>      <span class="n">examplestatefulset</span><span class="o">-</span><span class="mf">2.</span><span class="n">examplestatefulservice</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">svc</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">local</span>
<span class="n">Address</span> <span class="mi">1</span><span class="p">:</span> <span class="mf">10.0</span><span class="o">.</span><span class="mf">32.106</span> <span class="n">examplestatefulset</span><span class="o">-</span><span class="mf">2.</span><span class="n">examplestatefulservice</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">svc</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">local</span>
</pre></div>
</div>
<p>综上所述，要访问由不同的有状态Pod提供的服务，只需要访问其专属域名即可。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>/ <span class="c1"># curl examplestatefulset-0.examplestatefulservice.default.svc.cluster.local</span>
&lt;p&gt;The host is examplestatefulset-0&lt;/p&gt;

/ <span class="c1"># curl examplestatefulset-1.examplestatefulservice.default.svc.cluster.local</span>
&lt;p&gt;The host is examplestatefulset-1&lt;/p&gt;

/ <span class="c1"># curl examplestatefulset-2.examplestatefulservice.default.svc.cluster.local</span>
&lt;p&gt;The host is examplestatefulset-2&lt;/p&gt;
</pre></div>
</div>
<p>可以看到每个域名都可以成功返回各自的结果。</p>
</section>
<section id="pod">
<h2><a class="toc-backref" href="#id11">6.Pod的重建</a><a class="headerlink" href="#pod" title="Permalink to this headline">¶</a></h2>
<p>可以模拟Pod发生故障时的场景。假设现在examplestatefulset-1发生故障（例如，人为删除），请执行以下命令。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ kubectl delete pod/examplestatefulset-1
</pre></div>
</div>
<p>因为在之前模板中replicas设置为3，这表示会保留3个稳定副本，所以Pod会重建。可以看到，Pod
重建后的名称一模一样，Pod的 IP地址会有变化（但不会有实际影响）。</p>
<p>如图：</p>
<img alt="../../_images/image-20220419093308991.png" src="../../_images/image-20220419093308991.png" />
<p>执行以下命令，输出这个 Pod
专属的存储卷中文件的内容，查看是否仍然调用了同一个存储。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cat /data/nfs/nfstest/default-statefuldata-examplestatefulset-1-pvc-3144e3df-cf7c-46c6-a285-d2719b9d5161/data
The host is examplestatefulset-1
The host is examplestatefulset-1
</pre></div>
</div>
<p>因为在之前的Pod定义中Pod启动时会以追加文本的形式向文件中写入数据，所以Pod重建后，会再写一条数据。</p>
<p>因为重建后的Pod使用的还是同一个PVC和PV，所以仍然在同一个文件上进行编辑。</p>
<p>查询该文件会看到两条文本，一条是之前由被删除的Pod在启动时写的，一条是重建时写的</p>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id12">7.StatefulSet控制器的伸缩与更新</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>和Deployment控制器一样，StatefulSet控制器也可以实现动态伸缩，只需要修改配置模板中的replicas属性然后执行应用即可。</p>
<p>但与Deployment控制器不同的地方在于，Pod是有序伸缩的，就像创建StatefulSet控制器时依次创建Pod一样。在扩容时，后续新增的Pod会从前往后依次创建，创建完成后才开始下一个
Pod 的创建；</p>
<p>在缩容时，会先从编号最大的
Pod开始，从后往前依次删除，完全删除后才开始下一个Pod的删除。</p>
<p>StatefulSet控制器有<strong>两种更新策略</strong>，可以在模板中通过<strong>.spec.updateStrategy</strong>属性进行设置。</p>
<ul class="simple">
<li><p>OnDelete更新策略，这是默认的向后兼容的更新策略。使用OnDelete更新策略更新StatefulSet模板后，只有在手动删除旧的Pod时才会创建新的Pod。</p></li>
<li><p>RollingUpdate策略。在更新StatefulSet控制器模板后，旧的Pod将被终止，并且将以受控方式自动创建新的
Pod。</p></li>
</ul>
<section id="stsdeployment">
<h3><a class="toc-backref" href="#id13">7.1 sts和deployment的滚动更新差异</a><a class="headerlink" href="#stsdeployment" title="Permalink to this headline">¶</a></h3>
<p>StatefulSet控制器和Deployment控制器的滚动更新，有一些细节上的差异。</p>
<ul class="simple">
<li><p>因为StatefulSet控制器是有序的，所以它会从编号最大的Pod到最小的Pod依次更新，而且在更新前不会立即删除旧的Pod，而是
等新的Pod已完全创建完毕且处于Running状态时，才会替换并删除旧的Pod。</p></li>
<li><p>StatefulSet控制器拥有独有的更新属性<strong>.spec.updateStrategy.rollingUpdate.partition</strong>。这种方式类似于金丝雀部署，如果将partition设置为4，只有编号大于或等于4的Pod才会进行更新，编号小于partition的Pod将不会更新。如果已经更新的Pod通过验证，则再将partition改为0，更新其余Pod即可。</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="3.Job%E4%B8%8ECronJob%E6%8E%A7%E5%88%B6%E5%99%A8.html" class="btn btn-neutral float-left" title="Job与CronJob控制器" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="5.%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E5%99%A8.html" class="btn btn-neutral float-right" title="其他控制器" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>