<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pod的基本操作 &mdash; 运维开发修炼之路</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="5.控制器" href="../5.%E6%8E%A7%E5%88%B6%E5%99%A8/index.html" />
    <link rel="prev" title="4.Pod的基本操作" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> 小健_Docker_K8s_Blog
            <img src="../../_static/docker-k8s.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../01.Docker%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%983%E7%89%88/index.html">01.Docker技术入门与实战3版</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../02.Kubernetes%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/index.html">02.Kubernetes实战指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../03.Docker%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B/index.html">03.Docker经典实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../04.Prometheus%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/index.html">04.Prometheus监控运维实战</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">05.Kubernetes入门到实践</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../1.%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/index.html">1.容器的发展史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2.Kubernetes%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/index.html">2.Kubernetes的核心概念</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3.Kubernetes%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/index.html">3.Kubernetes的安装和部署</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">4.Pod的基本操作</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Pod的基本操作</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">1.创建Pod</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">2.查询Pod</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">3.修改Pod</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">4.删除Pod</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">5.Pod模板详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">6.Pod与容器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">7.Pod的生命周期</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">8.Pod的健康检查</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../5.%E6%8E%A7%E5%88%B6%E5%99%A8/index.html">5.控制器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6.Service%E5%92%8CIngress/index.html">6.Service和Ingress</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7.%E5%AD%98%E5%82%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/index.html">7.存储与配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8.Kubernetes%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E5%8F%8A%E8%B0%83%E5%BA%A6/index.html">8.Kubernetes资源的管理及调度</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9.API-Server/index.html">9.API-Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10.Kubernetes%E7%9A%84%E6%89%A9%E5%B1%95/index.html">10.Kubernetes的扩展</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11.%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B/index.html">11.项目部署案例</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12.Helm%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/index.html">12.Helm学习指南</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">小健_Docker_K8s_Blog</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">05.Kubernetes入门到实践</a> &raquo;</li>
          <li><a href="index.html">4.Pod的基本操作</a> &raquo;</li>
      <li>Pod的基本操作</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/05.Kubernetes入门到实践/4.Pod/1.Pod的基本操作.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#pod" id="id23">Pod的基本操作</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id24">1.创建Pod</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id25">2.查询Pod</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id26">3.修改Pod</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id27">4.删除Pod</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id28">5.Pod模板详解</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id29">6.Pod与容器</a></p>
<ul>
<li><p><a class="reference internal" href="#id7" id="id30">6.1 Pod创建容器的方式</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id31">6.2 Pod组织容器的方式</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id12" id="id32">7.Pod的生命周期</a></p>
<ul>
<li><p><a class="reference internal" href="#id13" id="id33">7.1 Pod的相位</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id34">7.2 Pod的重启策略</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id35">7.3 Pod的创建与销毁过程</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id36">7.4 Pod的生命周期事件</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id20" id="id37">8.Pod的健康检查</a></p>
<ul>
<li><p><a class="reference internal" href="#id21" id="id38">1.存活探针的使用</a></p></li>
<li><p><a class="reference internal" href="#id22" id="id39">2.就绪探针的使用</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="pod">
<h1><a class="toc-backref" href="#id23">Pod的基本操作</a><a class="headerlink" href="#pod" title="Permalink to this headline">¶</a></h1>
<section id="id1">
<h2><a class="toc-backref" href="#id24">1.创建Pod</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">examplepod.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepod</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepod-container</span>
      <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
      <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
      <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span> <span class="p p-Indicator">]</span>
      <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;Hello</span><span class="nv"> </span><span class="s">Kubernetes!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span> <span class="p p-Indicator">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>apiVersion表示使用的API版本。</p></li>
<li><p>kind表示要创建的资源对象，这里使用关键字Pod。</p></li>
<li><p>metadata表示该资源对象的元数据。一个资源对象可拥有多个元数据，其中一项是name，它表示当前资源的名称。</p></li>
<li><p>spec表示该资源对象的具体设置。</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>name：要创建的容器名称。
image：容器的镜像地址。
imagePullPolicy：镜像的下载策略


imagePullPolicy，如下所示。
    - Always：不管镜像是否存在都会进行一次拉取。
    - Never：不管镜像是否存在都不会进行拉取。
    - IfNotPresent：只有镜像不存在时，才会进行拉取


command：容器的启动命令列表（不配置的话，使用镜像内部的命令）。

args：启动参数列表（在本例中是输出文字“Hello Kubernetes!”并休眠3600s）
</pre></div>
</div>
<p>apply是一种声明式对象配置命令。这里应用了之前创建的模板，-f参数表示使用文件名作为参数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kubectl</span> <span class="n">apply</span> <span class="o">-</span><span class="n">f</span> <span class="n">examplepod</span><span class="o">.</span><span class="n">yml</span>
</pre></div>
</div>
<p><strong>如何在Kubernetes上保持容器运行？</strong></p>
<p>容器应运而生。您需要为您的容器提供永远无法完成的任务。这样的事情应该起作用：</p>
<p><strong>1.睡眠命令</strong></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
  <span class="nt">labels</span><span class="p">:</span>
    <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">ports</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">containerPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&quot;/bin/sh&quot;</span><span class="p p-Indicator">,</span> <span class="s">&quot;-ec&quot;</span><span class="p p-Indicator">,</span> <span class="s">&quot;sleep</span><span class="nv"> </span><span class="s">1000&quot;</span><span class="p p-Indicator">]</span>
  <span class="nt">nodeSelector</span><span class="p">:</span>
    <span class="nt">beta.kubernetes.io/os</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">linux</span>
</pre></div>
</div>
<p><strong>2.无限循环</strong></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ubuntu</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ubuntu</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ubuntu:latest</span>
    <span class="c1"># Just spin &amp; wait forever</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&quot;/bin/bash&quot;</span><span class="p p-Indicator">,</span> <span class="s">&quot;-c&quot;</span><span class="p p-Indicator">,</span> <span class="s">&quot;--&quot;</span> <span class="p p-Indicator">]</span>
    <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&quot;while</span><span class="nv"> </span><span class="s">true;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">30;</span><span class="nv"> </span><span class="s">done;&quot;</span> <span class="p p-Indicator">]</span>
</pre></div>
</div>
<p><strong>dockerfile的做法</strong></p>
<ol class="arabic">
<li><p>在您的Dockerfile中，使用以下命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;sh&quot;</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;tail -f /dev/null&quot;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>构建您的docker映像。</p></li>
<li><p>将其推送到您的群集或类似的群集中，只是为了确保它可用。</p></li>
<li><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kubectl</span> <span class="n">run</span> <span class="n">debug</span><span class="o">-</span><span class="n">container</span> <span class="o">-</span><span class="n">it</span> <span class="o">--</span><span class="n">image</span><span class="o">=&lt;</span><span class="n">your</span><span class="o">-</span><span class="n">image</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id2">
<h2><a class="toc-backref" href="#id25">2.查询Pod</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl get pod <span class="o">{</span>Pod名称<span class="o">}</span>

$ kubectl get pod <span class="o">{</span>Pod名称<span class="o">}</span> -w

$ kubectl get pod <span class="o">{</span>Pod名称<span class="o">}</span> -o wide

<span class="c1">#查询Pod更详细的信息将其输出为yaml或json格式</span>
$ kubectl get pod examplepod --output yaml
$ kubectl get pod examplepod --output json


<span class="c1"># 根据selector便签进行查询</span>
$ kubectl get pods --selector<span class="o">=</span><span class="nv">example</span><span class="o">=</span>exampleforservice

<span class="c1">#使用describe命令查看详情</span>
$ kubectl describe pods <span class="o">{</span>Pod名称<span class="o">}</span>

<span class="c1">#如果要查询Pod本身输出的日志信息，还可以使用logs命令</span>
$ kubectl logs <span class="o">{</span>Pod名称<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># k get pod examplepod</span>
NAME         READY   STATUS    RESTARTS   AGE
examplepod   <span class="m">1</span>/1     Running   <span class="m">0</span>          34s
</pre></div>
</div>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id26">3.修改Pod</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ kubectl replace -f {pod模板路径}
</pre></div>
</div>
<p>修改之前示例中定义的Pod，使它输出“Hello 2022!”</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepod</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepod-container</span>
      <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
      <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
      <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span> <span class="p p-Indicator">]</span>
      <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;Hello</span><span class="nv"> </span><span class="s">2022!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span> <span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>提示：Pod有很多属性无法修改，比如containers的image属性，spec下的activeDeadline
Seconds、tolerations属性等。</p>
<p>如果一定要修改，则需要加上–force参数，相当于重新创建Pod，命令如下。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl replace -f <span class="o">{</span>pod模板路径<span class="o">}</span> --force
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kubectl</span> <span class="n">replace</span> <span class="o">-</span><span class="n">f</span> <span class="n">examplepod</span><span class="o">.</span><span class="n">yml</span> <span class="o">--</span><span class="n">force</span>
</pre></div>
</div>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id27">4.删除Pod</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl delete pod <span class="o">{</span>Pod名称<span class="o">}</span>
</pre></div>
</div>
<p>还可以基于模板文件删除资源</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl delete -f <span class="o">{</span>模板文件名称<span class="o">}</span>
</pre></div>
</div>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id28">5.Pod模板详解</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>实际生产环境中很少直接创建pod资源，基本都是通过资源控制器对pod进行管理。</p>
<ul class="simple">
<li><p>yaml模板：</p></li>
</ul>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>      <span class="c1">#必填，版本号</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>     <span class="c1">#必填，资源类型</span>
<span class="nt">metadata</span><span class="p">:</span>       <span class="c1">#必填，元数据</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;name&gt;-Depolyment</span>     <span class="c1">#必填，资源名称</span>
  <span class="nt">namespace</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;namespace&gt;</span>    <span class="c1">#Pod所属的命名空间</span>
  <span class="nt">labels</span><span class="p">:</span>      <span class="c1">#自定义标签</span>
  <span class="p p-Indicator">-</span> <span class="nt">key</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;value&gt;</span>     <span class="c1">#自定义标签名字&lt;key: value&gt;</span>
  <span class="nt">annotations</span><span class="p">:</span>        <span class="c1">#自定义注解列表</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;string&gt;</span>        <span class="c1">#自定义注解名字</span>
<span class="nt">spec</span><span class="p">:</span>         <span class="c1">#必填，部署的详细定义</span>
  <span class="nt">containers</span><span class="p">:</span>      <span class="c1">#必填，定义容器列表</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;name&gt;</span>     <span class="c1">#必填，容器名称</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;image-name&gt;</span>    <span class="c1">#必填，容器的镜像名称</span>
    <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="nv">Always | Never | IfNotPresent</span><span class="p p-Indicator">]</span> <span class="c1">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="nv">array</span><span class="p p-Indicator">]</span>    <span class="c1">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span>
    <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="nv">string</span><span class="p p-Indicator">]</span>     <span class="c1">#容器的启动命令参数列表</span>
    <span class="nt">workingDir</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#选填，容器的工作目录</span>
    <span class="nt">env</span><span class="p">:</span>       <span class="c1">#容器运行前需设置的环境变量列表</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#环境变量名称</span>
      <span class="nt">value</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>    <span class="c1">#环境变量的值</span>
    <span class="nt">ports</span><span class="p">:</span>       <span class="c1">#需要暴露的端口库号列表</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#端口号名称</span>
      <span class="nt">containerPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">int</span>   <span class="c1">#容器需要监听的端口号</span>
      <span class="nt">hostPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">int</span>    <span class="c1">#容器所在主机需要监听的端口号，默认与Container相同</span>
      <span class="nt">protocol</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#端口协议，支持TCP和UDP，默认TCP</span>
    <span class="nt">resources</span><span class="p">:</span>       <span class="c1">#建议填写，资源限制和请求的设置</span>
      <span class="nt">limits</span><span class="p">:</span>      <span class="c1">#资源限制的设置</span>
        <span class="nt">cpu</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>    <span class="c1">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span>
        <span class="nt">memory</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span>
      <span class="nt">requests</span><span class="p">:</span>      <span class="c1">#资源请求的设置</span>
        <span class="nt">cpu</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>    <span class="c1">#Cpu请求，容器启动的初始可用数量</span>
        <span class="nt">memory</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#内存请求，容器启动的初始可用数量</span>
    <span class="nt">volumeMounts</span><span class="p">:</span>    <span class="c1">#挂载到容器内部的存储卷配置</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span>
      <span class="nt">mountPath</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>    <span class="c1">#存储卷在容器内mount的绝对路径，应少于512字符</span>
      <span class="nt">readOnly</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">boolean</span>    <span class="c1">#是否为只读模式</span>
    <span class="nt">livenessProbe</span><span class="p">:</span>     <span class="c1">#建议填写，对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span>
      <span class="nt">exec</span><span class="p">:</span>      <span class="c1">#对Pod容器内检查方式设置为exec方式</span>
        <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="nv">string</span><span class="p p-Indicator">]</span>  <span class="c1">#exec方式需要制定的命令或脚本</span>
      <span class="nt">httpGet</span><span class="p">:</span>       <span class="c1">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span>
        <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>
        <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">number</span>
        <span class="nt">host</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>
        <span class="nt">scheme</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>
        <span class="nt">HttpHeaders</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>
          <span class="nt">value</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>
      <span class="nt">tcpSocket</span><span class="p">:</span>     <span class="c1">#对Pod内个容器健康检查方式设置为tcpSocket方式</span>
        <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">number</span>
      <span class="nt">initialDelaySeconds</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">0</span>  <span class="c1">#容器启动完成后首次探测的时间，单位为秒</span>
      <span class="nt">timeoutSeconds</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">0</span>   <span class="c1">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span>
      <span class="nt">periodSeconds</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">0</span>    <span class="c1">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span>
      <span class="nt">successThreshold</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">0</span> <span class="c1">#处于失败状态时，探测操作至少连续多少次的成功才被认为是通过检测，显示为#success属性，默认值为1</span>
      <span class="nt">failureThreshold</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">0</span> <span class="c1">#处于成功状态时，探测操作至少连续多少次的失败才被视为是检测不通过，显示为#failure属性，默认值为3</span>
    <span class="nt">imagePullSecrets</span><span class="p">:</span>    <span class="c1">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>
    <span class="nt">hostNetwork</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">false</span>      <span class="c1">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span>
  <span class="nt">volumes</span><span class="p">:</span>       <span class="c1">#在该pod上定义共享存储卷列表</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#共享存储卷名称 （volumes类型有很多种）</span>
    <span class="nt">emptyDir</span><span class="p">:</span> <span class="p p-Indicator">{}</span>     <span class="c1">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span>
    <span class="nt">hostPath</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span>
    <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#Pod所在宿主机的目录，将被用于同期中mount的目录</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#共享存储卷名称</span>
    <span class="nt">secret</span><span class="p">:</span>      <span class="c1">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span>
      <span class="nt">scretname</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>
      <span class="nt">items</span><span class="p">:</span>
      <span class="p p-Indicator">-</span> <span class="nt">key</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#选择secrets定义的某个key</span>
        <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>    <span class="c1">#文件内容路径</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#共享存储卷名称</span>
    <span class="nt">configMap</span><span class="p">:</span>     <span class="c1">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span>
      <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>
      <span class="nt">items</span><span class="p">:</span>
      <span class="p p-Indicator">-</span> <span class="nt">key</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#选择configmap定义的某个key</span>
        <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#文件内容路径</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#共享存储卷名称</span>
    <span class="nt">persistentVolumeClaim</span><span class="p">:</span>
      <span class="nt">claimName</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#类型为PVC的持久化存储卷</span>
  <span class="nt">affinity</span><span class="p">:</span> <span class="c1"># 亲和调度</span>
    <span class="nt">nodeAffinity</span><span class="p">:</span> <span class="c1"># 节点亲和调度</span>
      <span class="nt">requiredDuringSchedulingIgnoredDuringExecution</span><span class="p">:</span> <span class="c1">#硬亲和调度 或preferredDuringSchedulingIgnoredDuringExecution 软亲和调度</span>
        <span class="nt">nodeSelectorTerms</span><span class="p">:</span> <span class="c1"># 选择条件</span>
          <span class="p p-Indicator">-</span> <span class="nt">matchExpressions</span><span class="p">:</span> <span class="c1"># 匹配规则</span>
              <span class="p p-Indicator">-</span> <span class="nt">key</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">key</span>
                <span class="nt">operator</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">In</span>
                <span class="nt">values</span><span class="p">:</span>
                  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">values</span>
  <span class="nt">nodeSelector</span><span class="p">:</span>  <span class="c1">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">string</span>     <span class="c1">#自定义标签名字&lt;key: value&gt;</span>
  <span class="nt">restartPolicy</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="nv">Always | Never | OnFailure</span><span class="p p-Indicator">]</span> <span class="c1">#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span>
</pre></div>
</div>
<ul class="simple">
<li><p>yaml示例：此处以最简单的busybox举例，添加容器启动命令参数</p></li>
</ul>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox-pod</span>
  <span class="nt">namespace</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">test</span>
  <span class="nt">labels</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox-pod</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox:latest</span>
    <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&quot;/bin/sh&quot;</span><span class="p p-Indicator">,</span><span class="s">&quot;-c&quot;</span><span class="p p-Indicator">,</span><span class="s">&quot;while</span><span class="nv"> </span><span class="s">true;do</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">hello;sleep</span><span class="nv"> </span><span class="s">1;done&quot;</span><span class="p p-Indicator">]</span>
  <span class="nt">restartPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Always</span>
</pre></div>
</div>
<p>可以使用<code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">explain</span> <span class="pre">pod</span></code>命令详细查看Pod资源所支持的所有字段的详细说明,对于spec字段可以使用命令$
kubectl explain pod.spec进行查看</p>
<p>查看k8s资源对象字段对照表</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl explain deploy --recursive<span class="o">=</span><span class="nb">true</span>
$ kubectl explain pod --recursive<span class="o">=</span><span class="nb">true</span>
$ kubectl explain server --recursive<span class="o">=</span><span class="nb">true</span>
</pre></div>
</div>
<p>如果要了解一个正在运行的Pod的配置，可以通过以下命令来获取。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl get pod <span class="o">{</span>pod名称<span class="o">}</span> -o yaml
</pre></div>
</div>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id29">6.Pod与容器</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<section id="id7">
<h3><a class="toc-backref" href="#id30">6.1 Pod创建容器的方式</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">examplepod.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepod</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepod-container</span>
      <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
      <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
      <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span> <span class="p p-Indicator">]</span>
      <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;Hello</span><span class="nv"> </span><span class="s">2022!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span> <span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>类似于docker上面执行了如下命令</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker run --name examplepod-container busybox sh -c <span class="s1">&#39;echo &quot;Hello Kubernetes!&quot;; sleep 3600&#39;</span>
</pre></div>
</div>
<blockquote>
<div><p>提示：command和args设置会分别覆盖原Docker镜像中定义的EntryPoint与CMD，在使用时请务必注意以下规则</p>
</div></blockquote>
<ul class="simple">
<li><p>如果没有在模板中提供command或args，则使用Docker镜像中定义的默认值运行。</p></li>
<li><p>如果在模板中提供了command，但未提供args，则仅使用提供的command。Docker镜像中定义的默认的EntryPoint和默认的命令都将被忽略。</p></li>
<li><p>如果只提供了args，则Docker镜像中定义的默认的EntryPoint将与所提供的args组合到一起运行。</p></li>
<li><p>如果同时提供了command和args，Docker镜像中定义的默认的EntryPoint和命令都将被忽略。所提供的command和args将会组合到一起运行。</p></li>
</ul>
<section id="volumemounts">
<h4>1.volumeMounts配置信息<a class="headerlink" href="#volumemounts" title="Permalink to this headline">¶</a></h4>
<p>创建examplepodforvolumemount.yml文件.</p>
<p><code class="docutils literal notranslate"><span class="pre">examplepodforvolumemount.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodforvolumemount</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">containerforwrite</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span> <span class="p p-Indicator">]</span>
    <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;test</span><span class="nv"> </span><span class="s">data!&quot;</span><span class="nv"> </span><span class="s">&gt;</span><span class="nv"> </span><span class="s">/write_dir/data;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span> <span class="p p-Indicator">]</span>

    <span class="nt">volumeMounts</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">filedata</span>
      <span class="nt">mountPath</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/write_dir</span>

  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">containerforread</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span> <span class="p p-Indicator">]</span>
    <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;cat</span><span class="nv"> </span><span class="s">/read_dir/data;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span> <span class="p p-Indicator">]</span>

    <span class="nt">volumeMounts</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">filedata</span>
      <span class="nt">mountPath</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/read_dir</span>

  <span class="nt">volumes</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">filedata</span>
    <span class="nt">emptyDir</span><span class="p">:</span> <span class="p p-Indicator">{</span> <span class="p p-Indicator">}</span>
</pre></div>
</div>
<p>在本例中，我们创建了两个容器。一个是containerforwrite，它向数据卷写入数据，会向/write_dir/data文件写入“test
data!”文本。</p>
<p>容器内的数据卷地址为/write_dir，它引用的存储卷为filedata</p>
<p>另一个容器是containerforread，TE会从/read_dir/data文件中读取文本，并将其输出到控制台（后续可以通过日志查询方式读取
输出到控制台的文本）。容器内的数据卷地址为/read_dir，它引用的存储卷为filedata。</p>
<p>执行以下命令，创建Pod。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplepodforvolumemount.yml
</pre></div>
</div>
<p>通过以下命令，查看Pod的运行情况，READY 2/2表示两个容器都已成功运行。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl get pod
NAME                       READY   STATUS    RESTARTS   AGE
examplepodforvolumemount   <span class="m">2</span>/2     Running   <span class="m">0</span>          56s

$ kubectl get pods examplepodforvolumemount
</pre></div>
</div>
<p>此时可以通过logs命令，查看Pod中containerforread容器的日志。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl logs examplepodforvolumemount containerforread
<span class="nb">test</span> data!
</pre></div>
</div>
<p>可以看到，containerforread容器已经读取到在containerforwrite容器中写入的文本，并已将其输出到控制台。</p>
</section>
<section id="ports">
<h4>2.ports配置信息<a class="headerlink" href="#ports" title="Permalink to this headline">¶</a></h4>
<p>容器运行时通常会提供一些机制以将容器端口暴露出来，并映射到主机的端口上，以便其他人能通过“主机IP:端口”访问容器所提供
的服务，例如，Docker的命令$ docker run -p {宿主机端口}:{容器端口}
{镜像名称}。同样，Pod模板中也提供了这个功能。</p>
<p><code class="docutils literal notranslate"><span class="pre">examplepodforport.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodforport</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">containerfornginx</span>
      <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">nginx</span>
      <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
      <span class="nt">ports</span><span class="p">:</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">portfoxnginx</span>
        <span class="nt">containerPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
        <span class="nt">hostPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">8081</span>
        <span class="nt">protocol</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">TCP</span>
</pre></div>
</div>
<p>在本例中，Nginx镜像中默认定义的对外提供服务的端口为80。通过containerPort属性，我们将80端口暴露出来，</p>
<p>再通过hostPort属性将其映射到宿主机的端口8081上，以便通过“主机IP:端口”访问容器所提供的服务，其中protocol为端口协议，支持TCP和UDP，默认为TCP。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplepodforport.yml
$ kubectl get pod examplepodforport
</pre></div>
</div>
<p>Pod创建完成后，执行以下命令，查看Pod具体被分配到哪台Node上。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl describe pods examplepodforport
Name:         examplepodforport
Namespace:    default
Priority:     <span class="m">0</span>
Node:         gitee-k8s-w28/192.168.1.81
</pre></div>
</div>
<p>执行结果如上，可以看到Pod被部署在<code class="docutils literal notranslate"><span class="pre">&quot;Node：gitee-k8s-w28/192.168.1.81&quot;</span></code>上。</p>
<p>通过浏览器访问刚才查到的IP地址，加上之前设置的映射到宿主机的端口号（在本例中为http://192.168.1.81:8081）</p>
<p>则可以访问Nginx的欢迎页面</p>
<img alt="../../_images/image-20220408163358776.png" src="../../_images/image-20220408163358776.png" />
<p>注意：以上案例仅为了说明Kubernetes是如何创建容器的，这种类似于Docker直接映射到主机端口的方式，在Kubernetes中强烈不推荐。</p>
<p>Pod只是一个运行服务的实例，随时可能在一个Node上停止，而在另一个Node上以新的IP地址启动新的Pod，因此它不能以稳定的IP地址
和端口号提供服务。若要稳定地提供服务，则需要服务发现和负载均衡能力。Kubernetes提供了Service抽象机制。</p>
</section>
<section id="env">
<h4>3.env配置信息<a class="headerlink" href="#env" title="Permalink to this headline">¶</a></h4>
<p>容器运行时通常还会提供一些机制来输入可动态配置的一些环境变量，以供容器中的应用程序使用。</p>
<p>如在Docker中，配置环境变量的命令为$ docker run –env {变量1}={值1} –env
{变量2}={值2} … {镜像名称}。</p>
<p>同样，Pod模板中也提供了这个功能，为了通过例子进行演示</p>
<p><code class="docutils literal notranslate"><span class="pre">examplepodforenv.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodforenv</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">containerforenv</span>
      <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
      <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
      <span class="nt">env</span><span class="p">:</span>
        <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">parameter1</span>
          <span class="nt">value</span><span class="p">:</span> <span class="s">&quot;good</span><span class="nv"> </span><span class="s">morning!&quot;</span>
        <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">parameter2</span>
          <span class="nt">value</span><span class="p">:</span> <span class="s">&quot;good</span><span class="nv"> </span><span class="s">night!&quot;</span>
      <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;-c&#39;</span> <span class="p p-Indicator">]</span>
      <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span> <span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;${parameter1}</span><span class="nv"> </span><span class="s">${parameter2}&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span> <span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>在模板中定义了一个名为containerforenv的容器，向它传入了两个环境变量：</p>
<p>其中一个名为parameter1，值为good morning!；</p>
<p>另一个变量名为parameter2，值为good night!。</p>
<p>在本例中，将通过在容器中执行命令的方式，将传入的两个环境变量拼接到一起并输出到日志。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplepodforenv.yml
$ kubectl get pods examplepodforenv
</pre></div>
</div>
<p>通过以下命令，查看Pod中输出的日志。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl logs pod/examplepodforenv
good morning! good night!
</pre></div>
</div>
<p>可以看到两个环境变量的值成功拼接到一起并输出到日志中.</p>
<p>在Docker中，环境变量不仅可以明文配置，还可以通过读取某个文件的方式从其他来源获取。</p>
<p>而Kubernetes还支持更丰富的配置方式，这会在后续章节中详述。</p>
</section>
</section>
<section id="id8">
<h3><a class="toc-backref" href="#id31">6.2 Pod组织容器的方式</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<section id="id9">
<h4>1.容器如何组成一个Pod<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>Pod只是一种抽象，并不是一个真正的物理实体，表示一组相关容器的逻辑划分。</p>
<p>每个Pod都包含一个或一组密切相关的业务容器，除此之外，每个Pod都还有一个称为“根容器”的特殊Pause容器</p>
<p>Pause容器其实属于Kubernetes的一部分。在一组容器作为一个单位的情况下，很难对整个容器组进行判断，如一个容器挂载了能代表
整个Pod都挂载了吗？</p>
<p>如果引入一个和业务无关的Pause容器，用它作为Pod的根容器，用它的状态代表整组容器的状态，便能解决该问题。</p>
<p><strong>另外，Pod中的所有容器都共享Pause容器的IP地址及其挂载的存储卷，这样也简化了容器之间的通信和数据共享问题。</strong></p>
<p><strong>另外，Pause容器还在Pod中担任Linux命名空间共享的基础，为各个容器启用pid命名空间，开启init进程。</strong></p>
<p>Pod中的容器可以使用Pod所提供的两种共享资源——存储和网络。</p>
<p>1）存储</p>
<p>在Pod中，可以指定一个或多个共享存储卷。Pod中的所有容器都可以访问共享存储卷，从而让这些容器共享数据。</p>
<p>存储卷也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。</p>
<p>2）网络</p>
<p>每个Pod都分配了唯一的IP地址。Pod中的每个容器都共享网络命名空间，包括IP地址和网络端口。</p>
<p>Pod内部的容器可以使用localhost互相通信。当Pod中的容器与Pod外部进行通信时，还必须共享网络资源（如使用端口映射）。</p>
<p>Docker和Kubernetes在网络空间上的差异。</p>
<img alt="../../_images/image-20220408171306313.png" src="../../_images/image-20220408171306313.png" />
<p>要查看Pod的IP，可以使用以下命令。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl get pod examplepodforenv --template<span class="o">={{</span>.status.podIP<span class="o">}}</span>
或者
$ kubectl get pod examplepodforenv -o wide
</pre></div>
</div>
</section>
<section id="id10">
<h4>2.Pod之间如何通信<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>Pod之间的通信主要涉及两个方面</p>
<section id="nodepod">
<h5>1.同一个Node上Pod之间的通信<a class="headerlink" href="#nodepod" title="Permalink to this headline">¶</a></h5>
<p>每一个Pod都有一个全局IP地址，同一个Node内不同Pod之间可以直接采用对方Pod的IP地址通信，而且不需要使用其他发现机制。</p>
<p>因为它们都是通过veth连接在同一个docker0网桥上的，其IP地址都是从docker0网桥上动态获取的，并关联在同一个docker0网桥上，地址段也相同，所以它们之间能直接通信。</p>
<p>同一个Node上Pod之间的通信</p>
<img alt="../../_images/image-20220408171859171.png" src="../../_images/image-20220408171859171.png" />
</section>
<section id="id11">
<h5>2.跨Node的Pod之间的通信<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>要实现跨Node的Pod之间的通信，首先需要保证的是Pod的IP地址在所有Node上都是全局唯一的。</p>
<p>这其实并不复杂，因为Pod的IP地址是由Docker
网桥分配的，所以可以将不同Node机器上的Docker网桥配置成不同的IP网段来实现这个功能。
然后需要在容器集群中创建一个覆盖网络来连接各个机器。</p>
<p><strong>目前可以通过第三方网络插件来覆盖网络，比如Flannel、Calico、Cilium。</strong></p>
<p>Flannel会配置Docker网桥（即docker0），通过修改Docker的启动参数bip来实现这一点。通过这种方式，集群中各台机器的Docker网桥就得到了全局唯一的IP网段，它所创建的容器自然也拥有全局唯一的IP。</p>
<p>Flannel还会修改路由表，使Flannel虚拟网卡可以接管容器并跨主机通信。</p>
<p>当一个节点的容器访问另一个节点的容器时，源节点上的数据会从docker0网桥路由到flannel0网卡，在目的节点处会从flannel0网卡路由到docker0网桥，然后再转发给目标容器。</p>
<p>Flannel运行在所有的Node机器上，重新规划了容器集群的网络。
这既保证了容器的IP地址的全局唯一性，又让不同机器上的容器能通过内网IP地址互相通信。</p>
<p>当然，容器的IP地址并不是固定的，IP地址的分配还由Docker来负责，Flannel只分配子网段。</p>
<p>跨Node的Pod之间的通信</p>
<img alt="../../_images/image-20220408172334170.png" src="../../_images/image-20220408172334170.png" />
<p>因为Pod的IP地址本身是虚拟IP，所以只有Kubernetes集群内部的机器（Master和Node）及其他Pod可以直接访问这个IP地址，集群之外的机器无法直接访问Pod的IP地址。</p>
<p>创建一个Nginx模板</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodfornginx</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">containerfornginx</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">nginx</span>
    <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
    <span class="nt">ports</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">portfoxnginx</span>
      <span class="nt">containerPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
      <span class="nt">protocol</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">TCP</span>
</pre></div>
</div>
<p>该模板在执行之后，可以通过<code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">get</span> <span class="pre">pod</span> <span class="pre">-o</span> <span class="pre">wide</span></code>命令查看Pod的虚拟IP地址</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplenginx.yml
$ kubectl get pod examplepodfornginx -o wide
NAME                 READY   STATUS    RESTARTS   AGE     IP            NODE            NOMINATED NODE   READINESS GATES
examplepodfornginx   <span class="m">1</span>/1     Running   <span class="m">0</span>          2m25s   <span class="m">10</span>.0.23.170   gitee-k8s-w28   &lt;none&gt;           &lt;none&gt;

<span class="c1"># node1节点</span>
$ curl <span class="m">10</span>.0.23.170
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
......
</pre></div>
</div>
<p>集群内部的任何机器都可以直接访问Pod的IP地址及containerPort中暴露的端口，可以执行以下命令访问Pod提供的服务
（也可以使用浏览器来访问，但前提是浏览器所在主机必须是集群内的Master或Node）。</p>
<p>要使集群外的机器访问Pod提供的服务，之前介绍过可以使用hostPort属性将它映射到Node宿主机的端口上，然后通过http://{Node主机IP}:{主机端口}的方式来访问。</p>
<p>前面已经提到，这并不是推荐方式。在Kubernetes中可使用Service和Ingress来发布服务</p>
</section>
</section>
</section>
</section>
<section id="id12">
<h2><a class="toc-backref" href="#id32">7.Pod的生命周期</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<section id="id13">
<h3><a class="toc-backref" href="#id33">7.1 Pod的相位</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Pending</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Pod已被Kubernetes系统接受，但尚有一个或多个容器镜像未能创建。
比如，调度前消耗的运算时间，以及通过网络下载镜像所消耗的时间，这些准备时间都会导致容器镜像未创建
</pre></div>
</div>
<ul class="simple">
<li><p>Running</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Pod已绑定到Node，所有的容器均已创建。至少有一个容器还在运行，或者正在启动或重新启动
</pre></div>
</div>
<ul class="simple">
<li><p>Succeeded</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Pod中的所有容器都已成功终止，并且不会重新启动
</pre></div>
</div>
<ul class="simple">
<li><p>Failed</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Pod中的所有容器都已终止，并且至少有一个容器表现出失败的终止状态。也就是说，容器要么以非零状态退出，要么被系统终止
</pre></div>
</div>
<ul class="simple">
<li><p>Unknown</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>由于某种原因，无法获得Pod的状态，这通常是Pod所在的宿主机通信出错而导致的
</pre></div>
</div>
<p>Pod相位的变更</p>
<img alt="../../_images/image-20220408173156247.png" src="../../_images/image-20220408173156247.png" />
<p>如果进入了Failed状态，通常有以下3种原因。</p>
<ul class="simple">
<li><p>Pod启动时，只要有一个容器运行失败，Pod将会从Pending状态进入Failed状态。</p></li>
<li><p>Pod正处于Running状态，若Pod中的一个容器突然损坏或在退出时状态码不为0，Pod将会从Running进入Failed状态。</p></li>
<li><p>在要求Pod正常关闭的时候，只要有一个容器退出的状态码不为0，Pod就会进入Failed状态。</p></li>
</ul>
</section>
<section id="id14">
<h3><a class="toc-backref" href="#id34">7.2 Pod的重启策略</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>PodSpec中有一个名为restartPolicy的字段，字段值为Always、OnFailure和Never中的一个。</p>
<p>restartPolicy对Pod中的所有容器有效，由Pod所在Node上的kubelet执行判断和重启操作。</p>
<p>由kubelet重新启动的已退出容器将会以递增延迟的方式（10s，20s，40s，…）尝试重新启动，上限时间为5min，延时的累加值会在成功运行10min后重置。</p>
<p>一旦Pod绑定到某个节点上，就绝对不会重新绑定到另一个节点上。</p>
<p>restartPolicy字段的值</p>
<ul class="simple">
<li><p>Always ：在容器失效时，立即重启</p></li>
<li><p>OnFailure：在容器终止运行且退出码不为0时重启</p></li>
<li><p>Never：不重启</p></li>
</ul>
<p><strong>重启策略对Pod状态的影响如下。</strong></p>
<p>假设有1个运行中的Pod，它拥有1个容器。容器退出成功后，
restartPolicy的不同设置的影响如下。
Always：重启容器，Pod相位仍为Running。 OnFailure：Pod相位变为Succeeded。
Never：Pod相位变为Succeeded。</p>
<p>假设有1个运行中的Pod，它拥有1个容器。容器退出失败后，
restartPolicy的不同设置的影响如下。
Always：重启容器，Pod相位仍为Running。
OnFailure：重启容器，Pod相位仍为Running。 Never：Pod相位变为Failed。</p>
<p>假设有1个运行中的Pod，它拥有两个容器。第1个容器退出失败
后，restartPolicy的不同设置的影响如下。
Always：重启容器，Pod相位仍为Running。
OnFailure：重启容器，Pod相位仍为Running。
Never：不会重启容器，Pod相位仍为Succeeded。</p>
<p>假设第1个容器没有运行起来，而第2个容器也退出了，此时
restartPolicy的不同设置的影响如下。
Always：重启容器，Pod相位仍为Running。
OnFailure：重启容器，Pod相位仍为Running。 Never：Pod相位变为Failed。</p>
<p>假设有1个运行中的Pod，它拥有1个容器。容器发生内存溢出后，
restartPolicy的不同设置的影响如下。
Always：重启容器，Pod相位仍为Running。
OnFailure：重启容器，Pod相位仍为Running。
Never：记录失败事件，Pod相位变为Failed。</p>
</section>
<section id="id15">
<h3><a class="toc-backref" href="#id35">7.3 Pod的创建与销毁过程</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p><strong>Pod的终止流程</strong></p>
<img alt="../../_images/image-20220408173716691.png" src="../../_images/image-20220408173716691.png" />
<p>删除操作的宽限时间默认为30s。kubectl
delete命令支持<code class="docutils literal notranslate"><span class="pre">--grace-period={秒}</span></code>选项，用户可以自定义宽限时间。</p>
<p>如果这个值设置为0，则表示强制删除Pod，但是在使用<code class="docutils literal notranslate"><span class="pre">--grace-period=0</span></code>时需要同时添加选项<code class="docutils literal notranslate"><span class="pre">--force</span></code>才能执行强制删除。</p>
</section>
<section id="id16">
<h3><a class="toc-backref" href="#id36">7.4 Pod的生命周期事件</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>在Pod的整个生命周期里，会经历两个大的阶段。第一个阶段是初始化容器运行阶段，第二个阶段是正式容器运行阶段。</p>
<p>每个大的阶段中都会有不同的生命周期事件。</p>
<img alt="../../_images/image-20220408174011774.png" src="../../_images/image-20220408174011774.png" />
<section id="id17">
<h4>1.初始化容器运行阶段<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>Pod中可以包含一个或多个初始化容器，它们是在应用程序容器正式运行之前而运行的专用容器（其中可以包含一些设定脚本或基础工具，它们主要负责初始化工作）。</p>
<p>初始化容器不能是长期运行的容器，而是在执行完一定操作后就必须结束的。</p>
<p>初始化容器不是同时运行的，而是按照既定顺序一个接一个地运行的。</p>
<p>在正式容器运行前，所有的初始化容器必须正常结束。</p>
<p>初始化容器的目的是将初始化逻辑与主体业务逻辑分离并放置在不同的镜像中。</p>
<p>初始化容器执行失败时，如果restartPolicy是OnFailure或者Always，那么会重复执行失败的初始化容器一直到成功；</p>
<p>如果restartPolicy是Never，则不会重启失败的初始化容器。</p>
<p>如果初始化容器执行成功，那么无论restartPolicy是什么，都不会再次重启。</p>
<p>初始化容器和正式容器能够定义的属性完全一样，但正式容器放在spec属性的containers下面，而初始化容器放在initContainers下面。</p>
<p>下面将用一个示例来说明初始化容器的使用方法。</p>
<p>假设要部署一个应用程序，但在部署前需要检查db是否就绪，并执行一些初始化脚本。</p>
<p><code class="docutils literal notranslate"><span class="pre">examplepodforinitcontainer.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodforinitcontainer</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">maincontainer</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">]</span>
    <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;maincontainer</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">running!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span><span class="p p-Indicator">]</span>
  <span class="nt">initContainers</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">initdbcheck</span>
      <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
      <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">]</span>
      <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;checking</span><span class="nv"> </span><span class="s">db!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">30;</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">&quot;checking</span><span class="nv"> </span><span class="s">done!&quot;&#39;</span><span class="p p-Indicator">]</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">initscript</span>
      <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
      <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">]</span>
      <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;init</span><span class="nv"> </span><span class="s">script</span><span class="nv"> </span><span class="s">exec!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">30;</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">&quot;init</span><span class="nv"> </span><span class="s">script</span><span class="nv"> </span><span class="s">exec</span><span class="nv"> </span><span class="s">done!&quot;&#39;</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>正式容器：</p>
<p>​ maincontainer</p>
<p>两个初始化容器：</p>
<ul class="simple">
<li><p>initdbcheck：执行初始化db检查</p></li>
<li><p>initscript： 执行初始化脚本</p></li>
</ul>
<p>创建Pod</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplepodforinitcontainer.yml
</pre></div>
</div>
<p>查看Pod的运行情况</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl get pods examplepodforinitcontainer
NAME                         READY   STATUS     RESTARTS   AGE
examplepodforinitcontainer   <span class="m">0</span>/1     Init:0/2   <span class="m">0</span>          <span class="m">15</span>
</pre></div>
</div>
<p>在30s内，因为还在执行第一个初始化容器，所以执行状态为Init:0/2</p>
<p>在30～60s时，执行第二个初始化容器，执行状态为Init:1/2</p>
<p>当所有初始化容器执行完时，容器就会先变为Pending，然后变为Running</p>
<p>同样，在不同的时间段执行logs命令，会得到不同的日志。</p>
<p>此时可使用如下命令查看容器的详细信息。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl describe pods examplepodforinitcontainer
</pre></div>
</div>
<p>按照之前设定的顺序，先执行initdbcheck，再执行initscript，初始化容器执行完之后，才运行maincontainer。</p>
<img alt="../../_images/image-20220408181905423.png" src="../../_images/image-20220408181905423.png" />
<p>下面的资源清单仅是一个初始化容器的使用示例，读者可自行创建并观察初始化容器的相关状态：</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-pod</span>
  <span class="nt">labels</span><span class="p">:</span>
    <span class="nt">app</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">myapp-container</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ikubernetes/myapp:v1</span>
  <span class="nt">initContainers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">init-something</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;sleep</span><span class="nv"> </span><span class="s">10&#39;</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<section id="init-container">
<h5>1.1 Init Container<a class="headerlink" href="#init-container" title="Permalink to this headline">¶</a></h5>
<p>Pod
能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个先于应用容器启动的
Init 容器。Init
容器在所有容器运行之前执行（run-to-completion），常用来初始化配置。</p>
<p>如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一行。 当所有的
Init 容器运行完成时，Kubernetes 初始化 Pod 并像平常一样运行应用容器。</p>
<p>下面是一个 Init 容器的示例：</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">init-demo</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">nginx</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">nginx</span>
    <span class="nt">ports</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">containerPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
    <span class="nt">volumeMounts</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">workdir</span>
      <span class="nt">mountPath</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/usr/share/nginx/html</span>
  <span class="c1"># These containers are run during pod initialization</span>
  <span class="nt">initContainers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">install</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">command</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">wget</span>
    <span class="p p-Indicator">-</span> <span class="s">&quot;-O&quot;</span>
    <span class="p p-Indicator">-</span> <span class="s">&quot;/work-dir/index.html&quot;</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">http://kubernetes.io</span>
    <span class="nt">volumeMounts</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">workdir</span>
      <span class="nt">mountPath</span><span class="p">:</span> <span class="s">&quot;/work-dir&quot;</span>
  <span class="nt">dnsPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Default</span>
  <span class="nt">volumes</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">workdir</span>
    <span class="nt">emptyDir</span><span class="p">:</span> <span class="p p-Indicator">{}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>它们可以包含并运行实用工具，出于安全考虑，是不建议在应用容器镜像中包含这些实用工具的。</p></li>
<li><p>它们可以包含使用工具和定制化代码来安装，但是不能出现在应用镜像中。例如，创建镜像没必要
FROM 另一个镜像，只需要在安装过程中使用类似 sed、 awk、 python 或 dig
这样的工具。</p></li>
<li><p>应用镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。</p></li>
<li><p>它们使用 Linux
Namespace，所以对应用容器具有不同的文件系统视图。因此，它们能够具有访问
Secret 的权限，而应用容器不能够访问。</p></li>
<li><p>它们在应用容器启动之前运行完成，然而应用容器并行运行，所以 Init
容器提供了一种简单的方式来阻塞或延迟应用容器的启动，直到满足了一组先决条件。</p></li>
</ul>
<p>Init 容器的资源计算，选择一下两者的较大值：</p>
<ul class="simple">
<li><p>所有 Init 容器中的资源使用的最大值</p></li>
<li><p>Pod 中所有容器资源使用的总和</p></li>
</ul>
<p>Init 容器的重启策略：</p>
<ul class="simple">
<li><p>如果 Init 容器执行失败，Pod 设置的 restartPolicy 为 Never，则 pod
将处于 fail 状态。否则 Pod 将一直重新执行每一个 Init 容器直到所有的
Init 容器都成功。</p></li>
<li><p>如果 Pod 异常退出，重新拉取 Pod 后，Init 容器也会被重新执行。所以在
Init 容器中执行的任务，需要保证是幂等的。</p></li>
</ul>
</section>
<section id="id18">
<h5>1.2 初始化容器常见案例<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h5>
<p>在 mountOptions 中设置 uid 和 gid
时失败，有时候需要设置挂载时候目录的属主和属组权限，默认持久存储卷挂载、或者cm进行挂载的权限为<code class="docutils literal notranslate"><span class="pre">root:root</span></code>且只读。这时候可以通过initcontainer容器进行权限修改。</p>
<p>可以通过执行以下操作之一来缓解此问题</p>
<ul class="simple">
<li><p>通过在 fsGroup 中的 runAsUser 和 gid 中设置 uid 来<a class="reference external" href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/">配置 pod
的安全上下文</a>。例如，以下设置会将
pod 设置为 root，使其可供任何文件访问：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apiVersion</span><span class="p">:</span> <span class="n">v1</span>
<span class="n">kind</span><span class="p">:</span> <span class="n">Pod</span>
<span class="n">metadata</span><span class="p">:</span>
  <span class="n">name</span><span class="p">:</span> <span class="n">security</span><span class="o">-</span><span class="n">context</span><span class="o">-</span><span class="n">demo</span>
<span class="n">spec</span><span class="p">:</span>
  <span class="n">securityContext</span><span class="p">:</span>
    <span class="n">runAsUser</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">fsGroup</span><span class="p">:</span> <span class="mi">0</span>
</pre></div>
</div>
<blockquote>
<div><p>备注: 因为 gid 和 uid 默认装载为 root 或0。如果 gid 或 uid
设置为非根（例如1000），则 Kubernetes 将使用
<code class="docutils literal notranslate"><span class="pre">chown</span></code>更改该磁盘下的所有目录和文件。此操作可能非常耗时，并且可能会导致装载磁盘的速度非常慢。</p>
</div></blockquote>
<ul class="simple">
<li><p>使用 initContainers 中的 <code class="docutils literal notranslate"><span class="pre">chown</span></code> 设置 gid 和 uid。例如:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initContainers</span><span class="p">:</span>
<span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">volume</span><span class="o">-</span><span class="n">mount</span>
  <span class="n">image</span><span class="p">:</span> <span class="n">busybox</span>
  <span class="n">command</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;sh&quot;</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;chown -R 100:100 /data&quot;</span><span class="p">]</span>
  <span class="n">volumeMounts</span><span class="p">:</span>
  <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">your</span> <span class="n">data</span> <span class="n">volume</span><span class="o">&gt;</span>
    <span class="n">mountPath</span><span class="p">:</span> <span class="o">/</span><span class="n">data</span>
</pre></div>
</div>
</section>
</section>
<section id="id19">
<h4>2.正式容器运行阶段<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>初始化容器运行完成后，就会开始启动正式容器。在正式容器运行期间，都会有与之对应的生命周期事件。</p>
<p>在正式容器刚刚创建成功之后，就会触发PostStart事件。而在整个容器持续运行的过程中，可以设置存活探针（liveness
probe）和 就绪探针（readiness probe）来持续检查容器的健康状况。</p>
<p>而在容器结束前，会触发PreStop事件。</p>
<p>如果要在容器创建后或停止前执行某些操作，则可以注册以下两个事件的回调。</p>
<ul class="simple">
<li><p>PostStart：容器刚刚创建成功后，触发事件，执行回调。如果回调中的操作执行失败，则该容器会被终止，并根据该容器的重启策略决定是否要重启该容器。</p></li>
<li><p>PreStop：容器开始和结束前，触发事件，执行回调。无论回调执行结果如何，都会结束容器。</p></li>
</ul>
<p>回调的实现方式有两种（一种是Exec，一种是HttpGet）</p>
<p>Exec</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">postStart或preStop</span><span class="p">:</span>
  <span class="n">exec</span><span class="p">:</span>
    <span class="n">command</span><span class="p">:</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="c1">#命令列表</span>
</pre></div>
</div>
<p>HttpGet</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">postStart或preStop</span><span class="p">:</span>
  <span class="n">httpGet</span><span class="p">:</span>
    <span class="n">host</span><span class="p">:</span> <span class="n">String</span> <span class="c1">#请求的IP地址或域名</span>
    <span class="n">port</span><span class="p">:</span> <span class="n">Number</span> <span class="c1">#请求的端口号</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">String</span> <span class="c1">#请求的路径（例如，www.baidu.com/tieba，&quot;/tieba&quot;就是路径）</span>
    <span class="n">scheme</span><span class="p">:</span> <span class="n">String</span> <span class="c1">#请求的协议，默认是为HTTP</span>
</pre></div>
</div>
<p>演示使用PostStart事件和PreStop事件</p>
<p><code class="docutils literal notranslate"><span class="pre">examplepodforpoststartandprestop.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodforpoststartandprestop</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">poststartandprestop-container</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">]</span>
    <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;Hello</span><span class="nv"> </span><span class="s">Kubernetes!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span><span class="p p-Indicator">]</span>
    <span class="nt">lifecycle</span><span class="p">:</span>
      <span class="nt">postStart</span><span class="p">:</span>
        <span class="nt">httpGet</span><span class="p">:</span>
          <span class="nt">host</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">www.baidu.com</span>
          <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/</span>
          <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
          <span class="nt">scheme</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">HTTP</span>
      <span class="nt">preStop</span><span class="p">:</span>
        <span class="nt">exec</span><span class="p">:</span>
          <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;preStop</span><span class="nv"> </span><span class="s">callback</span><span class="nv"> </span><span class="s">done!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">60&#39;</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>在这个例子中，我们用postStart事件执行HttpGet回调，回调请求baidu页面，preStop则执行命令并输出一段文本，之后停留60s。</p>
<p>如果执行上面的Pod模板，Pod会创建成功。但现在我们先来做一些实验，修改Pod模板，将postStart事件的baidu网址故意改错，如下所示。</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodforpoststartandprestop</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">poststartandprestop-container</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
    <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
    <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">]</span>
    <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;Hello</span><span class="nv"> </span><span class="s">Kubernetes!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span><span class="p p-Indicator">]</span>
    <span class="nt">lifecycle</span><span class="p">:</span>
      <span class="nt">postStart</span><span class="p">:</span>
        <span class="nt">httpGet</span><span class="p">:</span>
          <span class="nt">host</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">www.baiduxxxx.com</span>
          <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/</span>
          <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
          <span class="nt">scheme</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">HTTP</span>
      <span class="nt">preStop</span><span class="p">:</span>
        <span class="nt">exec</span><span class="p">:</span>
          <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;-c&#39;</span><span class="p p-Indicator">,</span> <span class="s">&#39;echo</span><span class="nv"> </span><span class="s">&quot;preStop</span><span class="nv"> </span><span class="s">callback</span><span class="nv"> </span><span class="s">done!&quot;;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">60&#39;</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplepodforpoststartandprestop.yml
</pre></div>
</div>
<p>执行后等待一段时间，再执行</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl get pod examplepodforpoststartandprestop
NAME                               READY   STATUS              RESTARTS   AGE
examplepodforpoststartandprestop   <span class="m">0</span>/1     ContainerCreating   <span class="m">0</span>          2m5s
</pre></div>
</div>
<p>可以看到，Pod并没有创建成功</p>
<p>执行</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl describe pods examplepodforpoststartandprestop
</pre></div>
</div>
<p>查看最下面的运行结果可以发现，容器成功创建后执行了postStart回调，因为我们给出的网址是错误的，发出请求后无法顺利获取响应，所以回调执行失败，失败后容器被终止。</p>
<img alt="../../_images/image-20220408183032998.png" src="../../_images/image-20220408183032998.png" />
<p>删除刚才创建的Pod</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 默认宽限时间默认为30s</span>
$ kubectl delete pod examplepodforpoststartandprestop

<span class="c1"># 强制快速删除</span>
$ kubectl delete pod examplepodforpoststartandprestop --grace-period<span class="o">=</span><span class="m">0</span> --force
</pre></div>
</div>
<p>将postStart事件的网址改回正确网址.Pod将会正常创建。</p>
</section>
</section>
</section>
<section id="id20">
<h2><a class="toc-backref" href="#id37">8.Pod的健康检查</a><a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
<p>在容器运行期间，可以设置两种探针来持续检查容器的健康状况。</p>
<ul class="simple">
<li><p>存活探针（liveness
probe）：测定容器是否正在运行。如果存活探针返回Failure，kubelet会终止容器，然后容器会遵循其重启策略。如果没有给容器提供存活探针，默认状态就是Success。</p></li>
<li><p>就绪探针（readiness
probe）：测定容器是否已准备好为请求提供服务。如果就绪探针返回Failure，Endpoint控制器会从所有Service的Endpoint中移除此Pod的IP地址。在初始等待探测时间（即容器启动之后并在第一次探测之前的时间间隔）之内，默认的就绪状态是Failure。如果没有给容器提供就绪探针，默认状态为Success。</p></li>
</ul>
<p>每个探针都会返回以下3种结果之一。</p>
<ul class="simple">
<li><p>Success：容器通过诊断。</p></li>
<li><p>Failure：容器没有通过诊断。</p></li>
<li><p>Unknown：诊断失败，不会采取任何措施。</p></li>
</ul>
<p>诊断是如何执行的呢？kubelet会调用容器配置中定义的测定方案来执行诊断，<strong>一共有3种测定方案。</strong></p>
<ul class="simple">
<li><p>ExecAction：在容器内部执行指定的命令。如果命令以状态码“0”退出，则测定为诊断成功。其配置方式如下。</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">livenessProbe或readinessProbe</span><span class="p">:</span>
  <span class="n">exec</span><span class="p">:</span>
    <span class="n">command</span><span class="p">:</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="c1">#命令列表</span>
</pre></div>
</div>
<ul class="simple">
<li><p>TCPSocketAction：对容器IP地址的指定端口执行TCP检测。如果端口是打开的，则测定为诊断成功。其配置方式如下。</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">livenessProbe或readinessProbe</span><span class="p">:</span>
  <span class="n">tcpSocket</span><span class="p">:</span>
    <span class="n">port</span><span class="p">:</span> <span class="n">Number</span> <span class="c1">#指定的端口号</span>
</pre></div>
</div>
<ul class="simple">
<li><p>HTTPGetAction：对容器IP地址的指定端口和路径执行HttpGet请求。如果响应的状态码范围为200～400，则测定为诊断成功。其配置方式如下。</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">livenessProbe或readinessProbe</span><span class="p">:</span>
  <span class="n">httpGet</span><span class="p">:</span>
    <span class="n">port</span><span class="p">:</span> <span class="n">Number</span> <span class="c1">#指定的端口号</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">String</span> <span class="c1">#指定的路径（例如，www.baidu.com/tieba，&quot;/tieba&quot;就是路径）</span>
</pre></div>
</div>
<p><strong>示例</strong></p>
<section id="id21">
<h3><a class="toc-backref" href="#id38">1.存活探针的使用</a><a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>示例1：使用存活探针，方案为ExecAction。</p>
<p><code class="docutils literal notranslate"><span class="pre">examplepodforliveness.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodforliveness</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">livenesscontainer</span>
      <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">busybox</span>
      <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
      <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;sh&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;-c&#39;</span><span class="p p-Indicator">]</span>
      <span class="nt">args</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;mkdir</span><span class="nv"> </span><span class="s">/files_dir;</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">&quot;important</span><span class="nv"> </span><span class="s">data&quot;</span><span class="nv"> </span><span class="s">&gt;</span><span class="nv"> </span><span class="s">/files_dir/importantfile;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600&#39;</span><span class="p p-Indicator">]</span>
      <span class="nt">livenessProbe</span><span class="p">:</span>
        <span class="nt">exec</span><span class="p">:</span>
          <span class="nt">command</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;cat&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;/files_dir/importantfile&#39;</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplepodforliveness.yml
</pre></div>
</div>
<p>接下来，通过<code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">get</span> <span class="pre">pods</span></code>命令查看Pod的运行情况，直到状态变为Running</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl get pod
NAME                               READY   STATUS    RESTARTS   AGE
examplepodforliveness              <span class="m">1</span>/1     Running   <span class="m">0</span>          54s
</pre></div>
</div>
<p>目前来说一切正常，现在我们来做一些破坏性操作。执行以下命令直接进入Pod内部，这相当于进入Pod容器里面的CMD界面。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl <span class="nb">exec</span> -it pod/examplepodforliveness -- sh
/ <span class="c1"># rm -f /files_dir/importantfile</span>
</pre></div>
</div>
<p>由于探针定期检测/files_dir/importantfile文件是否存在，因此存活探针会返回Failure，可以使用以下命令查看Pod描述。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl describe pods examplepodforliveness
</pre></div>
</div>
<p>稍等一会儿，通过$ kubectl get
pods命令查看Pod的运行情况，可以看到Pod已经重启过一次</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl get pod
NAME                    READY   STATUS    RESTARTS   AGE
examplepodforliveness   <span class="m">1</span>/1     Running   <span class="m">1</span>          2m52s
</pre></div>
</div>
</section>
<section id="id22">
<h3><a class="toc-backref" href="#id39">2.就绪探针的使用</a><a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>示例2：使用就绪探针，方案为HTTPGetAction。</p>
<p><code class="docutils literal notranslate"><span class="pre">examplepodforreadiness.yml</span></code></p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">v1</span>
<span class="nt">kind</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pod</span>
<span class="nt">metadata</span><span class="p">:</span>
  <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">examplepodforreadiness</span>
<span class="nt">spec</span><span class="p">:</span>
  <span class="nt">containers</span><span class="p">:</span>
  <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">readinesscontainer</span>
    <span class="nt">image</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">nginx</span>
    <span class="nt">imagePullPolicy</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">IfNotPresent</span>
    <span class="nt">ports</span><span class="p">:</span>
    <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">portfoxnginx</span>
      <span class="nt">containerPort</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
    <span class="nt">livenessProbe</span><span class="p">:</span>
      <span class="nt">httpGet</span><span class="p">:</span>
        <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">80</span>
        <span class="nt">path</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">/</span>
</pre></div>
</div>
<p>我们创建了一个Nginx容器，Nginx镜像中默认定义的对外提供服务的端口为80，通过containerPort属性，我们将80端口暴露出来。</p>
<p>然后，为该容器设置的一个就绪探测会定期向“容器IP:80”发送HttpGet请求，检测响应范围是否为200～400。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl apply -f examplepodforreadiness.yml
</pre></div>
</div>
<p>接下来，通过<code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">get</span> <span class="pre">pods</span></code>命令，查看Pod的运行情况，直到状态变为Running</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl <span class="nb">exec</span> -ti examplepodforreadiness -- /bin/sh
</pre></div>
</div>
<p>接下来，执行以下命令，直接将Nginx服务强制停止。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ nginx -s stop
</pre></div>
</div>
<p>执行后退出Pod容器里面的命令行界面</p>
<p>退出后，使用以下命令查看Pod的描述。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl describe pods examplepodforreadiness
</pre></div>
</div>
<p>由于设置了就绪探针，因此当Nginx服务不可用时，无法通过HttpGet访问“容器IP:80”，若就绪探针返回Failure，将会重启Pod。</p>
<img alt="../../_images/image-20220408185138592.png" src="../../_images/image-20220408185138592.png" />
<p>通过<code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">get</span> <span class="pre">pods</span></code>命令，查看Pod的运行情况，可以看到Pod已经重启过一次</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ kubectl get pod
NAME                     READY   STATUS    RESTARTS   AGE
examplepodforreadiness   <span class="m">1</span>/1     Running   <span class="m">1</span>          3m26s
</pre></div>
</div>
<p><strong>存活探针</strong>和<strong>就绪探针</strong>在使用上有什么区别呢？哪种情况下该使用存活探针，哪种情况下该使用就绪探针呢？这里给出的建议如下。</p>
<ol class="arabic simple">
<li><p>如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活探针，kubelet会根据Pod的重启策略自动执行正确的操作。</p></li>
<li><p>如果想在探针测试失败时终止并重启容器，则可以指定存活探针，并将重启策略设置为Always或OnFailure。</p></li>
<li><p>如果容器需要在启动期间处理大型数据、配置文件或迁移，请指定就绪探针。</p></li>
<li><p>如果希望容器能够自己停机进行维护，则可以指定就绪探针，用它去检查与存活探针不同的端点。</p></li>
<li><p>如果只想在探针成功时才对Pod发送网络流量，则可以指定就绪探针。在这种情况下，就绪探针和存活探针看似相差不大，但就绪探针的存在意味着Pod将在不会接收到任何网络流量的情况下启动。只有在探针开始成功时，才会开始接收流量。</p></li>
<li><p>如果只希望在删除Pod时排除请求，则不必使用就绪探针。无论有没有就绪探针，Pod在删除时都会自动将自己设置成未就绪状态。在等待Pod中的容器完全停止的时候，Pod已处于未就绪状态。</p></li>
</ol>
<p>对于每种探针，还可以设置5个参数，它们分别如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>initialDelaySeconds：启动容器后首次监控检查的等待时间，单位为秒。

timeoutSeconds：发送健康检查请求后等待响应的超时时间，单位为秒。当发生超时就认为探测失败。timeoutSeconds的默认值为10s，最小值为1s。

periodSeconds：探针的执行周期。默认10s执行一次，最小值为1s。

successThreshold：如果出现失败，则需要连续探测成功多次才能测定为诊断成功。successThreshold的默认值和最小值都是1。

failureThreshold：如果出现测定失败，则要连续失败多次才重启Pod（对于存活探针）或标记为Unready（对于就绪探针）。failureThreshold的默认值为3，最小值为1。
</pre></div>
</div>
<p>具体设置方法如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">livenessProbe或readinessProbe</span><span class="p">:</span>
    <span class="n">exec或tcpSocket或httpGet</span><span class="p">:</span>
        <span class="n">initialDelaySeconds</span><span class="p">:</span> <span class="n">Number</span>
        <span class="n">initialDelaySeconds</span><span class="p">:</span> <span class="n">Number</span>
        <span class="n">periodSeconds</span><span class="p">:</span> <span class="n">Number</span>
        <span class="n">successThreshold</span><span class="p">:</span> <span class="n">Number</span>
        <span class="n">failureThreshold</span><span class="p">:</span> <span class="n">Number</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="4.Pod的基本操作" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../5.%E6%8E%A7%E5%88%B6%E5%99%A8/index.html" class="btn btn-neutral float-right" title="5.控制器" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, huxiaojian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>